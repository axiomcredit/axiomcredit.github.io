{"version":3,"sources":["webpack:///static/js/3.96bcd54e618754c46765.js","webpack:///./src/modules/supplier/index.vue","webpack:///./node_modules/q/q.js","webpack:///./src/api/odata.js","webpack:///./node_modules/odata/o.js","webpack:///./node_modules/xhr2/lib/browser.js","webpack:///./src/modules/supplier/index.vue?72e5","webpack:///./src/modules/supplier/index.vue?c52b","webpack:///src/modules/supplier/index.vue","webpack:///./src/modules/supplier/_nav.js","webpack:///./node_modules/signalr-no-jquery/build/signalR.js","webpack:///./node_modules/signalr-no-jquery/build/jQueryShim.js","webpack:///./node_modules/jquery-deferred/index.js","webpack:///./node_modules/jquery-deferred/lib/jquery-deferred.js","webpack:///./node_modules/jquery-deferred/lib/jquery-callbacks.js","webpack:///./node_modules/jquery-deferred/lib/jquery-core.js","webpack:///./node_modules/jquery-param/jquery-param.js","webpack:///./src/modules/supplier/store/index.js","webpack:///./src/modules/supplier/index.vue?e5f3"],"names":["webpackJsonp","484","module","__webpack_exports__","__webpack_require__","injectStyle","ssrContext","Object","defineProperty","value","__WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__","__WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e231a1e4_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__","normalizeComponent","__vue_styles__","Component","500","exports","process","setImmediate","definition","bootstrap","uncurryThis","f","call","apply","arguments","isObject","isStopIteration","exception","object_toString","QReturnValue","makeStackTraceLong","error","promise","hasStacks","stack","stacks","p","source","__minimumStackCounter__","stackCounter","object_defineProperty","configurable","unshift","concatedStacks","join","STACK_JUMP_SEPARATOR","filterStackString","stackString","lines","split","desiredLines","i","length","line","isInternalFrame","isNodeFrame","push","stackLine","indexOf","getFileNameAndLineNumber","attempt1","exec","Number","attempt2","attempt3","fileNameAndLineNumber","fileName","lineNumber","qFileName","qStartingLine","qEndingLine","captureLine","Error","e","firstLine","Q","Promise","isPromiseAlike","coerce","fulfill","defer","become","newPromise","resolvedPromise","longStackSupport","array_reduce","messages","undefined","message","nextTick","promiseDispatch","progressListeners","deferred","object_create","prototype","resolve","op","operands","args","array_slice","valueOf","nearerValue","nearer","isPromise","inspect","state","substring","longStackCounter","reject","reason","notify","progress","progressListener","resolver","TypeError","race","answerPs","len","then","descriptor","fallback","result","inspected","when","fulfilled","rejected","progressed","object","isPending","isFulfilled","isRejected","resetUnhandledRejections","unhandledReasons","unhandledRejections","trackUnhandledRejections","trackRejection","emit","runAfter","array_indexOf","reportedUnhandledRejections","untrackRejection","at","atReport","splice","rejection","this","get","name","set","rhs","delete","post","thisp","keys","object_keys","master","isDef","dispatch","spread","async","makeGenerator","continuer","verb","arg","StopIteration","generator","done","callback","errback","bind","spawn","_return","promised","all","self","promises","pendingCount","index","snapshot","any","prev","current","onFulfilled","onRejected","err","onProgress","allResolved","array_map","noop","allSettled","nodeify","nodeback","flush","task","domain","head","next","enter","runSingle","laterQueue","pop","flushing","isNodeJS","exit","setTimeout","tail","requestTick","toString","window","MessageChannel","channel","port1","onmessage","requestPortTick","port2","postMessage","Function","Array","slice","reduce","basis","map","collect","create","Type","obj","prop","object_hasOwnProperty","hasOwnProperty","key","ReturnValue","NODE_ENV","Q_DEBUG","makeNodeResolver","passByCopy","x","y","that","makePromise","_fulfilled","_rejected","newException","_progressed","newValue","threw","onerror","tap","fcall","thenResolve","thenReject","getUnhandledReasons","stopUnhandledRejectionTracking","array","del","mapply","send","mcall","invoke","fapply","fbind","concat","alternative","console","warn","regardless","fail","fin","onUnhandledError","timeout","ms","timeoutId","code","clearTimeout","delay","nfapply","nodeArgs","nfcall","nfbind","denodeify","baseArgs","nbind","bound","nmapply","npost","nsend","nmcall","ninvoke","noConflict","570","o","config","endpoint","571","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","res","merge","il","base","oConfig","format","autoFormat","version","strictMode","start","ready","headers","username","password","isAsync","isCors","openAjaxRequests","isHashRoute","appending","isEndpoint","oData","initPromise","buildFilterByData","column","filterList","operation","combine","isArray","arr","buildSearchFilter","searchColumns","searchWord","searchFunc","searchWordSplit","isNotExactSearch","columnArr","wordArr","m","buildQuery","overrideRes","resource","path","throwEx","queryStr","endsWith","internalParam","getQuery","tempStr","queryName","query","queryList","strFormat","checkRoute","hash","r","routeList","route","regex","test","param","matches","beforeRoutingFunc","startRouteRequest","buildRouteRegex","routeStr","routeRegex","RegExp","startsWith","routeArr","deepCopy","JSON","parse","stringify","jsToOdata","str","regexp","replace","opertionMapping","addNewResource","resourceList","parseUri","isQuery","addQuery","startRequest","errorCallback","isSave","ajaxReq","createCORSRequest","method","countMethod","isXDomainRequest","startAjaxReq","data","removeResource","guid","generateUUID","buildBatchBody","expandResource","expandStr","$expand","original","resSplit","uri","reqObj","querySplit","pair","uriSplit","queryValue","queryOriginal","queryPseudonym","appendQuery","appendType","removeQuery","isQueryThrowEx","queries","queryNames","isIn","d","Date","getTime","c","Math","random","floor","checkEmpty","throwName","tryParseInt","defaultValue","retValue","isNaN","parseInt","methodNames","count","spliceArr","suffix","s","msg","oException","log","batchGuid","body","changsetGuid","isChangeset","hostname","k","header","ajaxRequest","isBatch","overideLoading","tempBase","onload","readyState","status","onreadystatechange","onprogress","dataArray","responseText","parseResponse","currentPromise","errResponse","ex","endLoading","setRequestHeader","encodeBase64","isError","response","raw","inlinecount","url","xhr","XMLHttpRequest","withCredentials","open","XDomainRequest","para","Base64","_keyStr","encode","input","chr1","chr2","chr3","enc1","enc2","enc3","enc4","output","_utf8_encode","charCodeAt","charAt","string","utftext","n","String","fromCharCode","==","===","!=","!==",">",">=","<","<=","&&","||","!","*","%","routes","prevHash","location","interval","setInterval","triggerRoute","beforeRouting","beforeFunc","find","getId","top","take","takeAmount","skip","skipAmount","first","filter","where","filterStr","filterVal","orderBy","orderStr","direction","orderByDesc","select","selectStr","inlineCount","countOption","batch","expand","loading","func1","func2","ref","link","navPath","id","newResource","baseRes","@odata.id","removeRef","deleteRef","save","patch","put","remove","search","isSupported","searchStr","filterByList","exclude","include","progressFunc","toUpperCase","routeName","572","617","content","locals","618","sources","names","mappings","file","sourceRoot","619","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default","__WEBPACK_IMPORTED_MODULE_1__nav__","__WEBPACK_IMPORTED_MODULE_2__components___","__WEBPACK_IMPORTED_MODULE_3_vuex__","__WEBPACK_IMPORTED_MODULE_4_signalr_no_jquery__","__WEBPACK_IMPORTED_MODULE_5__store__","components","AppHeader","Sidebar","nav","items","computed","supplier","$route","list","matched","created","$store","registerModule","connection","createHubProxy","on","jsonp","mounted","620","icon","621","_typeof","Symbol","iterator","constructor","jQueryShim","$","validateTransport","requestedTransport","transport","type","_signalR","transports","_","ieVersion","getDefaultPort","protocol","addDefaultPort","match","ConnectingMessageBuffer","drainCallback","buffer","tryBuffer","signalR","connectionState","connecting","drain","connected","shift","clear","resources","nojQuery","noTransportOnInit","errorOnNegotiate","stoppedWhileLoading","stoppedWhileNegotiating","errorParsingNegotiateResponse","errorDuringStartRequest","stoppedDuringStartRequest","errorParsingStartResponse","invalidStartResponse","protocolIncompatible","sendFailed","parseFailed","longPollFailed","eventSourceFailedToConnect","eventSourceError","webSocketClosed","pingServerFailedInvalidResponse","pingServerFailed","pingServerFailedStatusCode","pingServerFailedParse","noConnectionTransport","webSocketsInvalidState","reconnectTimeout","reconnectWindowTimeout","_connection","_pageLoaded","document","_pageWindow","events","onStart","onStarting","onReceived","onError","onConnectionSlow","onReconnecting","onReconnect","onStateChanged","onDisconnect","ajaxDefaults","processData","global","cache","_log","logging","toTimeString","debug","changeState","expectedState","newState","triggerHandler","oldState","isDisconnecting","disconnected","supportsKeepAlive","keepAliveData","activated","configureStopReconnectingTimeout","stopReconnectingTimeout","onReconnectTimeout","configuredStopReconnectingTimeout","disconnectTimeout","stop","reconnecting","stateChanged","qs","fn","init","defaultContentType","navigator","appName","userAgent","parseFloat","context","transportError","firefoxMajorVersion","configurePingInterval","onFail","pingIntervalId","pingInterval","_logic","pingServer","hub","load","$connection","lastError","connectingMessageBuffer","lastMessageAt","lastActiveAt","beatInterval","beatHandle","totalTransportConnectTimeout","_parseResponse","json","_originalJson","isCrossDomain","against","trim","createElement","href","host","ajaxDataType","contentType","clientProtocol","reconnectDelay","transportConnectTimeout","reconnectWindow","keepAliveWarnAt","options","_initialize","waitForPageLoad","_deferral","Deferred","parser","extend","deferredStartHandler","baseUrl","wsProtocol","support","cors","initHandler","noTransportError","transportName","onFallback","isFirefox11OrGreater","asyncAbort","monitorKeepAlive","startHeartbeat","onFailed","negotiateRequest","prepareQueryString","ajax","_error","statusText","success","protocolError","supportedTransports","appRelativeUrl","Url","ConnectionId","token","ConnectionToken","webSocketServerUrl","WebSocketServerUrl","pollTimeout","ConnectionTimeout","DisconnectTimeout","TransportConnectTimeout","KeepAliveTimeout","timeoutWarning","ProtocolVersion","each","TryWebSockets","inArray","starting","received","errorData","sendData","connectionSlow","reconnected","notifyServer","deferral","unbind","clearInterval","abort","stopMonitoringKeepAlive","messageId","groupsToken","beat","monitoring","checkIfAlive","transportLogic","markActive","timeElapsed","lostConnection","userNotified","getAjaxUrl","InitHandler","startRequested","startCompleted","connectionStopped","onSuccess","failCalled","initReceived","transportFailed","transportTimeoutHandle","tryAbortStartRequest","ajaxStart","wrappedError","xhrFields","dataType","addQs","Response","_error2","preparedUrl","encodeURIComponent","firstChar","appender","getUrl","poll","ajaxPost","maximizePersistentResponse","minPersistentResponse","MessageId","C","Messages","M","Initialized","S","ShouldReconnect","T","LongPollDelay","L","GroupsToken","G","updateGroups","stringifySend","ajaxSend","payload","triggerReceived","_error3","textStatus","ajaxAbort","rejectDeferred","triggerStartError","_error4","tryInitialize","persistentResponse","onInitialized","processMessages","minData","markLastMessage","reconnectKeepAliveUpdate","verifyLastActive","isConnectedOrReconnecting","ensureReconnectingState","clearReconnectTimeout","reconnect","handleParseFailure","foreverFrame","connections","webSockets","socket","opened","WebSocket","onopen","onclose","event","wasClean","isEmptyObject","close","clearReconnectAttemptTimeout","reconnectAttemptTimeoutHandle","serverSentEvents","timeOut","eventSource","EventSource","Message","OPEN","addEventListener","eventPhase","CLOSED","createFrame","frame","setAttribute","loadPreventer","loadingFixIntervalId","attachedTo","prevent","tempFrame","appendChild","removeChild","cancel","iframeClearThreshold","frameId","frameLoadHandler","documentElement","attachEvent","src","receive","cw","frameMessageCount","contentWindow","contentDocument","firstChild","execCommand","parentNode","getConnection","started","longPolling","_fireConnect","tryFailConnect","privateData","reconnectErrors","fireReconnected","instance","reconnectTimeoutId","pollXhr","pollTimeoutId","raiseReconnect","connect","polling","postData","shouldReconnect","min","pow","makeEventName","eventNamespace","fun","getArgValue","a","isFunction","hasMembers","clearInvocationCallbacks","callbacks","invocationCallbacks","invocationCallbackId","callbackId","scope","E","hubProxy","hubConnection","hubName","settings","useDefaultPath","callbackMap","hasSubscriptions","eventName","toLowerCase","off","callbackSpace","methodName","makeArray","argValues","H","A","I","minResult","_maximizeHubResponse","State","Progress","notifyWith","Data","progressjQueryVersionLogged","jquery","StackTrace","IsHubException","ErrorData","rejectWith","resolveWith","Result","minHubResponse","R","P","Id","D","proxies","proxy","dataCallbackId","_maximizeClientHubInvocation","Method","Hub","Args","errData","origData","minClientHubInvocation","_registerSubscribedHubs","_subscribedToHubs","subscribedHubs","622","jQueryDeferred","jQueryParam","jqueryFunction","subject","0","handler","removeEventListener","handlers","idx","_this","forEach","request","_hasError","defaultAjaxHeaders","item","xhrObj","623","624","jQuery","core_slice","func","tuples","Callbacks","always","fns","newDefer","tuple","action","returned","pipe","stateString","add","disable","lock","fire","fireWith","subordinate","progressValues","progressContexts","resolveContexts","resolveValues","remaining","updateFunc","contexts","values","625","createOptions","optionsCache","core_rspace","flag","memory","fired","firing","firingStart","firingLength","firingIndex","once","stopOnFalse","unique","has","empty","disabled","locked","626","class2type","isObj","isPlainObject","copy","copyIsArray","clone","target","deep","627","rbracket","v","buildParams","prefix","628","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__","__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default","__WEBPACK_IMPORTED_MODULE_1__api_odata__","namespaced","currentApplicant","actions","GET_SUPPLIER","commit","SAVE_OFFER","_ref","offer","GET_OFFER_APPLICATIONS","_ref2","offerId","getters","offers","Offers","mutations","SUPPLIER_UPDATED","ADD_OFFER","629","render","_vm","_h","$createElement","_c","_self","staticClass","_v","attrs","navItems","staticRenderFns","esExports"],"mappings":"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","file":"static/js/3.96bcd54e618754c46765.js","sourcesContent":["webpackJsonp([3],{\n\n/***/ 484:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__ = __webpack_require__(619);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e231a1e4_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__ = __webpack_require__(629);\nfunction injectStyle (ssrContext) {\n  __webpack_require__(617)\n}\nvar normalizeComponent = __webpack_require__(4)\n/* script */\n\n/* template */\n\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-e231a1e4\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __WEBPACK_IMPORTED_MODULE_0__babel_loader_node_modules_vue_loader_lib_selector_type_script_index_0_index_vue__[\"a\" /* default */],\n  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_e231a1e4_hasScoped_true_buble_transforms_node_modules_vue_loader_lib_selector_type_template_index_0_index_vue__[\"a\" /* default */],\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Component.exports);\n\n\n/***/ }),\n\n/***/ 500:\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (true) {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.toString()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        var stack = filterStackString(concatedStacks);\n        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */\nvar longStackCounter = 1;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && Object({\"NODE_ENV\":\"production\"}) && Object({\"NODE_ENV\":\"production\"}).Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n            promise.stackCounter = longStackCounter++;\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n\n        if (Q.longStackSupport && hasStacks) {\n            // Only hold a reference to the new promise if long stacks\n            // are enabled to reduce memory usage\n            promise.source = newPromise;\n        }\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected(err) {\n            pendingCount--;\n            if (pendingCount === 0) {\n                var rejection = err || new Error(\"\" + err);\n\n                rejection.message = (\"Q can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected. Last error message: \" + rejection.message);\n\n                deferred.reject(rejection);\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n        throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n        throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(224), __webpack_require__(225).setImmediate))\n\n/***/ }),\n\n/***/ 570:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar o = __webpack_require__(571);\n\no().config({\n  endpoint: 'http://axiomcredit-001-site1.etempurl.com/odata'\n});\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (o);\n\n/***/ }),\n\n/***/ 571:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// +++\r\n// o.js  v0.3.7\r\n//\r\n// o.js is a simple oData wrapper for JavaScript.\r\n// Currently supporting the following operations:\r\n// .get() / .post() / .put() / .delete() / .first()  / .take() / .skip() / .filter() / .orderBy() / .orderByDesc() / .count() /.search() / .select() / .any() / .ref() / .deleteRef()\r\n//\r\n// By Jan Hommes\r\n// Date: 11/08/2017\r\n// Contributors: Matteo Antony Mistretta (https://github.com/IceOnFire), \r\n//\r\n// --------------------\r\n// The MIT License (MIT)\r\n//\r\n// Copyright (c) 2017 Jan Hommes\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n// +++\r\n; (function (root, factory) {\r\n    if (true) {\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(500)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('q'));\r\n    } else {\r\n        root.o = factory(root.Q);\r\n    }\r\n}(this, function (Q) {\r\n    function o(res) {\r\n        var base = this;\r\n\r\n        //base config object\r\n        base.oConfig = base.oConfig || {\r\n            endpoint: null,\r\n            format: 'json', \t// The media format. Default is JSON.\r\n            autoFormat: true,   // Will always append a $format=json to each query if set to true.\r\n            version: 4, \t\t// currently only tested for Version 4. Most will work in version 3 as well.\r\n            strictMode: true, \t// strict mode throws exception, non strict mode only logs them\r\n            start: null, \t\t// a function which is executed on loading\r\n            ready: null,\t\t// a function which is executed on ready\r\n            error: null,\t\t// a function which is executed on error\r\n            headers: [],\t\t// an array of additional headers [{name:'headername',value:'headervalue'}]\r\n            username: null, \t// the basic auth username\r\n            password: null,\t\t// the basic auth password\r\n            isAsync: true,\t\t// set this to false to enable sync requests. Only usable without basic auth\r\n            isCors: true,       // set this to false to disable CORS\r\n            openAjaxRequests: 0,// a counter for all open ajax request to determine that are all ready TODO: Move this out of the config\r\n            isHashRoute: true,  // set this var to false to disable automatic #-hash setting on routes\r\n            appending: ''\t\t// set this value to append something to a any request. eg.: [{name:'apikey', value:'xyz'}]\r\n        };\r\n\r\n        // +++\r\n        // Configuration of the oData endpoint\r\n        //\r\n        // endpoint: Name of the endpoint e.g. http(s)://MyDomain/ServiceName.svc\r\n        // json: Use json, true or false (currently only json supported)\r\n        // version: Define the oData Version. (currently only Version 3 and 4 are supported)\r\n        // strictMode: In strict mode exceptions are thrown, else they are logged\r\n        // start: A function which is executed on loading\r\n        // ready: A function which is executed on finished loading\r\n        // headers: An array of additional headers [{name:'headername',value:'headervalue'}]\r\n        // username: The basic auth username\r\n        // password: The basic auth password\r\n        // isAsync: If set to false, the request are done sync. Default is true.\r\n        // IsCors: set this to false to disable CORS\r\n        // +++\r\n        base.config = function (config) {\r\n            base.oConfig = merge(base.oConfig, config);\r\n        }\r\n\r\n        // +++\r\n        // indicates if a endpoint is configured\r\n        // +++\r\n        base.isEndpoint = function () {\r\n            return (base.oConfig.endpoint !== null);\r\n        }\r\n\r\n        // +++\r\n        // To merge x object together\r\n        // +++\r\n        function merge() {\r\n            var obj = {},\r\n                i = 0,\r\n                il = arguments.length,\r\n                key;\r\n            for (; i < il; i++) {\r\n                for (key in arguments[i]) {\r\n                    if (arguments[i].hasOwnProperty(key)) {\r\n                        obj[key] = arguments[i][key];\r\n                    }\r\n                }\r\n            }\r\n            return obj;\r\n        }\r\n\r\n        if (typeof res === 'undefined') {\r\n            return (base);\r\n        }\r\n        else {\r\n            return (new oData(res, base.oConfig));\r\n        }\r\n    }\r\n\r\n\r\n    function oData(res, config) {\r\n        var base = this;\r\n\r\n        // --------------------+++ VARIABLES +++---------------------------\r\n\r\n        //base internal variables\r\n        var resource = null; \t\t\t\t\t// the main resource string\r\n        var resourceList = []; \t\t    \t\t// an array list of all resource used\r\n        var routeList = []; \t\t\t\t\t// an array list of all routes used\r\n        var isEndpoint = true;\t\t    \t\t// true if an endpoint is configured\r\n        var currentPromise = null;\t    \t\t// if promise (Q.js) is used, we hold it here\r\n        var overideLoading = null;      \t\t// if set, this resource call don't use the global loading function\r\n        var isXDomainRequest = false;   \t\t// this is set to true in IE 9 and IE 8 to support CORS operations. No basic auth support :(\r\n        var beforeRoutingFunc = function () { };\t// A function which is called before routing.\r\n        var internalParam = {}; \t\t\t\t// like base.param this object holds all parameter for a route but with the leading : for easier using in regexes\r\n        var opertionMapping = {\r\n            '==': 'eq',\r\n            '===': 'eq',\r\n            '!=': 'ne',\r\n            '!==': 'ne',\r\n            '>': 'gt',\r\n            '>=': 'ge',\r\n            '<': 'lt',\r\n            '<=': 'le',\r\n            '&&': 'and',\r\n            '||': 'or',\r\n            '!': 'not',\r\n            //'+': 'add',\r\n            //'-': 'sub',\r\n            '*': 'mul',\r\n            //'.': '/',\r\n            '%': 'mod'\r\n        };\r\n\r\n\r\n        //base external variables\r\n        base.data = [];\t\t\t\t\t//holds the data after an callback\r\n        base.inlinecount = null; \t\t//if inlinecount is set, here the counting is gold\r\n        base.param = {};\t\t\t\t//this object holds all parameter for a route\r\n        base.oConfig = config;\t\t\t//the internal config, passed over from the o function\r\n        base.raw = null;                //holds the data after an callback (raw data, containing also metadata)\r\n\r\n\r\n        // ---------------------+++ PUBLICS +++----------------------------\r\n\r\n        // +++\r\n        // route is a little extra function to enable rest-like routing on the client side\r\n        // +++\r\n        base.routes = base.route = function (routes, callback) {\r\n\r\n            //if not a array, make it one\r\n            if (!isArray(routes)) {\r\n                routes = [routes];\r\n            }\r\n\r\n            // check support\r\n            if (typeof window === 'undefined') {\r\n                throwEx('Routes are only supported in a browser env.');\r\n            }\r\n\r\n            var prevHash = window.location.hash;\r\n\r\n            //literate over every rout and add a interval to check if the route is triggered\r\n            for (var i = 0; i < routes.length; i++) {\r\n                if (typeof callback !== 'undefined') {\r\n\r\n                    //Push the routes in the routeList\r\n                    //TODO: Is there any way to use the build an on hash update function?! Onhaschange can't be bound multiple times. Also a problem: if the hash is called a second time the route is not triggered\r\n                    routeList.push({\r\n                        name: routes[i],\r\n                        route: buildRouteRegex(routes[i]),\r\n                        callback: callback,\r\n                        param: {},\r\n                        interval: setInterval(function () {\r\n                            if (window.location.hash != prevHash) {\r\n                                prevHash = window.location.hash;\r\n                                checkRoute(window.location.hash);\r\n                            }\r\n                        }, 100)\r\n                    });\r\n                }\r\n                else {\r\n                    throwEx('Routes without a callback are not supported. Please define a function like .route(\"YourRoute\", function() { }).');\r\n                }\r\n            }\r\n\r\n            //trigger on init if the hash is the same like current\r\n            base.triggerRoute(window.location.hash);\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // get called beforerounting\r\n        // +++\r\n        base.beforeRouting = function (beforeFunc) {\r\n            beforeRoutingFunc = beforeFunc;\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // indicates if a endpoint is configured\r\n        // +++\r\n        base.isEndpoint = function () {\r\n            return (isEndpoint);\r\n        }\r\n\r\n        // +++\r\n        // triggers a route\r\n        // +++\r\n        base.triggerRoute = function (hash) {\r\n            checkRoute(hash);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the object with the given id\r\n        // +++\r\n        base.find = function (getId) {\r\n            resource.path[resource.path.length - 1].get = getId;\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the top x objects\r\n        // +++\r\n        base.top = base.take = function (takeAmount) {\r\n            if (!isQueryThrowEx(['$top'])) {\r\n                addQuery('$top', takeAmount, takeAmount);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the x objects skipped by the property value\r\n        // +++\r\n        base.skip = function (skipAmount) {\r\n            if (!isQueryThrowEx('$skip')) {\r\n                addQuery('$skip', skipAmount, skipAmount);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the first object which is found\r\n        // +++\r\n        base.first = function () {\r\n            if (!isQueryThrowEx(['$top', '$first'])) {\r\n                addQuery('$top', 1, null, '$first');\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // add a filter\r\n        // +++\r\n        base.filter = base.where = function (filterStr) {\r\n            var filterVal = checkEmpty(jsToOdata(filterStr));\r\n            if (isQuery('$filter')) {\r\n                appendQuery('$filter', filterVal, filterVal);\r\n            }\r\n            else {\r\n                addQuery('$filter', filterVal, filterVal);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Applies a any filter\r\n        // +++\r\n        base.any = function (res, filter) {\r\n            var filterVal = res + '/any(x:x/' + jsToOdata(checkEmpty(filter)) + ')'\r\n            if (isQuery('$filter')) {\r\n                appendQuery('$filter', filterVal, filterVal);\r\n            }\r\n            else {\r\n                addQuery('$filter', filterVal, filterVal);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // orders the result asc\r\n        // +++\r\n        base.orderBy = function (orderStr, direction) {\r\n            if (typeof direction === 'undefined') {\r\n                direction = 'asc';\r\n            }\r\n            if (!isQueryThrowEx('$orderby')) {\r\n                addQuery('$orderby', checkEmpty(orderStr) + ' ' + direction);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // orders the result desc\r\n        // +++\r\n        base.orderByDesc = function (orderStr) {\r\n            return base.orderBy(orderStr, 'desc');\r\n        }\r\n\r\n        // +++\r\n        // enables select\r\n        // +++\r\n        base.select = function (selectStr) {\r\n            addQuery('$select', checkEmpty(selectStr));\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the counted data-sets\r\n        // +++\r\n        base.count = function () {\r\n            if (base.oConfig.version >= 4) {\r\n                resource.path.push({ resource: '$count', get: null });\r\n            }\r\n            else {\r\n                removeQuery('$format');\r\n                addQuery('$count', 'count');\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a inline count\r\n        // +++\r\n        base.inlineCount = function (countOption) {\r\n            if (base.oConfig.version >= 4) {\r\n                countOption = countOption || 'true';\r\n                if (!isQueryThrowEx('$count')) {\r\n                    addQuery('$count', countOption);\r\n                }\r\n            }\r\n            else {\r\n                countOption = countOption || 'allpages';\r\n                if (!isQueryThrowEx('$inlinecount')) {\r\n                    addQuery('$inlinecount', countOption);\r\n                }\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a second resource to the request list to batch it\r\n        // +++\r\n        base.batch = function (res) {\r\n            //add a new resource\r\n            addNewResource(res);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the top x objects\r\n        // +++\r\n        base.expand = function (expandStr) {\r\n            expandResource(expandStr);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // set to false to disabel loading, set two functions to overide loading\r\n        // +++\r\n        base.loading = function (func1, func2) {\r\n            func2 = func2 || func1;\r\n            if (!func1)\r\n                overideLoading = [function () { }, function () { }];\r\n            else {\r\n                overideLoading = [func1, func2];\r\n            }\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // appends a navigation property to an existing resource\r\n        // +++\r\n        base.ref = base.link = function (navPath, id) {\r\n            removeQuery('$format');\r\n            if (resource == null || resource.get) {\r\n                throwEx('You need to define a resource with the find() method to append an navigation property');\r\n            }\r\n            if (base.oConfig.version < 4) {\r\n                resource.method = 'POST';\r\n                resource.path.push('$link');\r\n                resource.path.push({ resource: navPath, get: null });\r\n            }\r\n            else {\r\n                resource.method = 'POST';\r\n                resource.path.push({ resource: navPath, get: null });\r\n                resource.path.push({ resource: '$ref', get: null });\r\n            }\r\n            var newResource = parseUri(navPath);\r\n            newResource.path[newResource.path.length - 1].get = id;\r\n            var baseRes = buildQuery(newResource);\r\n            resource.data = { '@odata.id': baseRes.substring(0, baseRes.length - 1) };\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // deletes a referenced entity relation\r\n        // +++\r\n        base.removeRef = base.deleteRef = function (navPath, id) {\r\n            removeQuery('$format');\r\n            if (resource == null || resource.get) {\r\n                throwEx('You need to define a resource with the find() method to append an navigation property');\r\n            }\r\n            if (base.oConfig.version < 4) {\r\n                resource.method = 'POST';\r\n                resource.path.push('$link');\r\n                resource.path.push({ resource: navPath, get: null });\r\n            }\r\n            else {\r\n                resource.method = 'POST';\r\n                resource.path.push({ resource: navPath, get: null });\r\n                resource.path.push({ resource: '$ref', get: null });\r\n            }\r\n            if (id) {\r\n                var newResource = parseUri(navPath);\r\n                newResource.path[newResource.path.length - 1].get = id;\r\n                var baseRes = buildQuery(newResource);\r\n                addQuery('$id', baseRes.substring(0, baseRes.length - 1));\r\n            }\r\n            //set the method\r\n            resource.method = 'DELETE';\r\n\r\n            return (base);\r\n        }\r\n\r\n\r\n        // +++\r\n        // This function actually queries the oData service with a GET request\r\n        // +++\r\n        base.get = function (callback, errorCallback) {\r\n            // init the q -> if node require a node promise -> if ES6, try ES6 promise\r\n            var promise = initPromise();\r\n            if (promise && typeof callback === 'undefined')\r\n                currentPromise = promise.defer();\r\n\r\n            //start the request\r\n            startRequest(callback, errorCallback, false);\r\n            if (promise && typeof callback === 'undefined')\r\n                return (currentPromise.promise);\r\n            else\r\n                return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a dataset to the current selected resource\r\n        // if o(\"Product/ProductGroup\").post(...) will post a dataset to the Product resource\r\n        // +++\r\n        base.save = function (callback, errorCallback) {\r\n            //if base.data is set and the user saves, we copying this resource as a Patch\r\n            //this allows a fast edit mode after a get request\r\n            if (resource.method === 'GET' && resource.data !== null) {\r\n                var newResource = deepCopy(resource);\r\n                //set the method and data\r\n                newResource.method = 'PATCH';\r\n                newResource.data = resource.data;\r\n                addNewResource(newResource);\r\n            }\r\n\r\n            var promise = initPromise();\r\n\r\n            //start the request with promise\r\n            if (promise && typeof callback === 'undefined') {\r\n                currentPromise = promise.defer();\r\n                startRequest(callback, errorCallback, true);\r\n                return (currentPromise.promise);\r\n            }\r\n            //start the request without promise\r\n            else {\r\n                startRequest(callback, errorCallback, true);\r\n                return (base);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // adds a dataset to the current selected resource\r\n        // o(\"Product/ProductGroup\").post(...) will post a dataset to the Product resource\r\n        // alternative you can define a new resource by using .post({data},'OtherResource');\r\n        // +++\r\n        base.post = function (data, res) {\r\n            //test: remove the $format attribute\r\n            removeQuery('$format');\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            //if (!resource.path[0] || !resource.path[0].get)\r\n            //    throwEx('Bulk inserts are not supported. You need to query a unique resource with find() to post it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'POST';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a update with the given Data to the current dataset with PATCH.\r\n        // +++\r\n        base.patch = function (data, res) {\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk updates are not supported. You need to query a unique resource with find() to patch/put it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'PATCH';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a update with the given Data to the current dataset with PUT.\r\n        // +++\r\n        base.put = function (data, res) {\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk updates are not supported. You need to query a unique resource with find() to patch/put it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'PUT';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a delete with the given Data to the current dataset\r\n        // +++\r\n        base.remove = base['delete'] = function (res) {\r\n\r\n            //add the resource\r\n            if (res)\r\n                addNewResource(res);\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk deletes are not supported. You need to query a unique resource with find() to delete it.');\r\n\r\n            //set the method\r\n            resource.method = 'DELETE';\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Returns the current query\r\n        // +++\r\n        base.query = function (overrideRes) {\r\n            return (buildQuery(overrideRes));\r\n        }\r\n\r\n        // +++\r\n        // search for the degined columns\r\n        // +++\r\n        base.search = function (searchColumns, searchWord, searchFunc, isSupported) {\r\n\r\n            var searchStr = buildSearchFilter(searchColumns, searchWord, searchFunc);\r\n\r\n            if (base.oConfig.version == 4 && isSupported) {\r\n                if (!isQueryThrowEx('$search')) {\r\n                    addQuery('$search', searchStr, searchStr);\r\n                }\r\n            }\r\n            else {\r\n                if (!isQueryThrowEx('$filter')) {\r\n                    addQuery('$filter', searchStr, searchStr, '$search');\r\n                }\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Adds a filter to exclude data from a existing data-result\r\n        // +++\r\n        base.filterByList = base.exclude = function (column, data) {\r\n            if (!isQueryThrowEx('$filter')) {\r\n                var filterStr = buildFilterByData(column, data, opertionMapping['!='], opertionMapping['&&']);\r\n                addQuery('$filter', checkEmpty(filterStr), filterStr);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Adds a filter to include data from a existing data-result\r\n        // +++\r\n        base.include = function (column, data) {\r\n            if (!isQueryThrowEx('$filter')) {\r\n                var filterStr = buildFilterByData(column, data, opertionMapping['=='], opertionMapping['||']);\r\n                addQuery('$filter', checkEmpty(filterStr), filterStr);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Set this value to add a progress handler to the current resource\r\n        // +++\r\n        base.progress = function (progressFunc) {\r\n            if (resource != null) {\r\n                resource.progress = progressFunc;\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // ---------------------+++ INTERNALS +++----------------------------\r\n\r\n        // +++\r\n        // initialize a promise callback\r\n        // +++\r\n        function initPromise() {\r\n            if (typeof Q !== 'undefined') {\r\n                var p = Q;\r\n                return (p);\r\n            }\r\n            else if (typeof window === 'undefined') {\r\n                var p = __webpack_require__(500);\r\n                return (p);\r\n            }\r\n            else {\r\n                return (null);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // builds a filter by a given data object to include or exclude values on a query\r\n        // +++\r\n        function buildFilterByData(column, filterList, operation, combine) {\r\n            if (isArray(filterList)) {\r\n                var filterStr = \"\", arr = [];\r\n                for (i = 0; i < filterList.length; ++i) {\r\n                    arr[i] = '(' + column + ' ' + operation + ' ' + filterList[i][column] + ')';\r\n                }\r\n                filterStr = arr.join(' ' + combine + ' ');\r\n                return (filterStr);\r\n            }\r\n            return (\"\");\r\n        }\r\n\r\n        // +++\r\n        // builds a search filter\r\n        // ++++\r\n        function buildSearchFilter(searchColumns, searchWord, searchFunc) {\r\n            searchFunc = searchFunc || (base.oConfig.version == 4 ? 'contains' : 'substringof');\r\n            var searchWordSplit = searchWord.split(' ');\r\n            var isNotExactSearch = (searchFunc === 'contains' || searchFunc === 'substringof');\r\n\r\n            var columnArr = [];\r\n            for (var i = 0; i < searchColumns.length; i++) {\r\n                var wordArr = [];\r\n                if (isNotExactSearch) {\r\n                    for (var m = 0; m < searchWordSplit.length; m++) {\r\n                        if (base.oConfig.version == 4) {\r\n                            wordArr.push(searchFunc + '(' + searchColumns[i] + ',\\'' + searchWordSplit[m] + '\\')');\r\n                        }\r\n                        else {\r\n                            wordArr.push(searchFunc + '(\\'' + searchWordSplit[m] + '\\',' + searchColumns[i] + ')');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    wordArr.push(searchColumns[i] + ' ' + searchFunc + ' \\'' + searchWord + '\\'');\r\n                }\r\n                columnArr.push('(' + wordArr.join(' and ') + ')');\r\n            }\r\n            return (columnArr.join('or'));\r\n        }\r\n\r\n        // +++\r\n        // builds the URI for this query\r\n        // +++\r\n        function buildQuery(overrideRes) {\r\n            var res = overrideRes || resource;\r\n\r\n            //check if there is a resource defined\r\n            if (!res || res.path.length === 0)\r\n                throwEx('No resource defined. Define a resource first with o(\"YourResourcePath\").');\r\n\r\n            //get the full query\r\n            var queryStr = '';\r\n\r\n            //add the configured endpoint\r\n            if (isEndpoint) {\r\n                queryStr = base.oConfig.endpoint + (endsWith(base.oConfig.endpoint, '/') ? '' : '/');\r\n            }\r\n\r\n            //combine the uri\r\n            for (var i = 0; i < res.path.length; i++) {\r\n                queryStr += res.path[i].resource;\r\n\r\n                if (res.path[i].get) {\r\n                    queryStr += '(' + (internalParam[res.path[i].get] || res.path[i].get) + ')';\r\n                }\r\n\r\n                queryStr += '/';\r\n            }\r\n\r\n            if (!res.appending) {\r\n                queryStr = queryStr.slice(0, -1);\r\n            }\r\n\r\n            return (queryStr + res.appending + getQuery());\r\n        }\r\n\r\n        // +++\r\n        // internal function which builds the url get parameter\r\n        // +++\r\n        function getQuery() {\r\n            var tempStr = '';\r\n\r\n            for (queryName in resource.query) {\r\n                if (resource.query.hasOwnProperty(queryName) && resource.query[queryName] != null) {\r\n                    tempStr += '&' + resource.queryList[resource.query[queryName]].name + '=' + strFormat(resource.queryList[resource.query[queryName]].value, internalParam);\r\n                }\r\n            }\r\n            if (tempStr.length > 0)\r\n                return ('?' + tempStr.substring(1));\r\n            return (\"\");\r\n        }\r\n\r\n        // +++\r\n        // checks if a route exist and starts the request and adds the parameters\r\n        // +++\r\n        function checkRoute(hash) {\r\n            //literate over the complete routeList\r\n            for (var r = 0; r < routeList.length; r++) {\r\n                //check regex with hash\r\n                if (routeList[r].route.regex.test(hash)) {\r\n\r\n                    //reset the param\r\n                    internalParam = {};\r\n                    var param = {};\r\n\r\n                    //get the matching data\r\n                    var matches = routeList[r].route.regex.exec(hash);\r\n\r\n                    //combine the propArr with the matches\r\n                    if (typeof routeList[r].route.param !== 'undefined') {\r\n                        var i = 1;\r\n                        for (prop in routeList[r].route.param) {\r\n                            internalParam[prop] = matches[i];\r\n                            param[prop.substring(1)] = matches[i];\r\n                            i++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i = 1; i < matches.length; i++) {\r\n                            internalParam[':' + (i - 1)] = matches[i];\r\n                            param[(i - 1)] = matches[i];\r\n\r\n                        }\r\n                    }\r\n\r\n                    //trigger the before routing func1\r\n                    if (!beforeRoutingFunc(param)) {\r\n                        //start the request if there is a resource defined\r\n                        startRouteRequest(routeList[r].callback, param);\r\n                    }\r\n\r\n                    base.param = param;\r\n                }\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // builds a route regex function based on a given string\r\n        // +++\r\n        function buildRouteRegex(routeStr) {\r\n            //build regex TODO: Can be done before and not on every iteration\r\n            var routeRegex = routeStr;\r\n            if (!(routeStr instanceof RegExp)) {\r\n                //set the hash if needed\r\n                if (base.oConfig.isHashRoute && !startsWith(routeStr, '#')) {\r\n                    routeStr = '#' + routeStr;\r\n                }\r\n                //build up a regex\r\n                var routeArr = routeStr.split('/');\r\n                var param = {};\r\n                for (var i = 0; i < routeArr.length; i++) {\r\n                    if (startsWith(routeArr[i], ':')) {\r\n                        param[routeArr[i]] = true;\r\n                        routeArr[i] = '([\\\\w| |-]+|\\\\[\\W| |-]+)';\r\n                    }\r\n                }\r\n                routeRegex = new RegExp('^' + routeArr.join('/') + '$');\r\n            }\r\n            return ({ regex: routeRegex, param: param });\r\n        }\r\n\r\n        // +++\r\n        // performs a deep copy on an object with JSON\r\n        // +++\r\n        function deepCopy(obj) {\r\n            if (JSON) {\r\n                return (JSON.parse(JSON.stringify(obj)));\r\n            }\r\n            else {\r\n                throwEx('No JSON Support.');\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // takes a script with javascript operations and translates it to odata\r\n        // +++\r\n        function jsToOdata(str) {\r\n            //stripe out the vars\r\n            var regexp = new RegExp(\"'.*?'\", '');\r\n\r\n            var matches = regexp.exec(str);\r\n            str = str.replace(regexp, '{0}');\r\n\r\n            for (key in opertionMapping) {\r\n                str = str.split(key).join(' ' + opertionMapping[key] + ' ');\r\n            }\r\n\r\n            if (matches != null) {\r\n                for (var i = 0; i < matches.length; i++) {\r\n                    str = str.replace('{0}', matches[i])\r\n                }\r\n            }\r\n\r\n            return (str);\r\n        }\r\n\r\n\r\n        // +++\r\n        // adds an new resource to the resouce list\r\n        // +++\r\n        function addNewResource(res) {\r\n            //add the predefined resource to the history resource list\r\n            if (resource)\r\n                resourceList.push(resource);\r\n\r\n            //build the resource array\r\n            if (typeof res === 'string')\r\n                resource = parseUri(res);\r\n            else\r\n                resource = res;\r\n\r\n            //add the default format\r\n            if (!isQuery('$format') && base.oConfig.autoFormat) {\r\n                addQuery('$format', base.oConfig.format);\r\n            }\r\n\r\n            //appendings\r\n            for (var i = 0; i < base.oConfig.appending.length; i++) {\r\n                addQuery(base.oConfig.appending[i].name, base.oConfig.appending[i].value);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // starts a request to the service\r\n        // +++\r\n        function startRequest(callback, errorCallback, isSave, param) {\r\n\r\n            //check if resource is defined\r\n            if (resource === null) {\r\n                throwEx('You must define a resource to perform a get(), post(), put() or delete() function. Define a resource with o(\"YourODataResource\").');\r\n            }\r\n\r\n            //create a CORS ajax Request\r\n            if (resourceList.length === 0 && !isSave) {\r\n                startAjaxReq(createCORSRequest('GET', buildQuery()), null, callback, errorCallback, false,\r\n                    [\r\n                        { name: 'Accept', value: 'application/json,text/plain' },\r\n                        { name: 'Content-Type', value: 'application/json' }\r\n                    ],\r\n                    param, resource.progress);\r\n            }\r\n            //else check if we need to make a $batch request\r\n            else {\r\n                //add the last resource to the history\r\n                resourceList.push(resource);\r\n\r\n                //build a ajax request\r\n                var ajaxReq = createCORSRequest(resource.method, buildQuery());\r\n                //check if we only have one request or we need to force batch because of isXDomainRequest\r\n                if ((countMethod(['POST', 'PATCH', 'DELETE', 'PUT']) <= 1 && isSave) && !isXDomainRequest) {\r\n                    startAjaxReq(ajaxReq, stringify(resource.data), callback, errorCallback, false,\r\n                        [\r\n                            { name: 'Accept', value: 'application/json' },\r\n                            { name: 'Content-Type', value: 'application/json' }\r\n                        ],\r\n                        param, resourceList[resourceList.length - 1].progress);\r\n                    // because the post/put/delete is done, we remove the resource to assume that it will not be posted again\r\n                    removeResource(['POST', 'PATCH', 'DELETE', 'PUT']);\r\n                }\r\n                // do a $batch request\r\n                else {\r\n                    // generate a uui for this batch\r\n                    var guid = generateUUID();\r\n\r\n                    // build the endpoint\r\n                    var endpoint = base.oConfig.endpoint + (endsWith(base.oConfig.endpoint, '/') ? '' : '/') + '$batch';\r\n\r\n                    // appendings\r\n                    for (var i = 0; i < base.oConfig.appending.length; i++) {\r\n                        endpoint += (i === 0 ? '?' : '&') + base.oConfig.appending[i].name + '=' + base.oConfig.appending[i].value;\r\n                    }\r\n\r\n                    // start the request\r\n                    startAjaxReq(createCORSRequest('POST', endpoint), buildBatchBody(guid, isSave), callback, errorCallback, true,\r\n                        // add the necessary headers\r\n                        [{ name: 'Content-Type', value: 'multipart/mixed; boundary=batch_' + guid }],\r\n                        param, resourceList[resourceList.length - 1].progress);\r\n                    if (isSave) {\r\n                        // because the post/put/delete is done, we remove the resource to assume that it will not be posted again\r\n                        removeResource(['POST', 'PUT', 'DELETE']);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // starts a request triggered by a route\r\n        // +++\r\n        function startRouteRequest(callback, param) {\r\n            if (resource.path[0].resource !== \"\")\r\n                startRequest(callback, null, false, param);\r\n            else {\r\n                callback.call(base, param);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // This functions interprets the given resource and returns the base object. It is called by the o-return.\r\n        // +++\r\n        function init(res) {\r\n            //if no resource defined, just return the base object\r\n            if (typeof res === 'undefined')\r\n                return (base);\r\n\r\n            //Check if we have a endpoint and save it to the var\r\n            if ((res.toUpperCase().indexOf('HTTP://') > -1 || res.toUpperCase().indexOf('HTTPS://') > -1)) {\r\n                isEndpoint = false;\r\n            }\r\n            else {\r\n                //check if endpoint is defined\r\n                if (!base.oConfig.endpoint) {\r\n                    throwEx('You can not use resource query without defining your oData endpoint. Use o().config({endpoint:yourEndpoint}) to define your oData endpoint.');\r\n                }\r\n            }\r\n\r\n            //set the route name\r\n            routeName = res;\r\n\r\n            //add the basic resource\r\n            addNewResource(res);\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // expands a resource by the given resource string (separated by ,)\r\n        // +++\r\n        function expandResource(expandStr) {\r\n            if (isQuery('$expand')) {\r\n                resource.queryList[resource.query.$expand].value += ',' + expandStr;\r\n                resource.queryList[resource.query.$expand].original = resource.queryList[resource.query.$expand].value;\r\n            }\r\n            else {\r\n                addQuery('$expand', expandStr, expandStr);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // internal function to parse the Uri and extrude the resource\r\n        // +++\r\n        function parseUri(resource) {\r\n            var resSplit = resource.split('?');\r\n            var uri = resource;\r\n            var query = '';\r\n            var reqObj = {\r\n                path: [], //array of all without the base\r\n                appending: '', // e.g. $count or $batch\r\n                query: {}, //the query Array --> use base.queryArray\r\n                queryList: [],\r\n                method: 'GET',\r\n                data: null,\r\n                progress: null,\r\n            };\r\n\r\n            //query\r\n            if (resSplit.length === 2) {\r\n                uri = resSplit[0];\r\n                query = resSplit[1];\r\n                var querySplit = query.split('&');\r\n                for (var i = 0; i < querySplit.length; i++) {\r\n                    var pair = querySplit[i].split('=');\r\n                    reqObj.queryList.push({ name: pair[0], value: pair[1] });\r\n                    reqObj.query[pair[0]] = reqObj.queryList.length - 1;\r\n                }\r\n            }\r\n\r\n            //uri\r\n            var uriSplit = uri.split('/');\r\n            for (var i = 0; i < uriSplit.length; i++) {\r\n                if (startsWith(uriSplit[i], '$') && uriSplit[i] !== '$link') {\r\n                    reqObj.appending = uriSplit[i];\r\n                }\r\n                else {\r\n                    var index = uriSplit[i].split('(');\r\n                    if (index.length === 1 || startsWith(uriSplit[i], '(')) {\r\n                        reqObj.path.push({ 'resource': uriSplit[i], 'get': null });\r\n                    }\r\n                    else {\r\n                        reqObj.path.push({ 'resource': index[0], 'get': index[1].substring(0, index[1].length - 1) });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return (reqObj);\r\n        }\r\n\r\n        // +++\r\n        // internal function to add a query parameter\r\n        // +++\r\n        function addQuery(queryName, queryValue, queryOriginal, queryPseudonym) {\r\n            queryOriginal = queryOriginal || null;\r\n            resource.queryList.push({ name: queryName, value: queryValue, original: queryOriginal });\r\n            resource.query[queryPseudonym || queryName] = resource.queryList.length - 1;\r\n        }\r\n\r\n        // +++\r\n        // internal function to append a query parameter\r\n        // +++\r\n        function appendQuery(queryName, queryValue, queryOriginal, appendType, queryPseudonym) {\r\n            queryOriginal = queryOriginal || null;\r\n            appendType = appendType || ' or ';\r\n            queryName = queryPseudonym || queryName;\r\n            resource.queryList[resource.query[queryName]].value = '(' + resource.queryList[resource.query[queryName]].value + ')' + appendType + '(' + queryValue + ')';\r\n            if (queryOriginal)\r\n                resource.queryList[resource.query[queryName]].original = resource.queryList[resource.query[queryName]].value;\r\n        }\r\n\r\n        // +++\r\n        // internal function to remove a query parameter\r\n        // +++\r\n        function removeQuery(queryName) {\r\n            resource.query[queryName] = null;\r\n        }\r\n\r\n        // +++\r\n        // internal function to check if a query exist. Otherwith throwEx a exception\r\n        // queries: Could be an array or an string\r\n        // returns true if\r\n        // +++\r\n        function isQueryThrowEx(queries) {\r\n            if (isQuery(queries)) {\r\n                var queryName = queries;\r\n                if (isArray(queryName)) {\r\n                    queryName = queryName.join(\",\");\r\n                }\r\n                throwEx('There is already a depending query. You can not use them together/twice: ' + queryName)\r\n                return (true);\r\n            }\r\n            return (false);\r\n        }\r\n\r\n        // +++\r\n        // internal function to check if a query exist\r\n        // queries:  Could be an array or an string\r\n        // returns true if the query is already in the query array\r\n        // +++\r\n        function isQuery(queries) {\r\n            var queryNames = (isArray(queries) ? queries : [queries]);\r\n            var isIn = false;\r\n            for (var i = 0; i < queryNames.length; i++) {\r\n                if (resource.query.hasOwnProperty(queryNames[i])) {\r\n                    isIn = true;\r\n                }\r\n            }\r\n            return (isIn);\r\n        }\r\n\r\n        // +++\r\n        // returns a  RFC4122 version 4 compliant  UUID\r\n        // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\r\n        // +++\r\n        function generateUUID() {\r\n            var d = new Date().getTime();\r\n            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n                var r = (d + Math.random() * 16) % 16 | 0;\r\n                d = Math.floor(d / 16);\r\n                return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);\r\n            });\r\n            return uuid;\r\n        }\r\n\r\n        // +++\r\n        // Checks if a value is positiv and a integer\r\n        // +++\r\n        function checkEmpty(str, throwName) {\r\n            if (typeof str !== 'undefined' && str !== null && str.length > 0)\r\n                return (str);\r\n            else\r\n                throwEx(throwName + ': Parameter must be set.');\r\n        }\r\n\r\n        // +++\r\n        // Helper function for trying to parse from this page: http://pietschsoft.com/post/2008/01/14/JavaScript-intTryParse-Equivalent\r\n        // +++\r\n        function tryParseInt(str, defaultValue) {\r\n            if (typeof str === 'number')\r\n                return (str);\r\n            var retValue = defaultValue;\r\n            if (str) {\r\n                if (str.length > 0) {\r\n                    if (!isNaN(str)) {\r\n                        retValue = parseInt(str);\r\n                    }\r\n                }\r\n            }\r\n            return (retValue);\r\n        }\r\n\r\n        // +++\r\n        // helper to count the current length of all methods in the resourceList\r\n        // +++\r\n        function countMethod(methodNames) {\r\n            var count = 0;\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                if (methodNames.indexOf(resourceList[i].method) > -1)\r\n                    count++;\r\n            }\r\n            return (count);\r\n        }\r\n\r\n        // +++\r\n        // removes resources out of the resourceList by it's method name\r\n        // +++\r\n        function removeResource(methodNames) {\r\n            //TODO:  Add a future detection here for .filter() can help to increase performance. This is a overall function to work in all common browsers. A better way is to use .filter(), but it is not supported by all browsers.\r\n            var spliceArr = [];\r\n            //search for them\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                if (methodNames.indexOf(resourceList[i].method) > -1)\r\n                    spliceArr.push(i);\r\n            }\r\n            //and after that, remove them by reverse looping\r\n            for (var i = spliceArr.length - 1; i >= 0; i--) {\r\n                resourceList.splice(spliceArr[i], 1);\r\n            }\r\n            //pack the last resource in the current resource\r\n            if (resourceList[0])\r\n                resource = resourceList[0];\r\n        }\r\n\r\n\r\n        // +++\r\n        // helper that stringify data. Checks for JSON support\r\n        // +++\r\n        function stringify(data) {\r\n            if (JSON)\r\n                return (JSON.stringify(data));\r\n            else {\r\n                //Throw exception\r\n                throwEx('No JSON support.');\r\n                return (data);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // Helper function to check if a given object is an array\r\n        // +++\r\n        function isArray(obj) {\r\n            //fall back for older browsers\r\n            if (typeof Array.isArray === 'undefined') {\r\n                return (obj.toString() === '[object Array]');\r\n            }\r\n            //the checking\r\n            return (Array.isArray(obj));\r\n        }\r\n\r\n        // +++\r\n        // helper function to check if a string ends with something\r\n        // +++\r\n        function endsWith(str, suffix) {\r\n            return (str ? str.indexOf(suffix, str.length - suffix.length) !== -1 : false);\r\n        }\r\n\r\n        // +++\r\n        // helper function to check if a string starts with something\r\n        // +++\r\n        function startsWith(s, str) {\r\n            return (s.indexOf(str) === 0);\r\n        }\r\n\r\n        // +++\r\n        // Throws an exception\r\n        // +++\r\n        function throwEx(msg) {\r\n            function oException(msg) {\r\n                this.message = msg;\r\n                this.name = 'o.js exception';\r\n            }\r\n            oException.prototype = new Error();\r\n            if (base.oConfig.strictMode === true)\r\n                throw new oException(msg);\r\n            else\r\n                console.log('o.js exception: ' + msg);\r\n        }\r\n\r\n        // +++\r\n        // builds a oData $batch http body\r\n        // +++\r\n        function buildBatchBody(batchGuid, isSave) {\r\n            var body = '';\r\n            var changsetGuid = generateUUID();\r\n            var isChangeset = false;\r\n            if (isSave) {\r\n                body += '--batch_' + batchGuid + '\\n';\r\n                body += 'Content-Type: multipart/mixed; boundary=changeset_' + changsetGuid + '\\n\\n';\r\n            }\r\n\r\n            var hostname = null;\r\n            if (base.oConfig.endpoint !== null) {\r\n                //find & remove protocol (http, https etc.) and get hostname\r\n                if (base.oConfig.endpoint.indexOf(\"://\") > -1) {\r\n                    hostname = base.oConfig.endpoint.split('/')[2];\r\n                } else {\r\n                    hostname = base.oConfig.endpoint.split('/')[0];\r\n                }\r\n                //find & remove port number\r\n                hostname = hostname.split(':')[0];\r\n            }\r\n\r\n            //loop over the resourceList\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                var res = resourceList[i];\r\n                //set the current resource to the resouceList-Element resource to enable addQuery and expand functions\r\n                resource = res;\r\n                //only do get if not saving is choosen\r\n                if (res.method === 'GET' && !isSave) {\r\n                    body += '--batch_' + batchGuid + '\\n';\r\n                    body += 'Content-Type: application/http\\n';\r\n                    body += 'Content-Transfer-Encoding: binary\\n\\n';\r\n                    body += res.method + ' ' + buildQuery(res) + ' HTTP/1.1\\n';\r\n                    body += 'Host: ' + hostname + '\\n';\r\n\r\n                    for (var k = 0; k < base.oConfig.headers.length; k++) {\r\n                        var header = base.oConfig.headers[k];\r\n                        body += header.name + ': ' + header.value + '\\n';\r\n                    }\r\n\r\n                    body += '\\n';\r\n                }\r\n                //do POST if the base.save() function was called\r\n                //TODO:  || res.method==='PUT' || res.method==='DELETE'\r\n                else if ((res.method === 'POST' || res.method === 'PUT' || res.method === 'PATCH' || res.method === 'DELETE') && isSave) {\r\n                    //var stringData = stringify(res.data);\r\n                    body += '--changeset_' + changsetGuid + '\\n';\r\n                    body += 'Content-Type: application/http\\n';\r\n                    body += 'Content-Transfer-Encoding: binary\\n';\r\n                    body += 'Content-ID:' + i + 1 + '\\n\\n'; //This ID can be referenced $1/Customer\r\n                    body += res.method + ' ' + buildQuery(res) + ' HTTP/1.1\\n';\r\n                    body += 'Host: ' + hostname + '\\n';\r\n\r\n                    for (var k = 0; k < base.oConfig.headers.length; k++) {\r\n                        var header = base.oConfig.headers[k];\r\n                        body += header.name + ': ' + header.value + '\\n';\r\n                    }\r\n\r\n                    body += 'Content-Type: application/json\\n';\r\n                    //body += 'Content-Length:' + stringData.length + '\\n';\r\n                    body += '\\n' + stringify(resource.data) + '\\n\\n\\n';\r\n                    isChangeset = true;\r\n                }\r\n            }\r\n            if (isChangeset)\r\n                body += '--changeset_' + changsetGuid + '--\\n\\n';\r\n            body += '--batch_' + batchGuid + '--';\r\n\r\n            return (body);\r\n        }\r\n\r\n        // +++\r\n        // start a ajax request. data should be null if nothing to send\r\n        // +++\r\n        function startAjaxReq(ajaxRequest, data, callback, errorCallback, isBatch, headers, param, progress) {\r\n\r\n            //if start loading function is set call it\r\n            if (base.oConfig.start && overideLoading == null) {\r\n                base.oConfig.openAjaxRequests++;\r\n                base.oConfig.start();\r\n            }\r\n            if (overideLoading && overideLoading[0]) {\r\n                overideLoading[0](true);\r\n            }\r\n\r\n            //save the base element into a temp base element\r\n            var tempBase = base;\r\n\r\n            // for ie 9 and 8\r\n            if (isXDomainRequest) {\r\n                ajaxRequest.onload = function (e) {\r\n                    ajaxRequest.readyState = 4;\r\n                    ajaxRequest.status = 200;\r\n                    ajaxRequest.onreadystatechange();\r\n                };\r\n                ajaxRequest.onerror = function (e) {\r\n                    ajaxRequest.readyState = 0;\r\n                    ajaxRequest.status = 400;\r\n                    ajaxRequest.onreadystatechange();\r\n                };\r\n            }\r\n            else if (typeof progress === 'function') {\r\n                ajaxRequest.onprogress = progress;\r\n            }\r\n\r\n            ajaxRequest.onreadystatechange = function () {\r\n                //check the http status\r\n                if (ajaxRequest.readyState === 4) {\r\n                    if (ajaxRequest.status >= 200 && ajaxRequest.status < 300) {\r\n\r\n                        //dealing with the response\r\n                        if (ajaxRequest.status !== 204) {\r\n                            if (!isBatch) {\r\n                                parseResponse(ajaxRequest.responseText, tempBase);\r\n                                //callback.call(tempBase,tempBase.data);\r\n                            }\r\n                            //else, handling a $batch response\r\n                            else {\r\n                                var dataArray = [];\r\n                                var regex = /({[\\s\\S]*?--batchresponse_)/g;\r\n                                var result;\r\n                                do {\r\n                                    result = regex.exec(ajaxRequest.responseText);\r\n                                    if (result) {\r\n                                        parseResponse(result[0].substring(0, result[0].length - 16), tempBase);\r\n                                        dataArray.push(tempBase.data);\r\n                                    }\r\n\r\n                                } while (result);\r\n\r\n                                tempBase.data = dataArray;\r\n                            }\r\n                        }\r\n\r\n                        //call the Callback (check for Q-promise)\r\n                        if (currentPromise) {\r\n                            currentPromise.resolve(tempBase);\r\n                        }\r\n                        if (typeof callback === 'function') {\r\n                            callback.call(tempBase, tempBase.data, param);\r\n                        }\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var errResponse = ajaxRequest.responseText;\r\n\r\n                            if (JSON && ajaxRequest.responseText != \"\")\r\n                                errResponse = JSON.parse(ajaxRequest.responseText);\r\n\r\n                            if (errResponse !== '' && errResponse['odata.error']) {\r\n                                var errorMsg = errResponse['odata.error'].message.value + ' | HTTP Status: ' + ajaxRequest.status + ' | oData Code: ' + errResponse['odata.error'].code;\r\n                                throwEx(errorMsg);\r\n                            }\r\n                            else {\r\n                                throwEx('Request to ' + buildQuery() + ' failed with HTTP status ' + (ajaxRequest.status || 404) + '.');\r\n                            }\r\n                        } catch (ex) {\r\n                            endLoading(tempBase, true, ajaxRequest.status || 404, ajaxRequest.responseText);\r\n                            if (typeof errorCallback === 'function') {\r\n                                errorCallback(ajaxRequest.status || 404, ex)\r\n                            }\r\n                            else if (currentPromise) {\r\n                                ex.status = (ajaxRequest.status || 404);\r\n                                currentPromise.reject(ex);\r\n                            }\r\n                            else {\r\n                                throw ex;\r\n                            }\r\n                        }\r\n                    }\r\n                    //end the loading when everything is okay\r\n                    endLoading(tempBase, false);\r\n                }\r\n            }\r\n\r\n            //check if we need to preflight the request (only if basic auth and isAsync)\r\n            if (base.oConfig.username && base.oConfig.password) {\r\n                //ajaxRequest.withCredentials=true;\r\n                if (isXDomainRequest) {\r\n                    throwEx('CORS and Basic Auth is not supported for IE <= 9. Try to set isCors:false in the OData config if you do not need CORS support.');\r\n                }\r\n                ajaxRequest.setRequestHeader('Authorization', 'Basic ' + encodeBase64(base.oConfig.username + ':' + base.oConfig.password));\r\n            }\r\n\r\n            //check if not IE 9 or 8\r\n            if (!isXDomainRequest) {\r\n                //set headers\r\n                if (headers) {\r\n                    //normal headers\r\n                    for (var i = 0; i < headers.length; i++) {\r\n                        ajaxRequest.setRequestHeader(headers[i].name, headers[i].value);\r\n                    }\r\n                }\r\n\r\n                //additional headers\r\n                if (base.oConfig.headers.length > 0) {\r\n                    //TODO: merge both normal and additional headers?!\r\n                    for (var i = 0; i < base.oConfig.headers.length; i++) {\r\n                        ajaxRequest.setRequestHeader(base.oConfig.headers[i].name, base.oConfig.headers[i].value);\r\n                    }\r\n                }\r\n            }\r\n            ajaxRequest.send(data);\r\n        }\r\n\r\n        //+++\r\n        // Cancels the loading state\r\n        //+++\r\n        function endLoading(base, isError, status, msg) {\r\n            if (base.oConfig.ready && overideLoading == null) {\r\n                base.oConfig.openAjaxRequests--;\r\n                if (base.oConfig.openAjaxRequests <= 0) {\r\n                    base.oConfig.ready();\r\n                }\r\n            }\r\n\r\n            if (overideLoading && overideLoading[1]) {\r\n                overideLoading[1](false);\r\n            }\r\n\r\n            if (base.oConfig.error && isError) {\r\n                base.oConfig.error(status, msg);\r\n            }\r\n        }\r\n\r\n\r\n        // +++\r\n        // this function parses a normal response to a JSON response\r\n        // +++\r\n        function parseResponse(response, tempBase) {\r\n            var count = tryParseInt(response, -1);\r\n            if (count !== -1) {\r\n                tempBase.data = count;\r\n            }\r\n            else {\r\n                if (JSON && response !== '') {\r\n                    var data = JSON.parse(response);\r\n                    tempBase.raw = data;\r\n                    if (data.hasOwnProperty('value')) {\r\n                        if (isQuery(['$first']) && data.value.length && data.value.length <= 1) {\r\n                            tempBase.data = data.value[0];\r\n                        }\r\n                        else {\r\n                            tempBase.data = data.value;\r\n                        }\r\n                        if (data.hasOwnProperty('odata.count') || data.hasOwnProperty('@odata.count')) {\r\n                            tempBase.inlinecount = data['odata.count'] || data['@odata.count'];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempBase.data = data;\r\n                    }\r\n                    resource.data = tempBase.data;\r\n                }\r\n                else {\r\n                    tempBase.data = response;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // +++\r\n        // Create the XHR object with CORS support\r\n        // +++\r\n        function createCORSRequest(method, url) {\r\n            var xhr = null;\r\n\r\n            //if no window assume node.js\r\n            if (typeof window === 'undefined') {\r\n                var Xhr2 = __webpack_require__(572);\r\n                xhr = new Xhr2();\r\n            }\r\n            else {\r\n                xhr = new XMLHttpRequest();\r\n            }\r\n\r\n            if (base.oConfig.isCors && 'withCredentials' in xhr) {\r\n\t\t\t\txhr.withCredentials=true;\r\n                // XHR for Chrome/Firefox/Opera/Safari.\r\n                xhr.open(method, url, base.oConfig.isAsync);\r\n            }\r\n            else if (base.oConfig.isCors && typeof XDomainRequest !== 'undefined') {\r\n                // XDomainRequest for IE.\r\n                xhr = new XDomainRequest();\r\n                // does not support PUT PATCH operations -> Switch to batch\r\n                isXDomainRequest = true;\r\n                if (method == 'GET')\r\n                    xhr.open(method, url);\r\n                else\r\n                    xhr.open('POST', url);\r\n            }\r\n            else {\r\n                // CORS not supported or forced\r\n                xhr.open(method, url, base.oConfig.isAsync);\r\n            }\r\n            return xhr;\r\n        }\r\n\r\n        // +++\r\n        // helper function to format a string with :vars\r\n        // +++\r\n        function strFormat() {\r\n            var str = arguments[0];\r\n            var para = arguments[1];\r\n            for (var p in para) {\r\n                var regex = new RegExp(p, 'g');\r\n                if (typeof str === 'string')\r\n                    str = str.replace(regex, para[p]);\r\n            }\r\n\r\n            return str;\r\n        }\r\n\r\n        //+++\r\n        // encode a string to base64\r\n        // +++\r\n        function encodeBase64(str) {\r\n            var Base64 = {\r\n\r\n                // private property\r\n                _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\r\n\r\n                // private method for encoding\r\n                encode: function (input) {\r\n                    var output = '';\r\n                    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n                    var i = 0;\r\n\r\n                    input = Base64._utf8_encode(input);\r\n\r\n                    while (i < input.length) {\r\n\r\n                        chr1 = input.charCodeAt(i++);\r\n                        chr2 = input.charCodeAt(i++);\r\n                        chr3 = input.charCodeAt(i++);\r\n\r\n                        enc1 = chr1 >> 2;\r\n                        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n                        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n                        enc4 = chr3 & 63;\r\n\r\n                        if (isNaN(chr2)) {\r\n                            enc3 = enc4 = 64;\r\n                        } else if (isNaN(chr3)) {\r\n                            enc4 = 64;\r\n                        }\r\n\r\n                        output = output +\r\n                            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\r\n                            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\r\n\r\n                    }\r\n\r\n                    return output;\r\n                },\r\n\r\n\r\n                // private method for UTF-8 encoding\r\n                _utf8_encode: function (string) {\r\n                    string = string.replace(/\\r\\n/g, '\\n');\r\n                    var utftext = '';\r\n\r\n                    for (var n = 0; n < string.length; n++) {\r\n\r\n                        var c = string.charCodeAt(n);\r\n\r\n                        if (c < 128) {\r\n                            utftext += String.fromCharCode(c);\r\n                        }\r\n                        else if ((c > 127) && (c < 2048)) {\r\n                            utftext += String.fromCharCode((c >> 6) | 192);\r\n                            utftext += String.fromCharCode((c & 63) | 128);\r\n                        }\r\n                        else {\r\n                            utftext += String.fromCharCode((c >> 12) | 224);\r\n                            utftext += String.fromCharCode(((c >> 6) & 63) | 128);\r\n                            utftext += String.fromCharCode((c & 63) | 128);\r\n                        }\r\n\r\n                    }\r\n\r\n                    return utftext;\r\n                }\r\n            }\r\n\r\n            return (Base64.encode(str));\r\n        }\r\n\r\n        return (init(res));\r\n    }\r\n\r\n    return o;\r\n}));\r\n\n\n/***/ }),\n\n/***/ 572:\n/***/ (function(module, exports) {\n\nmodule.exports = XMLHttpRequest;\n\n\n/***/ }),\n\n/***/ 617:\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(618);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(481)(\"ec996900\", content, true);\n\n/***/ }),\n\n/***/ 618:\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(480)(true);\n// imports\n\n\n// module\nexports.push([module.i, \"\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"index.vue\",\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n/***/ }),\n\n/***/ 619:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__ = __webpack_require__(223);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nav__ = __webpack_require__(620);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__components___ = __webpack_require__(229);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_vuex__ = __webpack_require__(56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_signalr_no_jquery__ = __webpack_require__(621);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_signalr_no_jquery___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_signalr_no_jquery__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__store__ = __webpack_require__(628);\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  name: 'SupplierContainer',\n  components: {\n    AppHeader: __WEBPACK_IMPORTED_MODULE_2__components___[\"d\" /* Header */],\n    Sidebar: __WEBPACK_IMPORTED_MODULE_2__components___[\"e\" /* Sidebar */]\n  },\n  data: function data() {\n    return {\n      nav: __WEBPACK_IMPORTED_MODULE_1__nav__[\"a\" /* default */].items\n    };\n  },\n\n  computed: __WEBPACK_IMPORTED_MODULE_0_babel_runtime_helpers_extends___default()({}, Object(__WEBPACK_IMPORTED_MODULE_3_vuex__[\"b\" /* mapGetters */])({\n    supplier: '$_supplier_view/supplier'\n  }), {\n    name: function name() {\n      return this.$route.name;\n    },\n    list: function list() {\n      return this.$route.matched;\n    }\n  }),\n  created: function created() {\n    this.$store.registerModule('$_supplier_view', __WEBPACK_IMPORTED_MODULE_5__store__[\"a\" /* default */]);\n\n    var connection = Object(__WEBPACK_IMPORTED_MODULE_4_signalr_no_jquery__[\"hubConnection\"])('http://axiomcredit-001-site1.etempurl.com/signalr');\n    var hubProxy = connection.createHubProxy('chatHub');\n    hubProxy.on('hello', function () {\n      console.log('Hello from the other side');\n    });\n    connection.start({ jsonp: true }).done(function () {\n      console.log('Now connected, connection ID=' + connection.id);\n    }).fail(function () {\n      console.log('Could not connect');\n    });\n  },\n  mounted: function mounted() {\n    this.$store.dispatch('$_supplier_view/GET_SUPPLIER');\n  }\n});\n\n/***/ }),\n\n/***/ 620:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  items: [{\n    name: 'Profile',\n    icon: 'icon-user'\n  }, {\n    name: 'Notifications',\n    icon: 'icon-bell'\n  }, {\n    name: 'Messages',\n    icon: 'icon-speedometer'\n  }]\n});\n\n/***/ }),\n\n/***/ 621:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar jQueryShim = __webpack_require__(622);\r\n\r\n/* jquery.signalR.core.js */\r\n/*global window:false */\r\n/*!\r\n * ASP.NET SignalR JavaScript Library v2.2.1\r\n * http://signalr.net/\r\n *\r\n * Copyright (c) .NET Foundation. All rights reserved.\r\n * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n *\r\n */\r\n\r\n/// <reference path=\"Scripts/jquery-1.6.4.js\" />\r\n/// <reference path=\"jquery.signalR.version.js\" />\r\n(function ($, window, undefined) {\r\n\r\n    var resources = {\r\n        nojQuery: \"jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.\",\r\n        noTransportOnInit: \"No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.\",\r\n        errorOnNegotiate: \"Error during negotiation request.\",\r\n        stoppedWhileLoading: \"The connection was stopped during page load.\",\r\n        stoppedWhileNegotiating: \"The connection was stopped during the negotiate request.\",\r\n        errorParsingNegotiateResponse: \"Error parsing negotiate response.\",\r\n        errorDuringStartRequest: \"Error during start request. Stopping the connection.\",\r\n        stoppedDuringStartRequest: \"The connection was stopped during the start request.\",\r\n        errorParsingStartResponse: \"Error parsing start response: '{0}'. Stopping the connection.\",\r\n        invalidStartResponse: \"Invalid start response: '{0}'. Stopping the connection.\",\r\n        protocolIncompatible: \"You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.\",\r\n        sendFailed: \"Send failed.\",\r\n        parseFailed: \"Failed at parsing response: {0}\",\r\n        longPollFailed: \"Long polling request failed.\",\r\n        eventSourceFailedToConnect: \"EventSource failed to connect.\",\r\n        eventSourceError: \"Error raised by EventSource\",\r\n        webSocketClosed: \"WebSocket closed.\",\r\n        pingServerFailedInvalidResponse: \"Invalid ping response when pinging server: '{0}'.\",\r\n        pingServerFailed: \"Failed to ping server.\",\r\n        pingServerFailedStatusCode: \"Failed to ping server.  Server responded with status code {0}, stopping the connection.\",\r\n        pingServerFailedParse: \"Failed to parse ping server response, stopping the connection.\",\r\n        noConnectionTransport: \"Connection is in an invalid state, there is no transport active.\",\r\n        webSocketsInvalidState: \"The Web Socket transport is in an invalid state, transitioning into reconnecting.\",\r\n        reconnectTimeout: \"Couldn't reconnect within the configured timeout of {0} ms, disconnecting.\",\r\n        reconnectWindowTimeout: \"The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection.\"\r\n    };\r\n\r\n    if (typeof $ !== \"function\") {\r\n        // no jQuery!\r\n        throw new Error(resources.nojQuery);\r\n    }\r\n\r\n    var _signalR,\r\n        _connection,\r\n        _pageLoaded = window.document.readyState === \"complete\",\r\n        _pageWindow = $(window),\r\n        _negotiateAbortText = \"__Negotiate Aborted__\",\r\n        events = {\r\n        onStart: \"onStart\",\r\n        onStarting: \"onStarting\",\r\n        onReceived: \"onReceived\",\r\n        onError: \"onError\",\r\n        onConnectionSlow: \"onConnectionSlow\",\r\n        onReconnecting: \"onReconnecting\",\r\n        onReconnect: \"onReconnect\",\r\n        onStateChanged: \"onStateChanged\",\r\n        onDisconnect: \"onDisconnect\"\r\n    },\r\n        ajaxDefaults = {\r\n        processData: true,\r\n        timeout: null,\r\n        async: true,\r\n        global: false,\r\n        cache: false\r\n    },\r\n        _log = function _log(msg, logging) {\r\n        if (logging === false) {\r\n            return;\r\n        }\r\n        var m;\r\n        if (typeof window.console === \"undefined\") {\r\n            return;\r\n        }\r\n        m = \"[\" + new Date().toTimeString() + \"] SignalR: \" + msg;\r\n        if (window.console.debug) {\r\n            window.console.debug(m);\r\n        } else if (window.console.log) {\r\n            window.console.log(m);\r\n        }\r\n    },\r\n        changeState = function changeState(connection, expectedState, newState) {\r\n        if (expectedState === connection.state) {\r\n            connection.state = newState;\r\n\r\n            $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n        isDisconnecting = function isDisconnecting(connection) {\r\n        return connection.state === _signalR.connectionState.disconnected;\r\n    },\r\n        supportsKeepAlive = function supportsKeepAlive(connection) {\r\n        return connection._.keepAliveData.activated && connection.transport.supportsKeepAlive(connection);\r\n    },\r\n        configureStopReconnectingTimeout = function configureStopReconnectingTimeout(connection) {\r\n        var stopReconnectingTimeout, onReconnectTimeout;\r\n\r\n        // Check if this connection has already been configured to stop reconnecting after a specified timeout.\r\n        // Without this check if a connection is stopped then started events will be bound multiple times.\r\n        if (!connection._.configuredStopReconnectingTimeout) {\r\n            onReconnectTimeout = function onReconnectTimeout(connection) {\r\n                var message = _signalR._.format(_signalR.resources.reconnectTimeout, connection.disconnectTimeout);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [_signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n            };\r\n\r\n            connection.reconnecting(function () {\r\n                var connection = this;\r\n\r\n                // Guard against state changing in a previous user defined even handler\r\n                if (connection.state === _signalR.connectionState.reconnecting) {\r\n                    stopReconnectingTimeout = window.setTimeout(function () {\r\n                        onReconnectTimeout(connection);\r\n                    }, connection.disconnectTimeout);\r\n                }\r\n            });\r\n\r\n            connection.stateChanged(function (data) {\r\n                if (data.oldState === _signalR.connectionState.reconnecting) {\r\n                    // Clear the pending reconnect timeout check\r\n                    window.clearTimeout(stopReconnectingTimeout);\r\n                }\r\n            });\r\n\r\n            connection._.configuredStopReconnectingTimeout = true;\r\n        }\r\n    };\r\n\r\n    _signalR = function signalR(url, qs, logging) {\r\n        /// <summary>Creates a new SignalR connection for the given url</summary>\r\n        /// <param name=\"url\" type=\"String\">The URL of the long polling endpoint</param>\r\n        /// <param name=\"qs\" type=\"Object\">\r\n        ///     [Optional] Custom querystring parameters to add to the connection URL.\r\n        ///     If an object, every non-function member will be added to the querystring.\r\n        ///     If a string, it's added to the QS as specified.\r\n        /// </param>\r\n        /// <param name=\"logging\" type=\"Boolean\">\r\n        ///     [Optional] A flag indicating whether connection logging is enabled to the browser\r\n        ///     console/log. Defaults to false.\r\n        /// </param>\r\n\r\n        return new _signalR.fn.init(url, qs, logging);\r\n    };\r\n\r\n    _signalR._ = {\r\n        defaultContentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\r\n        ieVersion: function () {\r\n            var version, matches;\r\n\r\n            if (window.navigator.appName === 'Microsoft Internet Explorer') {\r\n                // Check if the user agent has the pattern \"MSIE (one or more numbers).(one or more numbers)\";\r\n                matches = /MSIE ([0-9]+\\.[0-9]+)/.exec(window.navigator.userAgent);\r\n\r\n                if (matches) {\r\n                    version = window.parseFloat(matches[1]);\r\n                }\r\n            }\r\n\r\n            // undefined value means not IE\r\n            return version;\r\n        }(),\r\n\r\n        error: function error(message, source, context) {\r\n            var e = new Error(message);\r\n            e.source = source;\r\n\r\n            if (typeof context !== \"undefined\") {\r\n                e.context = context;\r\n            }\r\n\r\n            return e;\r\n        },\r\n\r\n        transportError: function transportError(message, transport, source, context) {\r\n            var e = this.error(message, source, context);\r\n            e.transport = transport ? transport.name : undefined;\r\n            return e;\r\n        },\r\n\r\n        format: function format() {\r\n            /// <summary>Usage: format(\"Hi {0}, you are {1}!\", \"Foo\", 100) </summary>\r\n            var s = arguments[0];\r\n            for (var i = 0; i < arguments.length - 1; i++) {\r\n                s = s.replace(\"{\" + i + \"}\", arguments[i + 1]);\r\n            }\r\n            return s;\r\n        },\r\n\r\n        firefoxMajorVersion: function firefoxMajorVersion(userAgent) {\r\n            // Firefox user agents: http://useragentstring.com/pages/Firefox/\r\n            var matches = userAgent.match(/Firefox\\/(\\d+)/);\r\n            if (!matches || !matches.length || matches.length < 2) {\r\n                return 0;\r\n            }\r\n            return parseInt(matches[1], 10 /* radix */);\r\n        },\r\n\r\n        configurePingInterval: function configurePingInterval(connection) {\r\n            var config = connection._.config,\r\n                onFail = function onFail(error) {\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n            };\r\n\r\n            if (config && !connection._.pingIntervalId && config.pingInterval) {\r\n                connection._.pingIntervalId = window.setInterval(function () {\r\n                    _signalR.transports._logic.pingServer(connection).fail(onFail);\r\n                }, config.pingInterval);\r\n            }\r\n        }\r\n    };\r\n\r\n    _signalR.events = events;\r\n\r\n    _signalR.resources = resources;\r\n\r\n    _signalR.ajaxDefaults = ajaxDefaults;\r\n\r\n    _signalR.changeState = changeState;\r\n\r\n    _signalR.isDisconnecting = isDisconnecting;\r\n\r\n    _signalR.connectionState = {\r\n        connecting: 0,\r\n        connected: 1,\r\n        reconnecting: 2,\r\n        disconnected: 4\r\n    };\r\n\r\n    _signalR.hub = {\r\n        start: function start() {\r\n            // This will get replaced with the real hub connection start method when hubs is referenced correctly\r\n            throw new Error(\"SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.\");\r\n        }\r\n    };\r\n\r\n    // .on() was added in version 1.7.0, .load() was removed in version 3.0.0 so we fallback to .load() if .on() does\r\n    // not exist to not break existing applications\r\n    if (typeof _pageWindow.on == \"function\") {\r\n        _pageWindow.on(\"load\", function () {\r\n            _pageLoaded = true;\r\n        });\r\n    } else {\r\n        _pageWindow.load(function () {\r\n            _pageLoaded = true;\r\n        });\r\n    }\r\n\r\n    function validateTransport(requestedTransport, connection) {\r\n        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>\r\n        /// <param name=\"requestedTransport\" type=\"Object\">The designated transports that the user has specified.</param>\r\n        /// <param name=\"connection\" type=\"signalR\">The connection that will be using the requested transports.  Used for logging purposes.</param>\r\n        /// <returns type=\"Object\" />\r\n\r\n        if ($.isArray(requestedTransport)) {\r\n            // Go through transport array and remove an \"invalid\" tranports\r\n            for (var i = requestedTransport.length - 1; i >= 0; i--) {\r\n                var transport = requestedTransport[i];\r\n                if ($.type(transport) !== \"string\" || !_signalR.transports[transport]) {\r\n                    connection.log(\"Invalid transport: \" + transport + \", removing it from the transports list.\");\r\n                    requestedTransport.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Verify we still have transports left, if we dont then we have invalid transports\r\n            if (requestedTransport.length === 0) {\r\n                connection.log(\"No transports remain within the specified transport array.\");\r\n                requestedTransport = null;\r\n            }\r\n        } else if (!_signalR.transports[requestedTransport] && requestedTransport !== \"auto\") {\r\n            connection.log(\"Invalid transport: \" + requestedTransport.toString() + \".\");\r\n            requestedTransport = null;\r\n        } else if (requestedTransport === \"auto\" && _signalR._.ieVersion <= 8) {\r\n            // If we're doing an auto transport and we're IE8 then force longPolling, #1764\r\n            return [\"longPolling\"];\r\n        }\r\n\r\n        return requestedTransport;\r\n    }\r\n\r\n    function getDefaultPort(protocol) {\r\n        if (protocol === \"http:\") {\r\n            return 80;\r\n        } else if (protocol === \"https:\") {\r\n            return 443;\r\n        }\r\n    }\r\n\r\n    function addDefaultPort(protocol, url) {\r\n        // Remove ports  from url.  We have to check if there's a / or end of line\r\n        // following the port in order to avoid removing ports such as 8080.\r\n        if (url.match(/:\\d+$/)) {\r\n            return url;\r\n        } else {\r\n            return url + \":\" + getDefaultPort(protocol);\r\n        }\r\n    }\r\n\r\n    function ConnectingMessageBuffer(connection, drainCallback) {\r\n        var that = this,\r\n            buffer = [];\r\n\r\n        that.tryBuffer = function (message) {\r\n            if (connection.state === $.signalR.connectionState.connecting) {\r\n                buffer.push(message);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        that.drain = function () {\r\n            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                while (buffer.length > 0) {\r\n                    drainCallback(buffer.shift());\r\n                }\r\n            }\r\n        };\r\n\r\n        that.clear = function () {\r\n            buffer = [];\r\n        };\r\n    }\r\n\r\n    _signalR.fn = _signalR.prototype = {\r\n        init: function init(url, qs, logging) {\r\n            var $connection = $(this);\r\n\r\n            this.url = url;\r\n            this.qs = qs;\r\n            this.lastError = null;\r\n            this._ = {\r\n                keepAliveData: {},\r\n                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {\r\n                    $connection.triggerHandler(events.onReceived, [message]);\r\n                }),\r\n                lastMessageAt: new Date().getTime(),\r\n                lastActiveAt: new Date().getTime(),\r\n                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,\r\n                beatHandle: null,\r\n                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout\r\n            };\r\n            if (typeof logging === \"boolean\") {\r\n                this.logging = logging;\r\n            }\r\n        },\r\n\r\n        _parseResponse: function _parseResponse(response) {\r\n            var that = this;\r\n\r\n            if (!response) {\r\n                return response;\r\n            } else if (typeof response === \"string\") {\r\n                return that.json.parse(response);\r\n            } else {\r\n                return response;\r\n            }\r\n        },\r\n\r\n        _originalJson: window.JSON,\r\n\r\n        json: window.JSON,\r\n\r\n        isCrossDomain: function isCrossDomain(url, against) {\r\n            /// <summary>Checks if url is cross domain</summary>\r\n            /// <param name=\"url\" type=\"String\">The base URL</param>\r\n            /// <param name=\"against\" type=\"Object\">\r\n            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.\r\n            ///     If specified it must contain a protocol and a host property.\r\n            /// </param>\r\n            var link;\r\n\r\n            url = $.trim(url);\r\n\r\n            against = against || window.location;\r\n\r\n            if (url.indexOf(\"http\") !== 0) {\r\n                return false;\r\n            }\r\n\r\n            // Create an anchor tag.\r\n            link = window.document.createElement(\"a\");\r\n            link.href = url;\r\n\r\n            // When checking for cross domain we have to special case port 80 because the window.location will remove the\r\n            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);\r\n        },\r\n\r\n        ajaxDataType: \"text\",\r\n\r\n        contentType: \"application/json; charset=UTF-8\",\r\n\r\n        logging: false,\r\n\r\n        state: _signalR.connectionState.disconnected,\r\n\r\n        clientProtocol: \"1.5\",\r\n\r\n        reconnectDelay: 2000,\r\n\r\n        transportConnectTimeout: 0,\r\n\r\n        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)\r\n\r\n        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request\r\n\r\n        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout\r\n\r\n        start: function start(options, callback) {\r\n            /// <summary>Starts the connection</summary>\r\n            /// <param name=\"options\" type=\"Object\">Options map</param>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection has started</param>\r\n            var connection = this,\r\n                config = {\r\n                pingInterval: 300000,\r\n                waitForPageLoad: true,\r\n                transport: \"auto\",\r\n                jsonp: false\r\n            },\r\n                _initialize,\r\n                deferred = connection._deferral || $.Deferred(),\r\n                // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it\r\n            parser = window.document.createElement(\"a\");\r\n\r\n            connection.lastError = null;\r\n\r\n            // Persist the deferral so that if start is called multiple times the same deferral is used.\r\n            connection._deferral = deferred;\r\n\r\n            if (!connection.json) {\r\n                // no JSON!\r\n                throw new Error(\"SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.\");\r\n            }\r\n\r\n            if ($.type(options) === \"function\") {\r\n                // Support calling with single callback parameter\r\n                callback = options;\r\n            } else if ($.type(options) === \"object\") {\r\n                $.extend(config, options);\r\n                if ($.type(config.callback) === \"function\") {\r\n                    callback = config.callback;\r\n                }\r\n            }\r\n\r\n            config.transport = validateTransport(config.transport, connection);\r\n\r\n            // If the transport is invalid throw an error and abort start\r\n            if (!config.transport) {\r\n                throw new Error(\"SignalR: Invalid transport(s) specified, aborting start.\");\r\n            }\r\n\r\n            connection._.config = config;\r\n\r\n            // Check to see if start is being called prior to page load\r\n            // If waitForPageLoad is true we then want to re-direct function call to the window load event\r\n            if (!_pageLoaded && config.waitForPageLoad === true) {\r\n                connection._.deferredStartHandler = function () {\r\n                    connection.start(options, callback);\r\n                };\r\n                _pageWindow.bind(\"load\", connection._.deferredStartHandler);\r\n\r\n                return deferred.promise();\r\n            }\r\n\r\n            // If we're already connecting just return the same deferral as the original connection start\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                return deferred.promise();\r\n            } else if (changeState(connection, _signalR.connectionState.disconnected, _signalR.connectionState.connecting) === false) {\r\n                // We're not connecting so try and transition into connecting.\r\n                // If we fail to transition then we're either in connected or reconnecting.\r\n\r\n                deferred.resolve(connection);\r\n                return deferred.promise();\r\n            }\r\n\r\n            configureStopReconnectingTimeout(connection);\r\n\r\n            // Resolve the full url\r\n            parser.href = connection.url;\r\n            if (!parser.protocol || parser.protocol === \":\") {\r\n                connection.protocol = window.document.location.protocol;\r\n                connection.host = parser.host || window.document.location.host;\r\n            } else {\r\n                connection.protocol = parser.protocol;\r\n                connection.host = parser.host;\r\n            }\r\n\r\n            connection.baseUrl = connection.protocol + \"//\" + connection.host;\r\n\r\n            // Set the websocket protocol\r\n            connection.wsProtocol = connection.protocol === \"https:\" ? \"wss://\" : \"ws://\";\r\n\r\n            // If jsonp with no/auto transport is specified, then set the transport to long polling\r\n            // since that is the only transport for which jsonp really makes sense.\r\n            // Some developers might actually choose to specify jsonp for same origin requests\r\n            // as demonstrated by Issue #623.\r\n            if (config.transport === \"auto\" && config.jsonp === true) {\r\n                config.transport = \"longPolling\";\r\n            }\r\n\r\n            // If the url is protocol relative, prepend the current windows protocol to the url.\r\n            if (connection.url.indexOf(\"//\") === 0) {\r\n                connection.url = window.location.protocol + connection.url;\r\n                connection.log(\"Protocol relative URL detected, normalizing it to '\" + connection.url + \"'.\");\r\n            }\r\n\r\n            if (this.isCrossDomain(connection.url)) {\r\n                connection.log(\"Auto detected cross domain url.\");\r\n\r\n                if (config.transport === \"auto\") {\r\n                    // TODO: Support XDM with foreverFrame\r\n                    config.transport = [\"webSockets\", \"serverSentEvents\", \"longPolling\"];\r\n                }\r\n\r\n                if (typeof config.withCredentials === \"undefined\") {\r\n                    config.withCredentials = true;\r\n                }\r\n\r\n                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.\r\n                // i.e. if the browser doesn't supports CORS\r\n                // If it is, ignore any preference to the contrary, and switch to jsonp.\r\n                if (!config.jsonp) {\r\n                    config.jsonp = !$.support.cors;\r\n\r\n                    if (config.jsonp) {\r\n                        connection.log(\"Using jsonp because this browser doesn't support CORS.\");\r\n                    }\r\n                }\r\n\r\n                connection.contentType = _signalR._.defaultContentType;\r\n            }\r\n\r\n            connection.withCredentials = config.withCredentials;\r\n\r\n            connection.ajaxDataType = config.jsonp ? \"jsonp\" : \"text\";\r\n\r\n            $(connection).bind(events.onStart, function (e, data) {\r\n                if ($.type(callback) === \"function\") {\r\n                    callback.call(connection);\r\n                }\r\n                deferred.resolve(connection);\r\n            });\r\n\r\n            connection._.initHandler = _signalR.transports._logic.initHandler(connection);\r\n\r\n            _initialize = function initialize(transports, index) {\r\n                var noTransportError = _signalR._.error(resources.noTransportOnInit);\r\n\r\n                index = index || 0;\r\n                if (index >= transports.length) {\r\n                    if (index === 0) {\r\n                        connection.log(\"No transports supported by the server were selected.\");\r\n                    } else if (index === 1) {\r\n                        connection.log(\"No fallback transports were selected.\");\r\n                    } else {\r\n                        connection.log(\"Fallback transports exhausted.\");\r\n                    }\r\n\r\n                    // No transport initialized successfully\r\n                    $(connection).triggerHandler(events.onError, [noTransportError]);\r\n                    deferred.reject(noTransportError);\r\n                    // Stop the connection if it has connected and move it into the disconnected state\r\n                    connection.stop();\r\n                    return;\r\n                }\r\n\r\n                // The connection was aborted\r\n                if (connection.state === _signalR.connectionState.disconnected) {\r\n                    return;\r\n                }\r\n\r\n                var transportName = transports[index],\r\n                    transport = _signalR.transports[transportName],\r\n                    onFallback = function onFallback() {\r\n                    _initialize(transports, index + 1);\r\n                };\r\n\r\n                connection.transport = transport;\r\n\r\n                try {\r\n                    connection._.initHandler.start(transport, function () {\r\n                        // success\r\n                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials\r\n                        var isFirefox11OrGreater = _signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,\r\n                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;\r\n\r\n                        connection.log(\"The start request succeeded. Transitioning to the connected state.\");\r\n\r\n                        if (supportsKeepAlive(connection)) {\r\n                            _signalR.transports._logic.monitorKeepAlive(connection);\r\n                        }\r\n\r\n                        _signalR.transports._logic.startHeartbeat(connection);\r\n\r\n                        // Used to ensure low activity clients maintain their authentication.\r\n                        // Must be configured once a transport has been decided to perform valid ping requests.\r\n                        _signalR._.configurePingInterval(connection);\r\n\r\n                        if (!changeState(connection, _signalR.connectionState.connecting, _signalR.connectionState.connected)) {\r\n                            connection.log(\"WARNING! The connection was not in the connecting state.\");\r\n                        }\r\n\r\n                        // Drain any incoming buffered messages (messages that came in prior to connect)\r\n                        connection._.connectingMessageBuffer.drain();\r\n\r\n                        $(connection).triggerHandler(events.onStart);\r\n\r\n                        // wire the stop handler for when the user leaves the page\r\n                        _pageWindow.bind(\"unload\", function () {\r\n                            connection.log(\"Window unloading, stopping the connection.\");\r\n\r\n                            connection.stop(asyncAbort);\r\n                        });\r\n\r\n                        if (isFirefox11OrGreater) {\r\n                            // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.\r\n                            // #2400\r\n                            _pageWindow.bind(\"beforeunload\", function () {\r\n                                // If connection.stop() runs runs in beforeunload and fails, it will also fail\r\n                                // in unload unless connection.stop() runs after a timeout.\r\n                                window.setTimeout(function () {\r\n                                    connection.stop(asyncAbort);\r\n                                }, 0);\r\n                            });\r\n                        }\r\n                    }, onFallback);\r\n                } catch (error) {\r\n                    connection.log(transport.name + \" transport threw '\" + error.message + \"' when attempting to start.\");\r\n                    onFallback();\r\n                }\r\n            };\r\n\r\n            var url = connection.url + \"/negotiate\",\r\n                onFailed = function onFailed(error, connection) {\r\n                var err = _signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);\r\n\r\n                $(connection).triggerHandler(events.onError, err);\r\n                deferred.reject(err);\r\n                // Stop the connection if negotiate failed\r\n                connection.stop();\r\n            };\r\n\r\n            $(connection).triggerHandler(events.onStarting);\r\n\r\n            url = _signalR.transports._logic.prepareQueryString(connection, url);\r\n\r\n            connection.log(\"Negotiating with '\" + url + \"'.\");\r\n\r\n            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.\r\n            connection._.negotiateRequest = _signalR.transports._logic.ajax(connection, {\r\n                url: url,\r\n                error: function error(_error, statusText) {\r\n                    // We don't want to cause any errors if we're aborting our own negotiate request.\r\n                    if (statusText !== _negotiateAbortText) {\r\n                        onFailed(_error, connection);\r\n                    } else {\r\n                        // This rejection will noop if the deferred has already been resolved or rejected.\r\n                        deferred.reject(_signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));\r\n                    }\r\n                },\r\n                success: function success(result) {\r\n                    var res,\r\n                        keepAliveData,\r\n                        protocolError,\r\n                        transports = [],\r\n                        supportedTransports = [];\r\n\r\n                    try {\r\n                        res = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        onFailed(_signalR._.error(resources.errorParsingNegotiateResponse, error), connection);\r\n                        return;\r\n                    }\r\n\r\n                    keepAliveData = connection._.keepAliveData;\r\n                    connection.appRelativeUrl = res.Url;\r\n                    connection.id = res.ConnectionId;\r\n                    connection.token = res.ConnectionToken;\r\n                    connection.webSocketServerUrl = res.WebSocketServerUrl;\r\n\r\n                    // The long poll timeout is the ConnectionTimeout plus 10 seconds\r\n                    connection._.pollTimeout = res.ConnectionTimeout * 1000 + 10000; // in ms\r\n\r\n                    // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect\r\n                    // after res.DisconnectTimeout seconds.\r\n                    connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms\r\n\r\n                    // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout\r\n                    connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;\r\n\r\n                    // If we have a keep alive\r\n                    if (res.KeepAliveTimeout) {\r\n                        // Register the keep alive data as activated\r\n                        keepAliveData.activated = true;\r\n\r\n                        // Timeout to designate when to force the connection into reconnecting converted to milliseconds\r\n                        keepAliveData.timeout = res.KeepAliveTimeout * 1000;\r\n\r\n                        // Timeout to designate when to warn the developer that the connection may be dead or is not responding.\r\n                        keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;\r\n\r\n                        // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes\r\n                        connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;\r\n                    } else {\r\n                        keepAliveData.activated = false;\r\n                    }\r\n\r\n                    connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);\r\n\r\n                    if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {\r\n                        protocolError = _signalR._.error(_signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n\r\n                        return;\r\n                    }\r\n\r\n                    $.each(_signalR.transports, function (key) {\r\n                        if (key.indexOf(\"_\") === 0 || key === \"webSockets\" && !res.TryWebSockets) {\r\n                            return true;\r\n                        }\r\n                        supportedTransports.push(key);\r\n                    });\r\n\r\n                    if ($.isArray(config.transport)) {\r\n                        $.each(config.transport, function (_, transport) {\r\n                            if ($.inArray(transport, supportedTransports) >= 0) {\r\n                                transports.push(transport);\r\n                            }\r\n                        });\r\n                    } else if (config.transport === \"auto\") {\r\n                        transports = supportedTransports;\r\n                    } else if ($.inArray(config.transport, supportedTransports) >= 0) {\r\n                        transports.push(config.transport);\r\n                    }\r\n\r\n                    _initialize(transports);\r\n                }\r\n            });\r\n\r\n            return deferred.promise();\r\n        },\r\n\r\n        starting: function starting(callback) {\r\n            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute before the connection is fully instantiated.</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStarting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        send: function send(data) {\r\n            /// <summary>Sends data over the connection</summary>\r\n            /// <param name=\"data\" type=\"String\">The data to send over the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection must be started before data can be sent. Call .start() before .send()\");\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.\");\r\n            }\r\n\r\n            connection.transport.send(connection, data);\r\n            // REVIEW: Should we return deferred here?\r\n            return connection;\r\n        },\r\n\r\n        received: function received(callback) {\r\n            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when any data is received on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReceived, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stateChanged: function stateChanged(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection state changes</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStateChanged, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        error: function error(callback) {\r\n            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when an error occurs on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onError, function (e, errorData, sendData) {\r\n                connection.lastError = errorData;\r\n                // In practice 'errorData' is the SignalR built error object.\r\n                // In practice 'sendData' is undefined for all error events except those triggered by\r\n                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.\r\n                callback.call(connection, errorData, sendData);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        disconnected: function disconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is broken</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onDisconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        connectionSlow: function connectionSlow(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is slow</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onConnectionSlow, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n\r\n            return connection;\r\n        },\r\n\r\n        reconnecting: function reconnecting(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection enters a reconnecting state</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnecting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        reconnected: function reconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is restored</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stop: function stop(async, notifyServer) {\r\n            /// <summary>Stops listening</summary>\r\n            /// <param name=\"async\" type=\"Boolean\">Whether or not to asynchronously abort the connection</param>\r\n            /// <param name=\"notifyServer\" type=\"Boolean\">Whether we want to notify the server that we are aborting the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this,\r\n\r\n            // Save deferral because this is always cleaned up\r\n            deferral = connection._deferral;\r\n\r\n            // Verify that we've bound a load event.\r\n            if (connection._.deferredStartHandler) {\r\n                // Unbind the event.\r\n                _pageWindow.unbind(\"load\", connection._.deferredStartHandler);\r\n            }\r\n\r\n            // Always clean up private non-timeout based state.\r\n            delete connection._.config;\r\n            delete connection._.deferredStartHandler;\r\n\r\n            // This needs to be checked despite the connection state because a connection start can be deferred until page load.\r\n            // If we've deferred the start due to a page load we need to unbind the \"onLoad\" -> start event.\r\n            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {\r\n                connection.log(\"Stopping connection prior to negotiate.\");\r\n\r\n                // If we have a deferral we should reject it\r\n                if (deferral) {\r\n                    deferral.reject(_signalR._.error(resources.stoppedWhileLoading));\r\n                }\r\n\r\n                // Short-circuit because the start has not been fully started.\r\n                return;\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                return;\r\n            }\r\n\r\n            connection.log(\"Stopping connection.\");\r\n\r\n            // Clear this no matter what\r\n            window.clearTimeout(connection._.beatHandle);\r\n            window.clearInterval(connection._.pingIntervalId);\r\n\r\n            if (connection.transport) {\r\n                connection.transport.stop(connection);\r\n\r\n                if (notifyServer !== false) {\r\n                    connection.transport.abort(connection, async);\r\n                }\r\n\r\n                if (supportsKeepAlive(connection)) {\r\n                    _signalR.transports._logic.stopMonitoringKeepAlive(connection);\r\n                }\r\n\r\n                connection.transport = null;\r\n            }\r\n\r\n            if (connection._.negotiateRequest) {\r\n                // If the negotiation request has already completed this will noop.\r\n                connection._.negotiateRequest.abort(_negotiateAbortText);\r\n                delete connection._.negotiateRequest;\r\n            }\r\n\r\n            // Ensure that initHandler.stop() is called before connection._deferral is deleted\r\n            if (connection._.initHandler) {\r\n                connection._.initHandler.stop();\r\n            }\r\n\r\n            delete connection._deferral;\r\n            delete connection.messageId;\r\n            delete connection.groupsToken;\r\n            delete connection.id;\r\n            delete connection._.pingIntervalId;\r\n            delete connection._.lastMessageAt;\r\n            delete connection._.lastActiveAt;\r\n\r\n            // Clear out our message buffer\r\n            connection._.connectingMessageBuffer.clear();\r\n\r\n            // Trigger the disconnect event\r\n            changeState(connection, connection.state, _signalR.connectionState.disconnected);\r\n            $(connection).triggerHandler(events.onDisconnect);\r\n\r\n            return connection;\r\n        },\r\n\r\n        log: function log(msg) {\r\n            _log(msg, this.logging);\r\n        }\r\n    };\r\n\r\n    _signalR.fn.init.prototype = _signalR.fn;\r\n\r\n    _signalR.noConflict = function () {\r\n        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>\r\n        /// <returns type=\"signalR\" />\r\n        if ($.connection === _signalR) {\r\n            $.connection = _connection;\r\n        }\r\n        return _signalR;\r\n    };\r\n\r\n    if ($.connection) {\r\n        _connection = $.connection;\r\n    }\r\n\r\n    $.connection = $.signalR = _signalR;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.common.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        startAbortText = \"__Start Aborted__\",\r\n        transportLogic;\r\n\r\n    signalR.transports = {};\r\n\r\n    function beat(connection) {\r\n        if (connection._.keepAliveData.monitoring) {\r\n            checkIfAlive(connection);\r\n        }\r\n\r\n        // Ensure that we successfully marked active before continuing the heartbeat.\r\n        if (transportLogic.markActive(connection)) {\r\n            connection._.beatHandle = window.setTimeout(function () {\r\n                beat(connection);\r\n            }, connection._.beatInterval);\r\n        }\r\n    }\r\n\r\n    function checkIfAlive(connection) {\r\n        var keepAliveData = connection._.keepAliveData,\r\n            timeElapsed;\r\n\r\n        // Only check if we're connected\r\n        if (connection.state === signalR.connectionState.connected) {\r\n            timeElapsed = new Date().getTime() - connection._.lastMessageAt;\r\n\r\n            // Check if the keep alive has completely timed out\r\n            if (timeElapsed >= keepAliveData.timeout) {\r\n                connection.log(\"Keep alive timed out.  Notifying transport that connection has been lost.\");\r\n\r\n                // Notify transport that the connection has been lost\r\n                connection.transport.lostConnection(connection);\r\n            } else if (timeElapsed >= keepAliveData.timeoutWarning) {\r\n                // This is to assure that the user only gets a single warning\r\n                if (!keepAliveData.userNotified) {\r\n                    connection.log(\"Keep alive has been missed, connection may be dead/slow.\");\r\n                    $(connection).triggerHandler(events.onConnectionSlow);\r\n                    keepAliveData.userNotified = true;\r\n                }\r\n            } else {\r\n                keepAliveData.userNotified = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAjaxUrl(connection, path) {\r\n        var url = connection.url + path;\r\n\r\n        if (connection.transport) {\r\n            url += \"?transport=\" + connection.transport.name;\r\n        }\r\n\r\n        return transportLogic.prepareQueryString(connection, url);\r\n    }\r\n\r\n    function InitHandler(connection) {\r\n        this.connection = connection;\r\n\r\n        this.startRequested = false;\r\n        this.startCompleted = false;\r\n        this.connectionStopped = false;\r\n    }\r\n\r\n    InitHandler.prototype = {\r\n        start: function start(transport, onSuccess, onFallback) {\r\n            var that = this,\r\n                connection = that.connection,\r\n                failCalled = false;\r\n\r\n            if (that.startRequested || that.connectionStopped) {\r\n                connection.log(\"WARNING! \" + transport.name + \" transport cannot be started. Initialization ongoing or completed.\");\r\n                return;\r\n            }\r\n\r\n            connection.log(transport.name + \" transport starting.\");\r\n\r\n            transport.start(connection, function () {\r\n                if (!failCalled) {\r\n                    that.initReceived(transport, onSuccess);\r\n                }\r\n            }, function (error) {\r\n                // Don't allow the same transport to cause onFallback to be called twice\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    that.transportFailed(transport, error, onFallback);\r\n                }\r\n\r\n                // Returns true if the transport should stop;\r\n                // false if it should attempt to reconnect\r\n                return !that.startCompleted || that.connectionStopped;\r\n            });\r\n\r\n            that.transportTimeoutHandle = window.setTimeout(function () {\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    connection.log(transport.name + \" transport timed out when trying to connect.\");\r\n                    that.transportFailed(transport, undefined, onFallback);\r\n                }\r\n            }, connection._.totalTransportConnectTimeout);\r\n        },\r\n\r\n        stop: function stop() {\r\n            this.connectionStopped = true;\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n            signalR.transports._logic.tryAbortStartRequest(this.connection);\r\n        },\r\n\r\n        initReceived: function initReceived(transport, onSuccess) {\r\n            var that = this,\r\n                connection = that.connection;\r\n\r\n            if (that.startRequested) {\r\n                connection.log(\"WARNING! The client received multiple init messages.\");\r\n                return;\r\n            }\r\n\r\n            if (that.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            that.startRequested = true;\r\n            window.clearTimeout(that.transportTimeoutHandle);\r\n\r\n            connection.log(transport.name + \" transport connected. Initiating start request.\");\r\n            signalR.transports._logic.ajaxStart(connection, function () {\r\n                that.startCompleted = true;\r\n                onSuccess();\r\n            });\r\n        },\r\n\r\n        transportFailed: function transportFailed(transport, error, onFallback) {\r\n            var connection = this.connection,\r\n                deferred = connection._deferral,\r\n                wrappedError;\r\n\r\n            if (this.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n\r\n            if (!this.startRequested) {\r\n                transport.stop(connection);\r\n\r\n                connection.log(transport.name + \" transport failed to connect. Attempting to fall back.\");\r\n                onFallback();\r\n            } else if (!this.startCompleted) {\r\n                // Do not attempt to fall back if a start request is ongoing during a transport failure.\r\n                // Instead, trigger an error and stop the connection.\r\n                wrappedError = signalR._.error(signalR.resources.errorDuringStartRequest, error);\r\n\r\n                connection.log(transport.name + \" transport failed during the start request. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                if (deferred) {\r\n                    deferred.reject(wrappedError);\r\n                }\r\n\r\n                connection.stop();\r\n            } else {\r\n                // The start request has completed, but the connection has not stopped.\r\n                // No need to do anything here. The transport should attempt its normal reconnect logic.\r\n            }\r\n        }\r\n    };\r\n\r\n    transportLogic = signalR.transports._logic = {\r\n        ajax: function ajax(connection, options) {\r\n            return $.ajax($.extend( /*deep copy*/true, {}, $.signalR.ajaxDefaults, {\r\n                type: \"GET\",\r\n                data: {},\r\n                xhrFields: { withCredentials: connection.withCredentials },\r\n                contentType: connection.contentType,\r\n                dataType: connection.ajaxDataType\r\n            }, options));\r\n        },\r\n\r\n        pingServer: function pingServer(connection) {\r\n            /// <summary>Pings the server</summary>\r\n            /// <param name=\"connection\" type=\"signalr\">Connection associated with the server ping</param>\r\n            /// <returns type=\"signalR\" />\r\n            var url,\r\n                xhr,\r\n                deferral = $.Deferred();\r\n\r\n            if (connection.transport) {\r\n                url = connection.url + \"/ping\";\r\n\r\n                url = transportLogic.addQs(url, connection.qs);\r\n\r\n                xhr = transportLogic.ajax(connection, {\r\n                    url: url,\r\n                    success: function success(result) {\r\n                        var data;\r\n\r\n                        try {\r\n                            data = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailedParse, connection.transport, error, xhr));\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        if (data.Response === \"pong\") {\r\n                            deferral.resolve();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result), connection.transport, null /* error */\r\n                            , xhr));\r\n                        }\r\n                    },\r\n                    error: function error(_error2) {\r\n                        if (_error2.status === 401 || _error2.status === 403) {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedStatusCode, _error2.status), connection.transport, _error2, xhr));\r\n                            connection.stop();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailed, connection.transport, _error2, xhr));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                deferral.reject(signalR._.transportError(signalR.resources.noConnectionTransport, connection.transport));\r\n            }\r\n\r\n            return deferral.promise();\r\n        },\r\n\r\n        prepareQueryString: function prepareQueryString(connection, url) {\r\n            var preparedUrl;\r\n\r\n            // Use addQs to start since it handles the ?/& prefix for us\r\n            preparedUrl = transportLogic.addQs(url, \"clientProtocol=\" + connection.clientProtocol);\r\n\r\n            // Add the user-specified query string params if any\r\n            preparedUrl = transportLogic.addQs(preparedUrl, connection.qs);\r\n\r\n            if (connection.token) {\r\n                preparedUrl += \"&connectionToken=\" + window.encodeURIComponent(connection.token);\r\n            }\r\n\r\n            if (connection.data) {\r\n                preparedUrl += \"&connectionData=\" + window.encodeURIComponent(connection.data);\r\n            }\r\n\r\n            return preparedUrl;\r\n        },\r\n\r\n        addQs: function addQs(url, qs) {\r\n            var appender = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\",\r\n                firstChar;\r\n\r\n            if (!qs) {\r\n                return url;\r\n            }\r\n\r\n            if ((typeof qs === 'undefined' ? 'undefined' : _typeof(qs)) === \"object\") {\r\n                return url + appender + $.param(qs);\r\n            }\r\n\r\n            if (typeof qs === \"string\") {\r\n                firstChar = qs.charAt(0);\r\n\r\n                if (firstChar === \"?\" || firstChar === \"&\") {\r\n                    appender = \"\";\r\n                }\r\n\r\n                return url + appender + qs;\r\n            }\r\n\r\n            throw new Error(\"Query string property must be either a string or object.\");\r\n        },\r\n\r\n        // BUG #2953: The url needs to be same otherwise it will cause a memory leak\r\n        getUrl: function getUrl(connection, transport, reconnecting, poll, ajaxPost) {\r\n            /// <summary>Gets the url for making a GET based connect request</summary>\r\n            var baseUrl = transport === \"webSockets\" ? \"\" : connection.baseUrl,\r\n                url = baseUrl + connection.appRelativeUrl,\r\n                qs = \"transport=\" + transport;\r\n\r\n            if (!ajaxPost && connection.groupsToken) {\r\n                qs += \"&groupsToken=\" + window.encodeURIComponent(connection.groupsToken);\r\n            }\r\n\r\n            if (!reconnecting) {\r\n                url += \"/connect\";\r\n            } else {\r\n                if (poll) {\r\n                    // longPolling transport specific\r\n                    url += \"/poll\";\r\n                } else {\r\n                    url += \"/reconnect\";\r\n                }\r\n\r\n                if (!ajaxPost && connection.messageId) {\r\n                    qs += \"&messageId=\" + window.encodeURIComponent(connection.messageId);\r\n                }\r\n            }\r\n            url += \"?\" + qs;\r\n            url = transportLogic.prepareQueryString(connection, url);\r\n\r\n            if (!ajaxPost) {\r\n                url += \"&tid=\" + Math.floor(Math.random() * 11);\r\n            }\r\n\r\n            return url;\r\n        },\r\n\r\n        maximizePersistentResponse: function maximizePersistentResponse(minPersistentResponse) {\r\n            return {\r\n                MessageId: minPersistentResponse.C,\r\n                Messages: minPersistentResponse.M,\r\n                Initialized: typeof minPersistentResponse.S !== \"undefined\" ? true : false,\r\n                ShouldReconnect: typeof minPersistentResponse.T !== \"undefined\" ? true : false,\r\n                LongPollDelay: minPersistentResponse.L,\r\n                GroupsToken: minPersistentResponse.G\r\n            };\r\n        },\r\n\r\n        updateGroups: function updateGroups(connection, groupsToken) {\r\n            if (groupsToken) {\r\n                connection.groupsToken = groupsToken;\r\n            }\r\n        },\r\n\r\n        stringifySend: function stringifySend(connection, message) {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\" || message === null) {\r\n                return message;\r\n            }\r\n            return connection.json.stringify(message);\r\n        },\r\n\r\n        ajaxSend: function ajaxSend(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data),\r\n                url = getAjaxUrl(connection, \"/send\"),\r\n                xhr,\r\n                onFail = function onFail(error, connection) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);\r\n            };\r\n\r\n            xhr = transportLogic.ajax(connection, {\r\n                url: url,\r\n                type: connection.ajaxDataType === \"jsonp\" ? \"GET\" : \"POST\",\r\n                contentType: signalR._.defaultContentType,\r\n                data: {\r\n                    data: payload\r\n                },\r\n                success: function success(result) {\r\n                    var res;\r\n\r\n                    if (result) {\r\n                        try {\r\n                            res = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            onFail(error, connection);\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        transportLogic.triggerReceived(connection, res);\r\n                    }\r\n                },\r\n                error: function error(_error3, textStatus) {\r\n                    if (textStatus === \"abort\" || textStatus === \"parsererror\") {\r\n                        // The parsererror happens for sends that don't return any data, and hence\r\n                        // don't write the jsonp callback to the response. This is harder to fix on the server\r\n                        // so just hack around it on the client for now.\r\n                        return;\r\n                    }\r\n\r\n                    onFail(_error3, connection);\r\n                }\r\n            });\r\n\r\n            return xhr;\r\n        },\r\n\r\n        ajaxAbort: function ajaxAbort(connection, async) {\r\n            if (typeof connection.transport === \"undefined\") {\r\n                return;\r\n            }\r\n\r\n            // Async by default unless explicitly overidden\r\n            async = typeof async === \"undefined\" ? true : async;\r\n\r\n            var url = getAjaxUrl(connection, \"/abort\");\r\n\r\n            transportLogic.ajax(connection, {\r\n                url: url,\r\n                async: async,\r\n                timeout: 1000,\r\n                type: \"POST\"\r\n            });\r\n\r\n            connection.log(\"Fired ajax abort async = \" + async + \".\");\r\n        },\r\n\r\n        ajaxStart: function ajaxStart(connection, onSuccess) {\r\n            var rejectDeferred = function rejectDeferred(error) {\r\n                var deferred = connection._deferral;\r\n                if (deferred) {\r\n                    deferred.reject(error);\r\n                }\r\n            },\r\n                triggerStartError = function triggerStartError(error) {\r\n                connection.log(\"The start request failed. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n                rejectDeferred(error);\r\n                connection.stop();\r\n            };\r\n\r\n            connection._.startRequest = transportLogic.ajax(connection, {\r\n                url: getAjaxUrl(connection, \"/start\"),\r\n                success: function success(result, statusText, xhr) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.errorParsingStartResponse, result), error, xhr));\r\n                        return;\r\n                    }\r\n\r\n                    if (data.Response === \"started\") {\r\n                        onSuccess();\r\n                    } else {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.invalidStartResponse, result), null /* error */, xhr));\r\n                    }\r\n                },\r\n                error: function error(xhr, statusText, _error4) {\r\n                    if (statusText !== startAbortText) {\r\n                        triggerStartError(signalR._.error(signalR.resources.errorDuringStartRequest, _error4, xhr));\r\n                    } else {\r\n                        // Stop has been called, no need to trigger the error handler\r\n                        // or stop the connection again with onStartError\r\n                        connection.log(\"The start request aborted because connection.stop() was called.\");\r\n                        rejectDeferred(signalR._.error(signalR.resources.stoppedDuringStartRequest, null /* error */, xhr));\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        tryAbortStartRequest: function tryAbortStartRequest(connection) {\r\n            if (connection._.startRequest) {\r\n                // If the start request has already completed this will noop.\r\n                connection._.startRequest.abort(startAbortText);\r\n                delete connection._.startRequest;\r\n            }\r\n        },\r\n\r\n        tryInitialize: function tryInitialize(connection, persistentResponse, onInitialized) {\r\n            if (persistentResponse.Initialized && onInitialized) {\r\n                onInitialized();\r\n            } else if (persistentResponse.Initialized) {\r\n                connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n            }\r\n        },\r\n\r\n        triggerReceived: function triggerReceived(connection, data) {\r\n            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {\r\n                $(connection).triggerHandler(events.onReceived, [data]);\r\n            }\r\n        },\r\n\r\n        processMessages: function processMessages(connection, minData, onInitialized) {\r\n            var data;\r\n\r\n            // Update the last message time stamp\r\n            transportLogic.markLastMessage(connection);\r\n\r\n            if (minData) {\r\n                data = transportLogic.maximizePersistentResponse(minData);\r\n\r\n                transportLogic.updateGroups(connection, data.GroupsToken);\r\n\r\n                if (data.MessageId) {\r\n                    connection.messageId = data.MessageId;\r\n                }\r\n\r\n                if (data.Messages) {\r\n                    $.each(data.Messages, function (index, message) {\r\n                        transportLogic.triggerReceived(connection, message);\r\n                    });\r\n\r\n                    transportLogic.tryInitialize(connection, data, onInitialized);\r\n                }\r\n            }\r\n        },\r\n\r\n        monitorKeepAlive: function monitorKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // If we haven't initiated the keep alive timeouts then we need to\r\n            if (!keepAliveData.monitoring) {\r\n                keepAliveData.monitoring = true;\r\n\r\n                transportLogic.markLastMessage(connection);\r\n\r\n                // Save the function so we can unbind it on stop\r\n                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {\r\n                    // Mark a new message so that keep alive doesn't time out connections\r\n                    transportLogic.markLastMessage(connection);\r\n                };\r\n\r\n                // Update Keep alive on reconnect\r\n                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                connection.log(\"Now monitoring keep alive with a warning timeout of \" + keepAliveData.timeoutWarning + \", keep alive timeout of \" + keepAliveData.timeout + \" and disconnecting timeout of \" + connection.disconnectTimeout);\r\n            } else {\r\n                connection.log(\"Tried to monitor keep alive but it's already being monitored.\");\r\n            }\r\n        },\r\n\r\n        stopMonitoringKeepAlive: function stopMonitoringKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // Only attempt to stop the keep alive monitoring if its being monitored\r\n            if (keepAliveData.monitoring) {\r\n                // Stop monitoring\r\n                keepAliveData.monitoring = false;\r\n\r\n                // Remove the updateKeepAlive function from the reconnect event\r\n                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                // Clear all the keep alive data\r\n                connection._.keepAliveData = {};\r\n                connection.log(\"Stopping the monitoring of the keep alive.\");\r\n            }\r\n        },\r\n\r\n        startHeartbeat: function startHeartbeat(connection) {\r\n            connection._.lastActiveAt = new Date().getTime();\r\n            beat(connection);\r\n        },\r\n\r\n        markLastMessage: function markLastMessage(connection) {\r\n            connection._.lastMessageAt = new Date().getTime();\r\n        },\r\n\r\n        markActive: function markActive(connection) {\r\n            if (transportLogic.verifyLastActive(connection)) {\r\n                connection._.lastActiveAt = new Date().getTime();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isConnectedOrReconnecting: function isConnectedOrReconnecting(connection) {\r\n            return connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        ensureReconnectingState: function ensureReconnectingState(connection) {\r\n            if (changeState(connection, signalR.connectionState.connected, signalR.connectionState.reconnecting) === true) {\r\n                $(connection).triggerHandler(events.onReconnecting);\r\n            }\r\n            return connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        clearReconnectTimeout: function clearReconnectTimeout(connection) {\r\n            if (connection && connection._.reconnectTimeout) {\r\n                window.clearTimeout(connection._.reconnectTimeout);\r\n                delete connection._.reconnectTimeout;\r\n            }\r\n        },\r\n\r\n        verifyLastActive: function verifyLastActive(connection) {\r\n            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {\r\n                var message = signalR._.format(signalR.resources.reconnectWindowTimeout, new Date(connection._.lastActiveAt), connection.reconnectWindow);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        reconnect: function reconnect(connection, transportName) {\r\n            var transport = signalR.transports[transportName];\r\n\r\n            // We should only set a reconnectTimeout if we are currently connected\r\n            // and a reconnectTimeout isn't already set.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {\r\n                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n                if (!transportLogic.verifyLastActive(connection)) {\r\n                    return;\r\n                }\r\n\r\n                connection._.reconnectTimeout = window.setTimeout(function () {\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    transport.stop(connection);\r\n\r\n                    if (transportLogic.ensureReconnectingState(connection)) {\r\n                        connection.log(transportName + \" reconnecting.\");\r\n                        transport.start(connection);\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        handleParseFailure: function handleParseFailure(connection, result, error, onFailed, context) {\r\n            var wrappedError = signalR._.transportError(signalR._.format(signalR.resources.parseFailed, result), connection.transport, error, context);\r\n\r\n            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.\r\n            if (onFailed && onFailed(wrappedError)) {\r\n                connection.log(\"Failed to parse server response while attempting to connect.\");\r\n            } else {\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                connection.stop();\r\n            }\r\n        },\r\n\r\n        initHandler: function initHandler(connection) {\r\n            return new InitHandler(connection);\r\n        },\r\n\r\n        foreverFrame: {\r\n            count: 0,\r\n            connections: {}\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.webSockets.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.webSockets = {\r\n        name: \"webSockets\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data);\r\n\r\n            try {\r\n                connection.socket.send(payload);\r\n            } catch (ex) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.webSocketsInvalidState, connection.transport, ex, connection.socket), data]);\r\n            }\r\n        },\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var url,\r\n                opened = false,\r\n                that = this,\r\n                reconnecting = !onSuccess,\r\n                $connection = $(connection);\r\n\r\n            if (!window.WebSocket) {\r\n                onFailed();\r\n                return;\r\n            }\r\n\r\n            if (!connection.socket) {\r\n                if (connection.webSocketServerUrl) {\r\n                    url = connection.webSocketServerUrl;\r\n                } else {\r\n                    url = connection.wsProtocol + connection.host;\r\n                }\r\n\r\n                url += transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n                connection.log(\"Connecting to websocket endpoint '\" + url + \"'.\");\r\n                connection.socket = new window.WebSocket(url);\r\n\r\n                connection.socket.onopen = function () {\r\n                    opened = true;\r\n                    connection.log(\"Websocket opened.\");\r\n\r\n                    transportLogic.clearReconnectTimeout(connection);\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                };\r\n\r\n                connection.socket.onclose = function (event) {\r\n                    var error;\r\n\r\n                    // Only handle a socket close if the close is from the current socket.\r\n                    // Sometimes on disconnect the server will push down an onclose event\r\n                    // to an expired socket.\r\n\r\n                    if (this === connection.socket) {\r\n                        if (opened && typeof event.wasClean !== \"undefined\" && event.wasClean === false) {\r\n                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but\r\n                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.\r\n                            error = signalR._.transportError(signalR.resources.webSocketClosed, connection.transport, event);\r\n\r\n                            connection.log(\"Unclean disconnect from websocket: \" + (event.reason || \"[no reason given].\"));\r\n                        } else {\r\n                            connection.log(\"Websocket closed.\");\r\n                        }\r\n\r\n                        if (!onFailed || !onFailed(error)) {\r\n                            if (error) {\r\n                                $(connection).triggerHandler(events.onError, [error]);\r\n                            }\r\n\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                connection.socket.onmessage = function (event) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(event.data);\r\n                    } catch (error) {\r\n                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);\r\n                        return;\r\n                    }\r\n\r\n                    if (data) {\r\n                        // data.M is PersistentResponse.Messages\r\n                        if ($.isEmptyObject(data) || data.M) {\r\n                            transportLogic.processMessages(connection, data, onSuccess);\r\n                        } else {\r\n                            // For websockets we need to trigger onReceived\r\n                            // for callbacks to outgoing hub calls.\r\n                            transportLogic.triggerReceived(connection, data);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection.socket) {\r\n                connection.log(\"Closing the Websocket.\");\r\n                connection.socket.close();\r\n                connection.socket = null;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.serverSentEvents.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        clearReconnectAttemptTimeout = function clearReconnectAttemptTimeout(connection) {\r\n        window.clearTimeout(connection._.reconnectAttemptTimeoutHandle);\r\n        delete connection._.reconnectAttemptTimeoutHandle;\r\n    };\r\n\r\n    signalR.transports.serverSentEvents = {\r\n        name: \"serverSentEvents\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        timeOut: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                opened = false,\r\n                $connection = $(connection),\r\n                reconnecting = !onSuccess,\r\n                url;\r\n\r\n            if (connection.eventSource) {\r\n                connection.log(\"The connection already has an event source. Stopping it.\");\r\n                connection.stop();\r\n            }\r\n\r\n            if (!window.EventSource) {\r\n                if (onFailed) {\r\n                    connection.log(\"This browser doesn't support SSE.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            url = transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n            try {\r\n                connection.log(\"Attempting to connect to SSE endpoint '\" + url + \"'.\");\r\n                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });\r\n            } catch (e) {\r\n                connection.log(\"EventSource failed trying to connect with error \" + e.Message + \".\");\r\n                if (onFailed) {\r\n                    // The connection failed, call the failed callback\r\n                    onFailed();\r\n                } else {\r\n                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);\r\n                    if (reconnecting) {\r\n                        // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                        that.reconnect(connection);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (reconnecting) {\r\n                connection._.reconnectAttemptTimeoutHandle = window.setTimeout(function () {\r\n                    if (opened === false) {\r\n                        // If we're reconnecting and the event source is attempting to connect,\r\n                        // don't keep retrying. This causes duplicate connections to spawn.\r\n                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {\r\n                            // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                }, that.timeOut);\r\n            }\r\n\r\n            connection.eventSource.addEventListener(\"open\", function (e) {\r\n                connection.log(\"EventSource connected.\");\r\n\r\n                clearReconnectAttemptTimeout(connection);\r\n                transportLogic.clearReconnectTimeout(connection);\r\n\r\n                if (opened === false) {\r\n                    opened = true;\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                }\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"message\", function (e) {\r\n                var res;\r\n\r\n                // process messages\r\n                if (e.data === \"initialized\") {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    res = connection._parseResponse(e.data);\r\n                } catch (error) {\r\n                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.processMessages(connection, res, onSuccess);\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"error\", function (e) {\r\n                var error = signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e);\r\n\r\n                // Only handle an error if the error is from the current Event Source.\r\n                // Sometimes on disconnect the server will push down an error event\r\n                // to an expired Event Source.\r\n                if (this !== connection.eventSource) {\r\n                    return;\r\n                }\r\n\r\n                if (onFailed && onFailed(error)) {\r\n                    return;\r\n                }\r\n\r\n                connection.log(\"EventSource readyState: \" + connection.eventSource.readyState + \".\");\r\n\r\n                if (e.eventPhase === window.EventSource.CLOSED) {\r\n                    // We don't use the EventSource's native reconnect function as it\r\n                    // doesn't allow us to change the URL when reconnecting. We need\r\n                    // to change the URL to not include the /connect suffix, and pass\r\n                    // the last message id we received.\r\n                    connection.log(\"EventSource reconnecting due to the server connection ending.\");\r\n                    that.reconnect(connection);\r\n                } else {\r\n                    // connection error\r\n                    connection.log(\"EventSource error.\");\r\n                    $connection.triggerHandler(events.onError, [error]);\r\n                }\r\n            }, false);\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            clearReconnectAttemptTimeout(connection);\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection && connection.eventSource) {\r\n                connection.log(\"EventSource calling close().\");\r\n                connection.eventSource.close();\r\n                connection.eventSource = null;\r\n                delete connection.eventSource;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.foreverFrame.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        createFrame = function createFrame() {\r\n        var frame = window.document.createElement(\"iframe\");\r\n        frame.setAttribute(\"style\", \"position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;\");\r\n        return frame;\r\n    },\r\n\r\n    // Used to prevent infinite loading icon spins in older versions of ie\r\n    // We build this object inside a closure so we don't pollute the rest of\r\n    // the foreverFrame transport with unnecessary functions/utilities.\r\n    loadPreventer = function () {\r\n        var loadingFixIntervalId = null,\r\n            loadingFixInterval = 1000,\r\n            attachedTo = 0;\r\n\r\n        return {\r\n            prevent: function prevent() {\r\n                // Prevent additional iframe removal procedures from newer browsers\r\n                if (signalR._.ieVersion <= 8) {\r\n                    // We only ever want to set the interval one time, so on the first attachedTo\r\n                    if (attachedTo === 0) {\r\n                        // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky\r\n                        loadingFixIntervalId = window.setInterval(function () {\r\n                            var tempFrame = createFrame();\r\n\r\n                            window.document.body.appendChild(tempFrame);\r\n                            window.document.body.removeChild(tempFrame);\r\n\r\n                            tempFrame = null;\r\n                        }, loadingFixInterval);\r\n                    }\r\n\r\n                    attachedTo++;\r\n                }\r\n            },\r\n            cancel: function cancel() {\r\n                // Only clear the interval if there's only one more object that the loadPreventer is attachedTo\r\n                if (attachedTo === 1) {\r\n                    window.clearInterval(loadingFixIntervalId);\r\n                }\r\n\r\n                if (attachedTo > 0) {\r\n                    attachedTo--;\r\n                }\r\n            }\r\n        };\r\n    }();\r\n\r\n    signalR.transports.foreverFrame = {\r\n        name: \"foreverFrame\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        // Added as a value here so we can create tests to verify functionality\r\n        iframeClearThreshold: 50,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                frameId = transportLogic.foreverFrame.count += 1,\r\n                url,\r\n                frame = createFrame(),\r\n                frameLoadHandler = function frameLoadHandler() {\r\n                connection.log(\"Forever frame iframe finished loading and is no longer receiving messages.\");\r\n                if (!onFailed || !onFailed()) {\r\n                    that.reconnect(connection);\r\n                }\r\n            };\r\n\r\n            if (window.EventSource) {\r\n                // If the browser supports SSE, don't use Forever Frame\r\n                if (onFailed) {\r\n                    connection.log(\"Forever Frame is not supported by SignalR on browsers with SSE support.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            frame.setAttribute(\"data-signalr-connection-id\", connection.id);\r\n\r\n            // Start preventing loading icon\r\n            // This will only perform work if the loadPreventer is not attached to another connection.\r\n            loadPreventer.prevent();\r\n\r\n            // Build the url\r\n            url = transportLogic.getUrl(connection, this.name);\r\n            url += \"&frameId=\" + frameId;\r\n\r\n            // add frame to the document prior to setting URL to avoid caching issues.\r\n            window.document.documentElement.appendChild(frame);\r\n\r\n            connection.log(\"Binding to iframe's load event.\");\r\n\r\n            if (frame.addEventListener) {\r\n                frame.addEventListener(\"load\", frameLoadHandler, false);\r\n            } else if (frame.attachEvent) {\r\n                frame.attachEvent(\"onload\", frameLoadHandler);\r\n            }\r\n\r\n            frame.src = url;\r\n            transportLogic.foreverFrame.connections[frameId] = connection;\r\n\r\n            connection.frame = frame;\r\n            connection.frameId = frameId;\r\n\r\n            if (onSuccess) {\r\n                connection.onSuccess = function () {\r\n                    connection.log(\"Iframe transport started.\");\r\n                    onSuccess();\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            var that = this;\r\n\r\n            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {\r\n                window.setTimeout(function () {\r\n                    // Verify that we're ok to reconnect.\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {\r\n                        var frame = connection.frame,\r\n                            src = transportLogic.getUrl(connection, that.name, true) + \"&frameId=\" + connection.frameId;\r\n                        connection.log(\"Updating iframe src to '\" + src + \"'.\");\r\n                        frame.src = src;\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        receive: function receive(connection, data) {\r\n            var cw, body, response;\r\n\r\n            if (connection.json !== connection._originalJson) {\r\n                // If there's a custom JSON parser configured then serialize the object\r\n                // using the original (browser) JSON parser and then deserialize it using\r\n                // the custom parser (connection._parseResponse does that). This is so we\r\n                // can easily send the response from the server as \"raw\" JSON but still\r\n                // support custom JSON deserialization in the browser.\r\n                data = connection._originalJson.stringify(data);\r\n            }\r\n\r\n            response = connection._parseResponse(data);\r\n\r\n            transportLogic.processMessages(connection, response, connection.onSuccess);\r\n\r\n            // Protect against connection stopping from a callback trigger within the processMessages above.\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                // Delete the script & div elements\r\n                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;\r\n                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {\r\n                    connection.frameMessageCount = 0;\r\n                    cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                    if (cw && cw.document && cw.document.body) {\r\n                        body = cw.document.body;\r\n\r\n                        // Remove all the child elements from the iframe's body to conserver memory\r\n                        while (body.firstChild) {\r\n                            body.removeChild(body.firstChild);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            var cw = null;\r\n\r\n            // Stop attempting to prevent loading icon\r\n            loadPreventer.cancel();\r\n\r\n            if (connection.frame) {\r\n                if (connection.frame.stop) {\r\n                    connection.frame.stop();\r\n                } else {\r\n                    try {\r\n                        cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                        if (cw.document && cw.document.execCommand) {\r\n                            cw.document.execCommand(\"Stop\");\r\n                        }\r\n                    } catch (e) {\r\n                        connection.log(\"Error occurred when stopping foreverFrame transport. Message = \" + e.message + \".\");\r\n                    }\r\n                }\r\n\r\n                // Ensure the iframe is where we left it\r\n                if (connection.frame.parentNode === window.document.body) {\r\n                    window.document.body.removeChild(connection.frame);\r\n                }\r\n\r\n                delete transportLogic.foreverFrame.connections[connection.frameId];\r\n                connection.frame = null;\r\n                connection.frameId = null;\r\n                delete connection.frame;\r\n                delete connection.frameId;\r\n                delete connection.onSuccess;\r\n                delete connection.frameMessageCount;\r\n                connection.log(\"Stopping forever frame.\");\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        },\r\n\r\n        getConnection: function getConnection(id) {\r\n            return transportLogic.foreverFrame.connections[id];\r\n        },\r\n\r\n        started: function started(connection) {\r\n            if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n\r\n                $(connection).triggerHandler(events.onReconnect);\r\n            }\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.longPolling.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        isDisconnecting = $.signalR.isDisconnecting,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.longPolling = {\r\n        name: \"longPolling\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return false;\r\n        },\r\n\r\n        reconnectDelay: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            /// <summary>Starts the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to start</param>\r\n            var that = this,\r\n                _fireConnect = function fireConnect() {\r\n                _fireConnect = $.noop;\r\n\r\n                connection.log(\"LongPolling connected.\");\r\n\r\n                if (onSuccess) {\r\n                    onSuccess();\r\n                } else {\r\n                    connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n                }\r\n            },\r\n                tryFailConnect = function tryFailConnect(error) {\r\n                if (onFailed(error)) {\r\n                    connection.log(\"LongPolling failed to connect.\");\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            },\r\n                privateData = connection._,\r\n                reconnectErrors = 0,\r\n                fireReconnected = function fireReconnected(instance) {\r\n                window.clearTimeout(privateData.reconnectTimeoutId);\r\n                privateData.reconnectTimeoutId = null;\r\n\r\n                if (changeState(instance, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                    // Successfully reconnected!\r\n                    instance.log(\"Raising the reconnect event\");\r\n                    $(instance).triggerHandler(events.onReconnect);\r\n                }\r\n            },\r\n\r\n            // 1 hour\r\n            maxFireReconnectedTimeout = 3600000;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.log(\"Polling xhr requests already exists, aborting.\");\r\n                connection.stop();\r\n            }\r\n\r\n            connection.messageId = null;\r\n\r\n            privateData.reconnectTimeoutId = null;\r\n\r\n            privateData.pollTimeoutId = window.setTimeout(function () {\r\n                (function poll(instance, raiseReconnect) {\r\n                    var messageId = instance.messageId,\r\n                        connect = messageId === null,\r\n                        reconnecting = !connect,\r\n                        polling = !raiseReconnect,\r\n                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling, true /* use Post for longPolling */),\r\n                        postData = {};\r\n\r\n                    if (instance.messageId) {\r\n                        postData.messageId = instance.messageId;\r\n                    }\r\n\r\n                    if (instance.groupsToken) {\r\n                        postData.groupsToken = instance.groupsToken;\r\n                    }\r\n\r\n                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.\r\n                    if (isDisconnecting(instance) === true) {\r\n                        return;\r\n                    }\r\n\r\n                    connection.log(\"Opening long polling request to '\" + url + \"'.\");\r\n                    instance.pollXhr = transportLogic.ajax(connection, {\r\n                        xhrFields: {\r\n                            onprogress: function onprogress() {\r\n                                transportLogic.markLastMessage(connection);\r\n                            }\r\n                        },\r\n                        url: url,\r\n                        type: \"POST\",\r\n                        contentType: signalR._.defaultContentType,\r\n                        data: postData,\r\n                        timeout: connection._.pollTimeout,\r\n                        success: function success(result) {\r\n                            var minData,\r\n                                delay = 0,\r\n                                data,\r\n                                shouldReconnect;\r\n\r\n                            connection.log(\"Long poll complete.\");\r\n\r\n                            // Reset our reconnect errors so if we transition into a reconnecting state again we trigger\r\n                            // reconnected quickly\r\n                            reconnectErrors = 0;\r\n\r\n                            try {\r\n                                // Remove any keep-alives from the beginning of the result\r\n                                minData = connection._parseResponse(result);\r\n                            } catch (error) {\r\n                                transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);\r\n                                return;\r\n                            }\r\n\r\n                            // If there's currently a timeout to trigger reconnect, fire it now before processing messages\r\n                            if (privateData.reconnectTimeoutId !== null) {\r\n                                fireReconnected(instance);\r\n                            }\r\n\r\n                            if (minData) {\r\n                                data = transportLogic.maximizePersistentResponse(minData);\r\n                            }\r\n\r\n                            transportLogic.processMessages(instance, minData, _fireConnect);\r\n\r\n                            if (data && $.type(data.LongPollDelay) === \"number\") {\r\n                                delay = data.LongPollDelay;\r\n                            }\r\n\r\n                            if (isDisconnecting(instance) === true) {\r\n                                return;\r\n                            }\r\n\r\n                            shouldReconnect = data && data.ShouldReconnect;\r\n                            if (shouldReconnect) {\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function\r\n                            if (delay > 0) {\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, shouldReconnect);\r\n                                }, delay);\r\n                            } else {\r\n                                poll(instance, shouldReconnect);\r\n                            }\r\n                        },\r\n\r\n                        error: function error(data, textStatus) {\r\n                            var error = signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr);\r\n\r\n                            // Stop trying to trigger reconnect, connection is in an error state\r\n                            // If we're not in the reconnect state this will noop\r\n                            window.clearTimeout(privateData.reconnectTimeoutId);\r\n                            privateData.reconnectTimeoutId = null;\r\n\r\n                            if (textStatus === \"abort\") {\r\n                                connection.log(\"Aborted xhr request.\");\r\n                                return;\r\n                            }\r\n\r\n                            if (!tryFailConnect(error)) {\r\n\r\n                                // Increment our reconnect errors, we assume all errors to be reconnect errors\r\n                                // In the case that it's our first error this will cause Reconnect to be fired\r\n                                // after 1 second due to reconnectErrors being = 1.\r\n                                reconnectErrors++;\r\n\r\n                                if (connection.state !== signalR.connectionState.reconnecting) {\r\n                                    connection.log(\"An error occurred using longPolling. Status = \" + textStatus + \".  Response = \" + data.responseText + \".\");\r\n                                    $(instance).triggerHandler(events.onError, [error]);\r\n                                }\r\n\r\n                                // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.\r\n                                // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.\r\n                                // Therefore we don't want to change that failure code path.\r\n                                if ((connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting) && !transportLogic.verifyLastActive(connection)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Call poll with the raiseReconnect flag as true after the reconnect delay\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, true);\r\n                                }, that.reconnectDelay);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // This will only ever pass after an error has occurred via the poll ajax procedure.\r\n                    if (reconnecting && raiseReconnect === true) {\r\n                        // We wait to reconnect depending on how many times we've failed to reconnect.\r\n                        // This is essentially a heuristic that will exponentially increase in wait time before\r\n                        // triggering reconnected.  This depends on the \"error\" handler of Poll to cancel this\r\n                        // timeout if it triggers before the Reconnected event fires.\r\n                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.\r\n                        privateData.reconnectTimeoutId = window.setTimeout(function () {\r\n                            fireReconnected(instance);\r\n                        }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));\r\n                    }\r\n                })(connection);\r\n            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort(\"lostConnection\");\r\n            }\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            /// <summary>Stops the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to stop</param>\r\n\r\n            window.clearTimeout(connection._.pollTimeoutId);\r\n            window.clearTimeout(connection._.reconnectTimeoutId);\r\n\r\n            delete connection._.pollTimeoutId;\r\n            delete connection._.reconnectTimeoutId;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort();\r\n                connection.pollXhr = null;\r\n                delete connection.pollXhr;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.hubs.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var eventNamespace = \".hubProxy\",\r\n        signalR = $.signalR;\r\n\r\n    function makeEventName(event) {\r\n        return event + eventNamespace;\r\n    }\r\n\r\n    // Equivalent to Array.prototype.map\r\n    function map(arr, fun, thisp) {\r\n        var i,\r\n            length = arr.length,\r\n            result = [];\r\n        for (i = 0; i < length; i += 1) {\r\n            if (arr.hasOwnProperty(i)) {\r\n                result[i] = fun.call(thisp, arr[i], i, arr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getArgValue(a) {\r\n        return $.isFunction(a) ? null : $.type(a) === \"undefined\" ? null : a;\r\n    }\r\n\r\n    function hasMembers(obj) {\r\n        for (var key in obj) {\r\n            // If we have any properties in our callback map then we have callbacks and can exit the loop via return\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function clearInvocationCallbacks(connection, error) {\r\n        /// <param name=\"connection\" type=\"hubConnection\" />\r\n        var callbacks = connection._.invocationCallbacks,\r\n            callback;\r\n\r\n        if (hasMembers(callbacks)) {\r\n            connection.log(\"Clearing hub invocation callbacks with error: \" + error + \".\");\r\n        }\r\n\r\n        // Reset the callback cache now as we have a local var referencing it\r\n        connection._.invocationCallbackId = 0;\r\n        delete connection._.invocationCallbacks;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Loop over the callbacks and invoke them.\r\n        // We do this using a local var reference and *after* we've cleared the cache\r\n        // so that if a fail callback itself tries to invoke another method we don't\r\n        // end up with its callback in the list we're looping over.\r\n        for (var callbackId in callbacks) {\r\n            callback = callbacks[callbackId];\r\n            callback.method.call(callback.scope, { E: error });\r\n        }\r\n    }\r\n\r\n    // hubProxy\r\n    function hubProxy(hubConnection, hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        return new hubProxy.fn.init(hubConnection, hubName);\r\n    }\r\n\r\n    hubProxy.fn = hubProxy.prototype = {\r\n        init: function init(connection, hubName) {\r\n            this.state = {};\r\n            this.connection = connection;\r\n            this.hubName = hubName;\r\n            this._ = {\r\n                callbackMap: {}\r\n            };\r\n        },\r\n\r\n        constructor: hubProxy,\r\n\r\n        hasSubscriptions: function hasSubscriptions() {\r\n            return hasMembers(this._.callbackMap);\r\n        },\r\n\r\n        on: function on(eventName, callback) {\r\n            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to register the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            // If there is not an event registered for this callback yet we want to create its event space in the callback map.\r\n            if (!callbackMap[eventName]) {\r\n                callbackMap[eventName] = {};\r\n            }\r\n\r\n            // Map the callback to our encompassed function\r\n            callbackMap[eventName][callback] = function (e, data) {\r\n                callback.apply(that, data);\r\n            };\r\n\r\n            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);\r\n\r\n            return that;\r\n        },\r\n\r\n        off: function off(eventName, callback) {\r\n            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to unregister the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                callbackSpace;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            callbackSpace = callbackMap[eventName];\r\n\r\n            // Verify that there is an event space to unbind\r\n            if (callbackSpace) {\r\n                // Only unbind if there's an event bound with eventName and a callback with the specified callback\r\n                if (callbackSpace[callback]) {\r\n                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);\r\n\r\n                    // Remove the callback from the callback map\r\n                    delete callbackSpace[callback];\r\n\r\n                    // Check if there are any members left on the event, if not we need to destroy it.\r\n                    if (!hasMembers(callbackSpace)) {\r\n                        delete callbackMap[eventName];\r\n                    }\r\n                } else if (!callback) {\r\n                    // Check if we're removing the whole event and we didn't error because of an invalid callback\r\n                    $(that).unbind(makeEventName(eventName));\r\n\r\n                    delete callbackMap[eventName];\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        invoke: function invoke(methodName) {\r\n            /// <summary>Invokes a server hub method with the given arguments.</summary>\r\n            /// <param name=\"methodName\" type=\"String\">The name of the server hub method.</param>\r\n\r\n            var that = this,\r\n                connection = that.connection,\r\n                args = $.makeArray(arguments).slice(1),\r\n                argValues = map(args, getArgValue),\r\n                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },\r\n                d = $.Deferred(),\r\n                callback = function callback(minResult) {\r\n                var result = that._maximizeHubResponse(minResult),\r\n                    source,\r\n                    error;\r\n\r\n                // Update the hub state\r\n                $.extend(that.state, result.State);\r\n\r\n                if (result.Progress) {\r\n                    if (d.notifyWith) {\r\n                        // Progress is only supported in jQuery 1.7+\r\n                        d.notifyWith(that, [result.Progress.Data]);\r\n                    } else if (!connection._.progressjQueryVersionLogged) {\r\n                        connection.log(\"A hub method invocation progress update was received but the version of jQuery in use (\" + $.prototype.jquery + \") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications.\");\r\n                        connection._.progressjQueryVersionLogged = true;\r\n                    }\r\n                } else if (result.Error) {\r\n                    // Server hub method threw an exception, log it & reject the deferred\r\n                    if (result.StackTrace) {\r\n                        connection.log(result.Error + \"\\n\" + result.StackTrace + \".\");\r\n                    }\r\n\r\n                    // result.ErrorData is only set if a HubException was thrown\r\n                    source = result.IsHubException ? \"HubException\" : \"Exception\";\r\n                    error = signalR._.error(result.Error, source);\r\n                    error.data = result.ErrorData;\r\n\r\n                    connection.log(that.hubName + \".\" + methodName + \" failed to execute. Error: \" + error.message);\r\n                    d.rejectWith(that, [error]);\r\n                } else {\r\n                    // Server invocation succeeded, resolve the deferred\r\n                    connection.log(\"Invoked \" + that.hubName + \".\" + methodName);\r\n                    d.resolveWith(that, [result.Result]);\r\n                }\r\n            };\r\n\r\n            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };\r\n            connection._.invocationCallbackId += 1;\r\n\r\n            if (!$.isEmptyObject(that.state)) {\r\n                data.S = that.state;\r\n            }\r\n\r\n            connection.log(\"Invoking \" + that.hubName + \".\" + methodName);\r\n            connection.send(data);\r\n\r\n            return d.promise();\r\n        },\r\n\r\n        _maximizeHubResponse: function _maximizeHubResponse(minHubResponse) {\r\n            return {\r\n                State: minHubResponse.S,\r\n                Result: minHubResponse.R,\r\n                Progress: minHubResponse.P ? {\r\n                    Id: minHubResponse.P.I,\r\n                    Data: minHubResponse.P.D\r\n                } : null,\r\n                Id: minHubResponse.I,\r\n                IsHubException: minHubResponse.H,\r\n                Error: minHubResponse.E,\r\n                StackTrace: minHubResponse.T,\r\n                ErrorData: minHubResponse.D\r\n            };\r\n        }\r\n    };\r\n\r\n    hubProxy.fn.init.prototype = hubProxy.fn;\r\n\r\n    // hubConnection\r\n    function hubConnection(url, options) {\r\n        /// <summary>Creates a new hub connection.</summary>\r\n        /// <param name=\"url\" type=\"String\">[Optional] The hub route url, defaults to \"/signalr\".</param>\r\n        /// <param name=\"options\" type=\"Object\">[Optional] Settings to use when creating the hubConnection.</param>\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        };\r\n\r\n        $.extend(settings, options);\r\n\r\n        if (!url || settings.useDefaultPath) {\r\n            url = (url || \"\") + \"/signalr\";\r\n        }\r\n        return new hubConnection.fn.init(url, settings);\r\n    }\r\n\r\n    hubConnection.fn = hubConnection.prototype = $.connection();\r\n\r\n    hubConnection.fn.init = function (url, options) {\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        },\r\n            connection = this;\r\n\r\n        $.extend(settings, options);\r\n\r\n        // Call the base constructor\r\n        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);\r\n\r\n        // Object to store hub proxies for this connection\r\n        connection.proxies = {};\r\n\r\n        connection._.invocationCallbackId = 0;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Wire up the received handler\r\n        connection.received(function (minData) {\r\n            var data, proxy, dataCallbackId, callback, hubName, eventName;\r\n            if (!minData) {\r\n                return;\r\n            }\r\n\r\n            // We have to handle progress updates first in order to ensure old clients that receive\r\n            // progress updates enter the return value branch and then no-op when they can't find\r\n            // the callback in the map (because the minData.I value will not be a valid callback ID)\r\n            if (typeof minData.P !== \"undefined\") {\r\n                // Process progress notification\r\n                dataCallbackId = minData.P.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else if (typeof minData.I !== \"undefined\") {\r\n                // We received the return value from a server method invocation, look up callback by id and call it\r\n                dataCallbackId = minData.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    // Delete the callback from the proxy\r\n                    connection._.invocationCallbacks[dataCallbackId] = null;\r\n                    delete connection._.invocationCallbacks[dataCallbackId];\r\n\r\n                    // Invoke the callback\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else {\r\n                data = this._maximizeClientHubInvocation(minData);\r\n\r\n                // We received a client invocation request, i.e. broadcast from server hub\r\n                connection.log(\"Triggering client hub event '\" + data.Method + \"' on hub '\" + data.Hub + \"'.\");\r\n\r\n                // Normalize the names to lowercase\r\n                hubName = data.Hub.toLowerCase();\r\n                eventName = data.Method.toLowerCase();\r\n\r\n                // Trigger the local invocation event\r\n                proxy = this.proxies[hubName];\r\n\r\n                // Update the hub state\r\n                $.extend(proxy.state, data.State);\r\n                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);\r\n            }\r\n        });\r\n\r\n        connection.error(function (errData, origData) {\r\n            var callbackId, callback;\r\n\r\n            if (!origData) {\r\n                // No original data passed so this is not a send error\r\n                return;\r\n            }\r\n\r\n            callbackId = origData.I;\r\n            callback = connection._.invocationCallbacks[callbackId];\r\n\r\n            // Verify that there is a callback bound (could have been cleared)\r\n            if (callback) {\r\n                // Delete the callback\r\n                connection._.invocationCallbacks[callbackId] = null;\r\n                delete connection._.invocationCallbacks[callbackId];\r\n\r\n                // Invoke the callback with an error to reject the promise\r\n                callback.method.call(callback.scope, { E: errData });\r\n            }\r\n        });\r\n\r\n        connection.reconnecting(function () {\r\n            if (connection.transport && connection.transport.name === \"webSockets\") {\r\n                clearInvocationCallbacks(connection, \"Connection started reconnecting before invocation result was received.\");\r\n            }\r\n        });\r\n\r\n        connection.disconnected(function () {\r\n            clearInvocationCallbacks(connection, \"Connection was disconnected before invocation result was received.\");\r\n        });\r\n    };\r\n\r\n    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {\r\n        return {\r\n            Hub: minClientHubInvocation.H,\r\n            Method: minClientHubInvocation.M,\r\n            Args: minClientHubInvocation.A,\r\n            State: minClientHubInvocation.S\r\n        };\r\n    };\r\n\r\n    hubConnection.fn._registerSubscribedHubs = function () {\r\n        /// <summary>\r\n        ///     Sets the starting event to loop through the known hubs and register any new hubs\r\n        ///     that have been added to the proxy.\r\n        /// </summary>\r\n        var connection = this;\r\n\r\n        if (!connection._subscribedToHubs) {\r\n            connection._subscribedToHubs = true;\r\n            connection.starting(function () {\r\n                // Set the connection's data object with all the hub proxies with active subscriptions.\r\n                // These proxies will receive notifications from the server.\r\n                var subscribedHubs = [];\r\n\r\n                $.each(connection.proxies, function (key) {\r\n                    if (this.hasSubscriptions()) {\r\n                        subscribedHubs.push({ name: key });\r\n                        connection.log(\"Client subscribed to hub '\" + key + \"'.\");\r\n                    }\r\n                });\r\n\r\n                if (subscribedHubs.length === 0) {\r\n                    connection.log(\"No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.\");\r\n                }\r\n\r\n                connection.data = connection.json.stringify(subscribedHubs);\r\n            });\r\n        }\r\n    };\r\n\r\n    hubConnection.fn.createHubProxy = function (hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        /// <param name=\"hubName\" type=\"String\">\r\n        ///     The name of the hub on the server to create the proxy for.\r\n        /// </param>\r\n\r\n        // Normalize the name to lowercase\r\n        hubName = hubName.toLowerCase();\r\n\r\n        var proxy = this.proxies[hubName];\r\n        if (!proxy) {\r\n            proxy = hubProxy(this, hubName);\r\n            this.proxies[hubName] = proxy;\r\n        }\r\n\r\n        this._registerSubscribedHubs();\r\n\r\n        return proxy;\r\n    };\r\n\r\n    hubConnection.fn.init.prototype = hubConnection.fn;\r\n\r\n    $.hubConnection = hubConnection;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.version.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n(function ($, undefined) {\r\n    $.signalR.version = \"2.2.1\";\r\n})(jQueryShim);\r\n\r\nvar hubConnection = exports.hubConnection = jQueryShim.hubConnection;\r\nvar signalR = exports.signalR = jQueryShim.signalR;\n\n/***/ }),\n\n/***/ 622:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\r\n\r\nvar jQueryDeferred = __webpack_require__(623);\r\nvar jQueryParam = __webpack_require__(627);\r\n\r\nvar jqueryFunction = function jqueryFunction(subject) {\r\n  var events = subject.events || {};\r\n\r\n  if (subject && subject === subject.window) return {\r\n    0: subject,\r\n    load: function load(handler) {\r\n      return subject.addEventListener('load', handler, false);\r\n    },\r\n    bind: function bind(event, handler) {\r\n      return subject.addEventListener(event, handler, false);\r\n    },\r\n    unbind: function unbind(event, handler) {\r\n      return subject.removeEventListener(event, handler, false);\r\n    }\r\n  };\r\n\r\n  return {\r\n    0: subject,\r\n\r\n    unbind: function unbind(event, handler) {\r\n      var handlers = events[event] || [];\r\n\r\n      if (handler) {\r\n        var idx = handlers.indexOf(handler);\r\n        if (idx !== -1) handlers.splice(idx, 1);\r\n      } else handlers = [];\r\n\r\n      events[event] = handlers;\r\n      subject.events = events;\r\n    },\r\n    bind: function bind(event, handler) {\r\n      var current = events[event] || [];\r\n      events[event] = current.concat(handler);\r\n      subject.events = events;\r\n    },\r\n    triggerHandler: function triggerHandler(event, args) {\r\n      var _this = this;\r\n\r\n      var handlers = events[event] || [];\r\n      handlers.forEach(function (fn) {\r\n        if (args && args[0] && args[0].type === undefined) {\r\n          args = [{\r\n            type: event\r\n          }].concat(args || []);\r\n        } else {\r\n          args = args || [];\r\n        }\r\n\r\n        fn.apply(_this, args);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\nvar xhr = function xhr() {\r\n  try {\r\n    return new window.XMLHttpRequest();\r\n  } catch (e) {}\r\n};\r\n\r\nvar ajax = function ajax(options) {\r\n  var request = xhr();\r\n  request.onreadystatechange = function () {\r\n    if (request.readyState !== 4) {\r\n      return;\r\n    }\r\n\r\n    if (request.status === 200 && !request._hasError) {\r\n      options.success && options.success(JSON.parse(request.responseText));\r\n    } else {\r\n      options.error && options.error(request);\r\n    }\r\n  };\r\n\r\n  request.open(options.type, options.url);\r\n  request.setRequestHeader('content-type', options.contentType);\r\n\r\n  request.send(options.data.data && 'data=' + options.data.data);\r\n\r\n  return {\r\n    abort: function abort(reason) {\r\n      return request.abort(reason);\r\n    }\r\n  };\r\n};\r\n\r\nmodule.exports = jQueryDeferred.extend(jqueryFunction, jQueryDeferred, {\r\n  defaultAjaxHeaders: null,\r\n  ajax: ajax,\r\n  inArray: function inArray(arr, item) {\r\n    return arr.indexOf(item) !== -1;\r\n  },\r\n  trim: function trim(str) {\r\n    return str && str.trim();\r\n  },\r\n  isEmptyObject: function isEmptyObject(obj) {\r\n    return !obj || Object.keys(obj).length === 0;\r\n  },\r\n  makeArray: function makeArray(arr) {\r\n    return [].slice.call(arr, 0);\r\n  },\r\n  param: function param(obj) {\r\n    return jQueryParam(obj);\r\n  },\r\n  support: {\r\n    cors: function () {\r\n      var xhrObj = xhr();\r\n      return !!xhrObj && \"withCredentials\" in xhrObj;\r\n    }()\r\n  }\r\n});\n\n/***/ }),\n\n/***/ 623:\n/***/ (function(module, exports, __webpack_require__) {\n\n\nmodule.exports = __webpack_require__(624);\n\n/***/ }),\n\n/***/ 624:\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/*!\n* jquery-deferred\n* Copyright(c) 2011 Hidden <zzdhidden@gmail.com>\n* MIT Licensed\n*/\n\n/**\n* Library version.\n*/\n\nvar jQuery = module.exports = __webpack_require__(625),\n\tcore_slice = Array.prototype.slice;\n\n/**\n* jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/deferred.js\n* Doc: http://api.jquery.com/category/deferred-object/\n*\n*/\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ]( jQuery.isFunction( fn ) ?\n\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\tvar returned = fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} :\n\t\t\t\t\t\t\t\tnewDefer[ action ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ] = list.fire\n\t\t\tdeferred[ tuple[0] ] = list.fire;\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n/***/ }),\n\n/***/ 625:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar jQuery = module.exports = __webpack_require__(626),\n\tcore_rspace = /\\s+/;\n/**\n* jQuery Callbacks\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/callbacks.js\n*\n*/\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.split( core_rspace ), function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Control if a given callback is in the list\n\t\t\thas: function( fn ) {\n\t\t\t\treturn jQuery.inArray( fn, list ) > -1;\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\n\n/***/ }),\n\n/***/ 626:\n/***/ (function(module, exports) {\n\n/**\n* jQuery core object.\n*\n* Worker with jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/core.js\n*\n*/\n\nvar jQuery = module.exports = {\n\ttype: type\n\t, isArray: isArray\n\t, isFunction: isFunction\n\t, isPlainObject: isPlainObject\n\t, each: each\n\t, extend: extend\n\t, noop: function() {}\n};\n\nvar toString = Object.prototype.toString;\n\nvar class2type = {};\n// Populate the class2type map\n\"Boolean Number String Function Array Date RegExp Object\".split(\" \").forEach(function(name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\n\nfunction type( obj ) {\n\treturn obj == null ?\n\t\tString( obj ) :\n\t\t\tclass2type[ toString.call(obj) ] || \"object\";\n}\n\nfunction isFunction( obj ) {\n\treturn jQuery.type(obj) === \"function\";\n}\n\nfunction isArray( obj ) {\n\treturn jQuery.type(obj) === \"array\";\n}\n\nfunction each( object, callback, args ) {\n\tvar name, i = 0,\n\tlength = object.length,\n\tisObj = length === undefined || isFunction( object );\n\n\tif ( args ) {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t} else {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn object;\n}\n\nfunction isPlainObject( obj ) {\n\t// Must be an Object.\n\tif ( !obj || jQuery.type(obj) !== \"object\" ) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\ttarget = arguments[0] || {},\n\ti = 1,\n\tlength = arguments.length,\n\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n/***/ }),\n\n/***/ 627:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT\n */\n(function (global) {\n    'use strict';\n\n    var param = function (a) {\n        var s = [], rbracket = /\\[\\]$/,\n            isArray = function (obj) {\n                return Object.prototype.toString.call(obj) === '[object Array]';\n            }, add = function (k, v) {\n                v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n                s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n            }, buildParams = function (prefix, obj) {\n                var i, len, key;\n\n                if (prefix) {\n                    if (isArray(obj)) {\n                        for (i = 0, len = obj.length; i < len; i++) {\n                            if (rbracket.test(prefix)) {\n                                add(prefix, obj[i]);\n                            } else {\n                                buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i]);\n                            }\n                        }\n                    } else if (obj && String(obj) === '[object Object]') {\n                        for (key in obj) {\n                            buildParams(prefix + '[' + key + ']', obj[key]);\n                        }\n                    } else {\n                        add(prefix, obj);\n                    }\n                } else if (isArray(obj)) {\n                    for (i = 0, len = obj.length; i < len; i++) {\n                        add(obj[i].name, obj[i].value);\n                    }\n                } else {\n                    for (key in obj) {\n                        buildParams(key, obj[key]);\n                    }\n                }\n                return s;\n            };\n\n        return buildParams('', a).join('&').replace(/%20/g, '+');\n    };\n\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = param;\n    } else if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {\n            return param;\n        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {\n        global.param = param;\n    }\n\n}(this));\n\n\n\n/***/ }),\n\n/***/ 628:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__ = __webpack_require__(227);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_odata__ = __webpack_require__(570);\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  namespaced: true,\n  state: {\n    supplier: {},\n    currentApplicant: {}\n  },\n  actions: {\n    GET_SUPPLIER: function GET_SUPPLIER(context) {\n      Object(__WEBPACK_IMPORTED_MODULE_1__api_odata__[\"a\" /* default */])('Suppliers').find(5).expand('Offers($expand=Applications)').get(function (data) {\n        context.commit('SUPPLIER_UPDATED', data);\n      });\n    },\n    SAVE_OFFER: function SAVE_OFFER(_ref, offer) {\n      var commit = _ref.commit;\n\n      Object(__WEBPACK_IMPORTED_MODULE_1__api_odata__[\"a\" /* default */])('Suppliers(5)/Offers').post(offer).save(function (data) {\n        commit('ADD_OFFER', offer);\n      });\n    },\n    GET_OFFER_APPLICATIONS: function GET_OFFER_APPLICATIONS(_ref2, offerId) {\n      var commit = _ref2.commit;\n\n      return new __WEBPACK_IMPORTED_MODULE_0_babel_runtime_core_js_promise___default.a(function (resolve, reject) {\n        Object(__WEBPACK_IMPORTED_MODULE_1__api_odata__[\"a\" /* default */])('Offers(' + offerId + ')/Applications').expand('Applicant($expand=Scores($orderby=Date))').get(function (data) {\n          resolve(data);\n        });\n      });\n    }\n  },\n  getters: {\n    supplier: function supplier(state) {\n      return state.supplier;\n    },\n    offers: function offers(state) {\n      return state.supplier.Offers;\n    }\n  },\n  mutations: {\n    SUPPLIER_UPDATED: function SUPPLIER_UPDATED(state, supplier) {\n      state.supplier = supplier;\n    },\n    ADD_OFFER: function ADD_OFFER(state, offer) {\n      state.supplier.Offers.push(offer);\n    }\n  }\n});\n\n/***/ }),\n\n/***/ 629:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"app\"},[_c('AppHeader'),_vm._v(\" \"),_c('div',{staticClass:\"app-body\"},[_c('Sidebar',{attrs:{\"navItems\":_vm.nav}}),_vm._v(\" \"),_c('main',{staticClass:\"main\"},[_c('div',{staticClass:\"container-fluid\"},[_c('router-view')],1)])],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\n/* harmony default export */ __webpack_exports__[\"a\"] = (esExports);\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/3.96bcd54e618754c46765.js","function injectStyle (ssrContext) {\n  require(\"!!../../../node_modules/extract-text-webpack-plugin/dist/loader.js?{\\\"omit\\\":1,\\\"remove\\\":true}!vue-style-loader!css-loader?{\\\"minimize\\\":true,\\\"sourceMap\\\":true,\\\"alias\\\":{\\\"../img\\\":\\\"../static/img\\\"}}!../../../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-e231a1e4\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector?type=styles&index=0!./index.vue\")\n}\nvar normalizeComponent = require(\"!../../../node_modules/vue-loader/lib/component-normalizer\")\n/* script */\nimport __vue_script__ from \"!!babel-loader!../../../node_modules/vue-loader/lib/selector?type=script&index=0!./index.vue\"\n/* template */\nimport __vue_template__ from \"!!../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-e231a1e4\\\",\\\"hasScoped\\\":true,\\\"buble\\\":{\\\"transforms\\\":{}}}!../../../node_modules/vue-loader/lib/selector?type=template&index=0!./index.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = injectStyle\n/* scopeId */\nvar __vue_scopeId__ = \"data-v-e231a1e4\"\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_template__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/modules/supplier/index.vue\n// module id = 484\n// module chunks = 3","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2017 Kris Kowal under the terms of the MIT\n * license found at https://github.com/kriskowal/q/blob/v1/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    \"use strict\";\n\n    // This file will function properly as a <script> tag, or a module\n    // using CommonJS and NodeJS or RequireJS module formats.  In\n    // Common/Node/RequireJS, the module exports the Q API and when\n    // executed as a simple <script>, it creates a Q global instead.\n\n    // Montage Require\n    if (typeof bootstrap === \"function\") {\n        bootstrap(\"promise\", definition);\n\n    // CommonJS\n    } else if (typeof exports === \"object\" && typeof module === \"object\") {\n        module.exports = definition();\n\n    // RequireJS\n    } else if (typeof define === \"function\" && define.amd) {\n        define(definition);\n\n    // SES (Secure EcmaScript)\n    } else if (typeof ses !== \"undefined\") {\n        if (!ses.ok()) {\n            return;\n        } else {\n            ses.makeQ = definition;\n        }\n\n    // <script>\n    } else if (typeof window !== \"undefined\" || typeof self !== \"undefined\") {\n        // Prefer window over self for add-on scripts. Use self for\n        // non-windowed contexts.\n        var global = typeof window !== \"undefined\" ? window : self;\n\n        // Get the `window` object, save the previous Q global\n        // and initialize Q as a global.\n        var previousQ = global.Q;\n        global.Q = definition();\n\n        // Add a noConflict function so Q can be removed from the\n        // global namespace.\n        global.Q.noConflict = function () {\n            global.Q = previousQ;\n            return this;\n        };\n\n    } else {\n        throw new Error(\"This environment was not anticipated by Q. Please file a bug.\");\n    }\n\n})(function () {\n\"use strict\";\n\nvar hasStacks = false;\ntry {\n    throw new Error();\n} catch (e) {\n    hasStacks = !!e.stack;\n}\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// Use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick =(function () {\n    // linked list of tasks (single, with head node)\n    var head = {task: void 0, next: null};\n    var tail = head;\n    var flushing = false;\n    var requestTick = void 0;\n    var isNodeJS = false;\n    // queue for late tasks, used by unhandled rejection tracking\n    var laterQueue = [];\n\n    function flush() {\n        /* jshint loopfunc: true */\n        var task, domain;\n\n        while (head.next) {\n            head = head.next;\n            task = head.task;\n            head.task = void 0;\n            domain = head.domain;\n\n            if (domain) {\n                head.domain = void 0;\n                domain.enter();\n            }\n            runSingle(task, domain);\n\n        }\n        while (laterQueue.length) {\n            task = laterQueue.pop();\n            runSingle(task);\n        }\n        flushing = false;\n    }\n    // runs a single function in the async queue\n    function runSingle(task, domain) {\n        try {\n            task();\n\n        } catch (e) {\n            if (isNodeJS) {\n                // In node, uncaught exceptions are considered fatal errors.\n                // Re-throw them synchronously to interrupt flushing!\n\n                // Ensure continuation if the uncaught exception is suppressed\n                // listening \"uncaughtException\" events (as domains does).\n                // Continue in next event to avoid tick recursion.\n                if (domain) {\n                    domain.exit();\n                }\n                setTimeout(flush, 0);\n                if (domain) {\n                    domain.enter();\n                }\n\n                throw e;\n\n            } else {\n                // In browsers, uncaught exceptions are not fatal.\n                // Re-throw them asynchronously to avoid slow-downs.\n                setTimeout(function () {\n                    throw e;\n                }, 0);\n            }\n        }\n\n        if (domain) {\n            domain.exit();\n        }\n    }\n\n    nextTick = function (task) {\n        tail = tail.next = {\n            task: task,\n            domain: isNodeJS && process.domain,\n            next: null\n        };\n\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n\n    if (typeof process === \"object\" &&\n        process.toString() === \"[object process]\" && process.nextTick) {\n        // Ensure Q is in a real Node environment, with a `process.nextTick`.\n        // To see through fake Node environments:\n        // * Mocha test runner - exposes a `process` global without a `nextTick`\n        // * Browserify - exposes a `process.nexTick` function that uses\n        //   `setTimeout`. In this case `setImmediate` is preferred because\n        //    it is faster. Browserify's `process.toString()` yields\n        //   \"[object Object]\", while in a real Node environment\n        //   `process.toString()` yields \"[object process]\".\n        isNodeJS = true;\n\n        requestTick = function () {\n            process.nextTick(flush);\n        };\n\n    } else if (typeof setImmediate === \"function\") {\n        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate\n        if (typeof window !== \"undefined\") {\n            requestTick = setImmediate.bind(window, flush);\n        } else {\n            requestTick = function () {\n                setImmediate(flush);\n            };\n        }\n\n    } else if (typeof MessageChannel !== \"undefined\") {\n        // modern browsers\n        // http://www.nonblocking.io/2011/06/windownexttick.html\n        var channel = new MessageChannel();\n        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create\n        // working message ports the first time a page loads.\n        channel.port1.onmessage = function () {\n            requestTick = requestPortTick;\n            channel.port1.onmessage = flush;\n            flush();\n        };\n        var requestPortTick = function () {\n            // Opera requires us to provide a message payload, regardless of\n            // whether we use it.\n            channel.port2.postMessage(0);\n        };\n        requestTick = function () {\n            setTimeout(flush, 0);\n            requestPortTick();\n        };\n\n    } else {\n        // old browsers\n        requestTick = function () {\n            setTimeout(flush, 0);\n        };\n    }\n    // runs a task after all other tasks have been run\n    // this is useful for unhandled rejection tracking that needs to happen\n    // after all `then`d tasks have been run.\n    nextTick.runAfter = function (task) {\n        laterQueue.push(task);\n        if (!flushing) {\n            flushing = true;\n            requestTick();\n        }\n    };\n    return nextTick;\n})();\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this **might** have the nice side-effect of reducing the size of\n// the minified code by reducing x.call() to merely x()\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nvar call = Function.call;\nfunction uncurryThis(f) {\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_defineProperty = Object.defineProperty || function (obj, prop, descriptor) {\n    obj[prop] = descriptor.value;\n    return obj;\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\nfunction isObject(value) {\n    return value === Object(value);\n}\n\n// generator related shims\n\n// FIXME: Remove this function once ES6 generators are in SpiderMonkey.\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\n// FIXME: Remove this helper and Q.return once ES6 generators are in\n// SpiderMonkey.\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible, transform the error stack trace by removing Node and Q\n    // cruft, then concatenating with the stack trace of `promise`. See #57.\n    if (hasStacks &&\n        promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack\n    ) {\n        var stacks = [];\n        for (var p = promise; !!p; p = p.source) {\n            if (p.stack && (!error.__minimumStackCounter__ || error.__minimumStackCounter__ > p.stackCounter)) {\n                object_defineProperty(error, \"__minimumStackCounter__\", {value: p.stackCounter, configurable: true});\n                stacks.unshift(p.stack);\n            }\n        }\n        stacks.unshift(error.stack);\n\n        var concatedStacks = stacks.join(\"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\");\n        var stack = filterStackString(concatedStacks);\n        object_defineProperty(error, \"stack\", {value: stack, configurable: true});\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction getFileNameAndLineNumber(stackLine) {\n    // Named functions: \"at functionName (filename:lineNumber:columnNumber)\"\n    // In IE10 function name can have spaces (\"Anonymous function\") O_o\n    var attempt1 = /at .+ \\((.+):(\\d+):(?:\\d+)\\)$/.exec(stackLine);\n    if (attempt1) {\n        return [attempt1[1], Number(attempt1[2])];\n    }\n\n    // Anonymous functions: \"at filename:lineNumber:columnNumber\"\n    var attempt2 = /at ([^ ]+):(\\d+):(?:\\d+)$/.exec(stackLine);\n    if (attempt2) {\n        return [attempt2[1], Number(attempt2[2])];\n    }\n\n    // Firefox style: \"function@filename:lineNumber or @filename:lineNumber\"\n    var attempt3 = /.*@(.+):(\\d+)$/.exec(stackLine);\n    if (attempt3) {\n        return [attempt3[1], Number(attempt3[2])];\n    }\n}\n\nfunction isInternalFrame(stackLine) {\n    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);\n\n    if (!fileNameAndLineNumber) {\n        return false;\n    }\n\n    var fileName = fileNameAndLineNumber[0];\n    var lineNumber = fileNameAndLineNumber[1];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (!hasStacks) {\n        return;\n    }\n\n    try {\n        throw new Error();\n    } catch (e) {\n        var lines = e.stack.split(\"\\n\");\n        var firstLine = lines[0].indexOf(\"@\") > 0 ? lines[1] : lines[2];\n        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);\n        if (!fileNameAndLineNumber) {\n            return;\n        }\n\n        qFileName = fileNameAndLineNumber[0];\n        return fileNameAndLineNumber[1];\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" &&\n            typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative +\n                         \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nfunction Q(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (value instanceof Promise) {\n        return value;\n    }\n\n    // assimilate thenables\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\nQ.resolve = Q;\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Controls whether or not long stack traces will be on\n */\nQ.longStackSupport = false;\n\n/**\n * The counter is used to determine the stopping point for building\n * long stack traces. In makeStackTraceLong we walk backwards through\n * the linked list of promises, only stacks which were created before\n * the rejection are concatenated.\n */\nvar longStackCounter = 1;\n\n// enable long stacks if Q_DEBUG is set\nif (typeof process === \"object\" && process && process.env && process.env.Q_DEBUG) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Constructs a {promise, resolve, reject} object.\n *\n * `resolve` is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke `resolve` with any value that is\n * not a thenable. To reject the promise, invoke `resolve` with a rejected\n * thenable, or invoke `reject` with the reason directly. To resolve the\n * promise to another thenable, thus putting it in the same state, invoke\n * `resolve` with that other thenable.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"messages\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the messages array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the `resolve` function because it handles both fully\n    // non-thenable values and other thenables gracefully.\n    var messages = [], progressListeners = [], resolvedPromise;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (messages) {\n            messages.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            Q.nextTick(function () {\n                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);\n            });\n        }\n    };\n\n    // XXX deprecated\n    promise.valueOf = function () {\n        if (messages) {\n            return promise;\n        }\n        var nearerValue = nearer(resolvedPromise);\n        if (isPromise(nearerValue)) {\n            resolvedPromise = nearerValue; // shorten chain\n        }\n        return nearerValue;\n    };\n\n    promise.inspect = function () {\n        if (!resolvedPromise) {\n            return { state: \"pending\" };\n        }\n        return resolvedPromise.inspect();\n    };\n\n    if (Q.longStackSupport && hasStacks) {\n        try {\n            throw new Error();\n        } catch (e) {\n            // NOTE: don't try to use `Error.captureStackTrace` or transfer the\n            // accessor around; that causes memory leaks as per GH-111. Just\n            // reify the stack trace as a string ASAP.\n            //\n            // At the same time, cut off the first line; it's always just\n            // \"[object Promise]\\n\", as per the `toString`.\n            promise.stack = e.stack.substring(e.stack.indexOf(\"\\n\") + 1);\n            promise.stackCounter = longStackCounter++;\n        }\n    }\n\n    // NOTE: we do the checks for `resolvedPromise` in each method, instead of\n    // consolidating them into `become`, since otherwise we'd create new\n    // promises with the lines `become(whatever(value))`. See e.g. GH-252.\n\n    function become(newPromise) {\n        resolvedPromise = newPromise;\n\n        if (Q.longStackSupport && hasStacks) {\n            // Only hold a reference to the new promise if long stacks\n            // are enabled to reduce memory usage\n            promise.source = newPromise;\n        }\n\n        array_reduce(messages, function (undefined, message) {\n            Q.nextTick(function () {\n                newPromise.promiseDispatch.apply(newPromise, message);\n            });\n        }, void 0);\n\n        messages = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(Q(value));\n    };\n\n    deferred.fulfill = function (value) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(fulfill(value));\n    };\n    deferred.reject = function (reason) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        become(reject(reason));\n    };\n    deferred.notify = function (progress) {\n        if (resolvedPromise) {\n            return;\n        }\n\n        array_reduce(progressListeners, function (undefined, progressListener) {\n            Q.nextTick(function () {\n                progressListener(progress);\n            });\n        }, void 0);\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param resolver {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in resolver\n */\nQ.Promise = promise; // ES6\nQ.promise = promise;\nfunction promise(resolver) {\n    if (typeof resolver !== \"function\") {\n        throw new TypeError(\"resolver must be a function.\");\n    }\n    var deferred = defer();\n    try {\n        resolver(deferred.resolve, deferred.reject, deferred.notify);\n    } catch (reason) {\n        deferred.reject(reason);\n    }\n    return deferred.promise;\n}\n\npromise.race = race; // ES6\npromise.all = all; // ES6\npromise.reject = reject; // ES6\npromise.resolve = Q; // ES6\n\n// XXX experimental.  This method is a way to denote that a local value is\n// serializable and should be immediately dispatched to a remote upon request,\n// instead of passing a reference.\nQ.passByCopy = function (object) {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return object;\n};\n\nPromise.prototype.passByCopy = function () {\n    //freeze(object);\n    //passByCopies.set(object, true);\n    return this;\n};\n\n/**\n * If two promises eventually fulfill to the same value, promises that value,\n * but otherwise rejects.\n * @param x {Any*}\n * @param y {Any*}\n * @returns {Any*} a promise for x and y if they are the same, but a rejection\n * otherwise.\n *\n */\nQ.join = function (x, y) {\n    return Q(x).join(y);\n};\n\nPromise.prototype.join = function (that) {\n    return Q([this, that]).spread(function (x, y) {\n        if (x === y) {\n            // TODO: \"===\" should be Object.is or equiv\n            return x;\n        } else {\n            throw new Error(\"Q can't join: not the same: \" + x + \" \" + y);\n        }\n    });\n};\n\n/**\n * Returns a promise for the first of an array of promises to become settled.\n * @param answers {Array[Any*]} promises to race\n * @returns {Any*} the first promise to be settled\n */\nQ.race = race;\nfunction race(answerPs) {\n    return promise(function (resolve, reject) {\n        // Switch to this once we can assume at least ES5\n        // answerPs.forEach(function (answerP) {\n        //     Q(answerP).then(resolve, reject);\n        // });\n        // Use this in the meantime\n        for (var i = 0, len = answerPs.length; i < len; i++) {\n            Q(answerPs[i]).then(resolve, reject);\n        }\n    });\n}\n\nPromise.prototype.race = function () {\n    return this.then(Q.race);\n};\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * set(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = Promise;\nfunction Promise(descriptor, fallback, inspect) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\n                \"Promise does not support operation: \" + op\n            ));\n        };\n    }\n    if (inspect === void 0) {\n        inspect = function () {\n            return {state: \"unknown\"};\n        };\n    }\n\n    var promise = object_create(Promise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    promise.inspect = inspect;\n\n    // XXX deprecated `valueOf` and `exception` support\n    if (inspect) {\n        var inspected = inspect();\n        if (inspected.state === \"rejected\") {\n            promise.exception = inspected.reason;\n        }\n\n        promise.valueOf = function () {\n            var inspected = inspect();\n            if (inspected.state === \"pending\" ||\n                inspected.state === \"rejected\") {\n                return promise;\n            }\n            return inspected.value;\n        };\n    }\n\n    return promise;\n}\n\nPromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\nPromise.prototype.then = function (fulfilled, rejected, progressed) {\n    var self = this;\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, self);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    Q.nextTick(function () {\n        self.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    self.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n};\n\nQ.tap = function (promise, callback) {\n    return Q(promise).tap(callback);\n};\n\n/**\n * Works almost like \"finally\", but not called for rejections.\n * Original resolution value is passed through callback unaffected.\n * Callback may return a promise that will be awaited for.\n * @param {Function} callback\n * @returns {Q.Promise}\n * @example\n * doSomething()\n *   .then(...)\n *   .tap(console.log)\n *   .then(...);\n */\nPromise.prototype.tap = function (callback) {\n    callback = Q(callback);\n\n    return this.then(function (value) {\n        return callback.fcall(value).thenResolve(value);\n    });\n};\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    return Q(value).then(fulfilled, rejected, progressed);\n}\n\nPromise.prototype.thenResolve = function (value) {\n    return this.then(function () { return value; });\n};\n\nQ.thenResolve = function (promise, value) {\n    return Q(promise).thenResolve(value);\n};\n\nPromise.prototype.thenReject = function (reason) {\n    return this.then(function () { throw reason; });\n};\n\nQ.thenReject = function (promise, reason) {\n    return Q(promise).thenReject(reason);\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\n\n// XXX should we re-do this?\nQ.nearer = nearer;\nfunction nearer(value) {\n    if (isPromise(value)) {\n        var inspected = value.inspect();\n        if (inspected.state === \"fulfilled\") {\n            return inspected.value;\n        }\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object instanceof Promise;\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return isObject(object) && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return isPromise(object) && object.inspect().state === \"pending\";\n}\n\nPromise.prototype.isPending = function () {\n    return this.inspect().state === \"pending\";\n};\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromise(object) || object.inspect().state === \"fulfilled\";\n}\n\nPromise.prototype.isFulfilled = function () {\n    return this.inspect().state === \"fulfilled\";\n};\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    return isPromise(object) && object.inspect().state === \"rejected\";\n}\n\nPromise.prototype.isRejected = function () {\n    return this.inspect().state === \"rejected\";\n};\n\n//// BEGIN UNHANDLED REJECTION TRACKING\n\n// This promise library consumes exceptions thrown in handlers so they can be\n// handled by a subsequent promise.  The exceptions get added to this array when\n// they are created, and removed when they are handled.  Note that in ES6 or\n// shimmed environments, this would naturally be a `Set`.\nvar unhandledReasons = [];\nvar unhandledRejections = [];\nvar reportedUnhandledRejections = [];\nvar trackUnhandledRejections = true;\n\nfunction resetUnhandledRejections() {\n    unhandledReasons.length = 0;\n    unhandledRejections.length = 0;\n\n    if (!trackUnhandledRejections) {\n        trackUnhandledRejections = true;\n    }\n}\n\nfunction trackRejection(promise, reason) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n    if (typeof process === \"object\" && typeof process.emit === \"function\") {\n        Q.nextTick.runAfter(function () {\n            if (array_indexOf(unhandledRejections, promise) !== -1) {\n                process.emit(\"unhandledRejection\", reason, promise);\n                reportedUnhandledRejections.push(promise);\n            }\n        });\n    }\n\n    unhandledRejections.push(promise);\n    if (reason && typeof reason.stack !== \"undefined\") {\n        unhandledReasons.push(reason.stack);\n    } else {\n        unhandledReasons.push(\"(no stack) \" + reason);\n    }\n}\n\nfunction untrackRejection(promise) {\n    if (!trackUnhandledRejections) {\n        return;\n    }\n\n    var at = array_indexOf(unhandledRejections, promise);\n    if (at !== -1) {\n        if (typeof process === \"object\" && typeof process.emit === \"function\") {\n            Q.nextTick.runAfter(function () {\n                var atReport = array_indexOf(reportedUnhandledRejections, promise);\n                if (atReport !== -1) {\n                    process.emit(\"rejectionHandled\", unhandledReasons[at], promise);\n                    reportedUnhandledRejections.splice(atReport, 1);\n                }\n            });\n        }\n        unhandledRejections.splice(at, 1);\n        unhandledReasons.splice(at, 1);\n    }\n}\n\nQ.resetUnhandledRejections = resetUnhandledRejections;\n\nQ.getUnhandledReasons = function () {\n    // Make a copy so that consumers can't interfere with our internal state.\n    return unhandledReasons.slice();\n};\n\nQ.stopUnhandledRejectionTracking = function () {\n    resetUnhandledRejections();\n    trackUnhandledRejections = false;\n};\n\nresetUnhandledRejections();\n\n//// END UNHANDLED REJECTION TRACKING\n\n/**\n * Constructs a rejected promise.\n * @param reason value describing the failure\n */\nQ.reject = reject;\nfunction reject(reason) {\n    var rejection = Promise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                untrackRejection(this);\n            }\n            return rejected ? rejected(reason) : this;\n        }\n    }, function fallback() {\n        return this;\n    }, function inspect() {\n        return { state: \"rejected\", reason: reason };\n    });\n\n    // Note that the reason has not been handled.\n    trackRejection(rejection, reason);\n\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(value) {\n    return Promise({\n        \"when\": function () {\n            return value;\n        },\n        \"get\": function (name) {\n            return value[name];\n        },\n        \"set\": function (name, rhs) {\n            value[name] = rhs;\n        },\n        \"delete\": function (name) {\n            delete value[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name === null || name === void 0) {\n                return value.apply(void 0, args);\n            } else {\n                return value[name].apply(value, args);\n            }\n        },\n        \"apply\": function (thisp, args) {\n            return value.apply(thisp, args);\n        },\n        \"keys\": function () {\n            return object_keys(value);\n        }\n    }, void 0, function inspect() {\n        return { state: \"fulfilled\", value: value };\n    });\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    Q.nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return Promise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return Q(object).inspect();\n    });\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(value, fulfilled, rejected) {\n    return Q(value).spread(fulfilled, rejected);\n}\n\nPromise.prototype.spread = function (fulfilled, rejected) {\n    return this.all().then(function (array) {\n        return fulfilled.apply(void 0, array);\n    }, rejected);\n};\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  Although generators are only part\n * of the newest ECMAScript 6 drafts, this code does not cause syntax\n * errors in older engines.  This code should continue to work and will\n * in fact improve over time as the language improves.\n *\n * ES6 generators are currently part of V8 version 3.19 with the\n * --harmony-generators runtime flag enabled.  SpiderMonkey has had them\n * for longer, but under an older Python-inspired form.  This function\n * works on both kinds of generators.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n\n            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only\n            // engine that has a deployed base of browsers that support generators.\n            // However, SM's generators use the Python-inspired semantics of\n            // outdated ES6 drafts.  We would like to support ES6, but we'd also\n            // like to make it possible to use generators in deployed browsers, so\n            // we also support Python-style generators.  At some point we can remove\n            // this block.\n\n            if (typeof StopIteration === \"undefined\") {\n                // ES6 Generators\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    return reject(exception);\n                }\n                if (result.done) {\n                    return Q(result.value);\n                } else {\n                    return when(result.value, callback, errback);\n                }\n            } else {\n                // SpiderMonkey Generators\n                // FIXME: Remove this case when SM does ES6 generators.\n                try {\n                    result = generator[verb](arg);\n                } catch (exception) {\n                    if (isStopIteration(exception)) {\n                        return Q(exception.value);\n                    } else {\n                        return reject(exception);\n                    }\n                }\n                return when(result, callback, errback);\n            }\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"next\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * The spawn function is a small wrapper around async that immediately\n * calls the generator and also ends the promise chain, so that any\n * unhandled errors are thrown instead of forwarded to the error\n * handler. This is useful because it's extremely common to run\n * generators at the top-level to work with libraries.\n */\nQ.spawn = spawn;\nfunction spawn(makeGenerator) {\n    Q.done(Q.async(makeGenerator)());\n}\n\n// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n *\n * This interface is a stop-gap measure to support generator return\n * values in older Firefox/SpiderMonkey.  In browsers that support ES6\n * generators like Chromium 29, just use \"return\" in your generator\n * functions.\n *\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * // ES6 style\n * Q.async(function* () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      return foo + bar;\n * })\n * // Older SpiderMonkey style\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ[\"return\"] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are settled and passed as values (`this` is also settled and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q(a), Q(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    return Q(object).dispatch(op, args);\n}\n\nPromise.prototype.dispatch = function (op, args) {\n    var self = this;\n    var deferred = defer();\n    Q.nextTick(function () {\n        self.promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n};\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = function (object, key) {\n    return Q(object).dispatch(\"get\", [key]);\n};\n\nPromise.prototype.get = function (key) {\n    return this.dispatch(\"get\", [key]);\n};\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = function (object, key, value) {\n    return Q(object).dispatch(\"set\", [key, value]);\n};\n\nPromise.prototype.set = function (key, value) {\n    return this.dispatch(\"set\", [key, value]);\n};\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ.del = // XXX legacy\nQ[\"delete\"] = function (object, key) {\n    return Q(object).dispatch(\"delete\", [key]);\n};\n\nPromise.prototype.del = // XXX legacy\nPromise.prototype[\"delete\"] = function (key) {\n    return this.dispatch(\"delete\", [key]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nQ.mapply = // XXX As proposed by \"Redsandro\"\nQ.post = function (object, name, args) {\n    return Q(object).dispatch(\"post\", [name, args]);\n};\n\nPromise.prototype.mapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.post = function (name, args) {\n    return this.dispatch(\"post\", [name, args]);\n};\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = // XXX Mark Miller's proposed parlance\nQ.mcall = // XXX As proposed by \"Redsandro\"\nQ.invoke = function (object, name /*...args*/) {\n    return Q(object).dispatch(\"post\", [name, array_slice(arguments, 2)]);\n};\n\nPromise.prototype.send = // XXX Mark Miller's proposed parlance\nPromise.prototype.mcall = // XXX As proposed by \"Redsandro\"\nPromise.prototype.invoke = function (name /*...args*/) {\n    return this.dispatch(\"post\", [name, array_slice(arguments, 1)]);\n};\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = function (object, args) {\n    return Q(object).dispatch(\"apply\", [void 0, args]);\n};\n\nPromise.prototype.fapply = function (args) {\n    return this.dispatch(\"apply\", [void 0, args]);\n};\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] =\nQ.fcall = function (object /* ...args*/) {\n    return Q(object).dispatch(\"apply\", [void 0, array_slice(arguments, 1)]);\n};\n\nPromise.prototype.fcall = function (/*...args*/) {\n    return this.dispatch(\"apply\", [void 0, array_slice(arguments)]);\n};\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = function (object /*...args*/) {\n    var promise = Q(object);\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\nPromise.prototype.fbind = function (/*...args*/) {\n    var promise = this;\n    var args = array_slice(arguments);\n    return function fbound() {\n        return promise.dispatch(\"apply\", [\n            this,\n            args.concat(array_slice(arguments))\n        ]);\n    };\n};\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually settled object\n */\nQ.keys = function (object) {\n    return Q(object).dispatch(\"keys\", []);\n};\n\nPromise.prototype.keys = function () {\n    return this.dispatch(\"keys\", []);\n};\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var pendingCount = 0;\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            var snapshot;\n            if (\n                isPromise(promise) &&\n                (snapshot = promise.inspect()).state === \"fulfilled\"\n            ) {\n                promises[index] = snapshot.value;\n            } else {\n                ++pendingCount;\n                when(\n                    promise,\n                    function (value) {\n                        promises[index] = value;\n                        if (--pendingCount === 0) {\n                            deferred.resolve(promises);\n                        }\n                    },\n                    deferred.reject,\n                    function (progress) {\n                        deferred.notify({ index: index, value: progress });\n                    }\n                );\n            }\n        }, void 0);\n        if (pendingCount === 0) {\n            deferred.resolve(promises);\n        }\n        return deferred.promise;\n    });\n}\n\nPromise.prototype.all = function () {\n    return all(this);\n};\n\n/**\n * Returns the first resolved promise of an array. Prior rejected promises are\n * ignored.  Rejects only if all promises are rejected.\n * @param {Array*} an array containing values or promises for values\n * @returns a promise fulfilled with the value of the first resolved promise,\n * or a rejected promise if all promises are rejected.\n */\nQ.any = any;\n\nfunction any(promises) {\n    if (promises.length === 0) {\n        return Q.resolve();\n    }\n\n    var deferred = Q.defer();\n    var pendingCount = 0;\n    array_reduce(promises, function (prev, current, index) {\n        var promise = promises[index];\n\n        pendingCount++;\n\n        when(promise, onFulfilled, onRejected, onProgress);\n        function onFulfilled(result) {\n            deferred.resolve(result);\n        }\n        function onRejected(err) {\n            pendingCount--;\n            if (pendingCount === 0) {\n                var rejection = err || new Error(\"\" + err);\n\n                rejection.message = (\"Q can't get fulfillment value from any promise, all \" +\n                    \"promises were rejected. Last error message: \" + rejection.message);\n\n                deferred.reject(rejection);\n            }\n        }\n        function onProgress(progress) {\n            deferred.notify({\n                index: index,\n                value: progress\n            });\n        }\n    }, undefined);\n\n    return deferred.promise;\n}\n\nPromise.prototype.any = function () {\n    return any(this);\n};\n\n/**\n * Waits for all promises to be settled, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = deprecate(allResolved, \"allResolved\", \"allSettled\");\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, Q);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\nPromise.prototype.allResolved = function () {\n    return allResolved(this);\n};\n\n/**\n * @see Promise#allSettled\n */\nQ.allSettled = allSettled;\nfunction allSettled(promises) {\n    return Q(promises).allSettled();\n}\n\n/**\n * Turns an array of promises into a promise for an array of their states (as\n * returned by `inspect`) when they have all settled.\n * @param {Array[Any*]} values an array (or promise for an array) of values (or\n * promises for values)\n * @returns {Array[State]} an array of states for the respective values.\n */\nPromise.prototype.allSettled = function () {\n    return this.then(function (promises) {\n        return all(array_map(promises, function (promise) {\n            promise = Q(promise);\n            function regardless() {\n                return promise.inspect();\n            }\n            return promise.then(regardless, regardless);\n        }));\n    });\n};\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ.fail = // XXX legacy\nQ[\"catch\"] = function (object, rejected) {\n    return Q(object).then(void 0, rejected);\n};\n\nPromise.prototype.fail = // XXX legacy\nPromise.prototype[\"catch\"] = function (rejected) {\n    return this.then(void 0, rejected);\n};\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(object, progressed) {\n    return Q(object).then(void 0, void 0, progressed);\n}\n\nPromise.prototype.progress = function (progressed) {\n    return this.then(void 0, void 0, progressed);\n};\n\n/**\n * Provides an opportunity to observe the settling of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ.fin = // XXX legacy\nQ[\"finally\"] = function (object, callback) {\n    return Q(object)[\"finally\"](callback);\n};\n\nPromise.prototype.fin = // XXX legacy\nPromise.prototype[\"finally\"] = function (callback) {\n    if (!callback || typeof callback.apply !== \"function\") {\n        throw new Error(\"Q can't apply finally callback\");\n    }\n    callback = Q(callback);\n    return this.then(function (value) {\n        return callback.fcall().then(function () {\n            return value;\n        });\n    }, function (reason) {\n        // TODO attempt to recycle the rejection with \"this\".\n        return callback.fcall().then(function () {\n            throw reason;\n        });\n    });\n};\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = function (object, fulfilled, rejected, progress) {\n    return Q(object).done(fulfilled, rejected, progress);\n};\n\nPromise.prototype.done = function (fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        Q.nextTick(function () {\n            makeStackTraceLong(error, promise);\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promise = fulfilled || rejected || progress ?\n        this.then(fulfilled, rejected, progress) :\n        this;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n\n    promise.then(void 0, onUnhandledError);\n};\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @param {Any*} custom error message or Error object (optional)\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = function (object, ms, error) {\n    return Q(object).timeout(ms, error);\n};\n\nPromise.prototype.timeout = function (ms, error) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        if (!error || \"string\" === typeof error) {\n            error = new Error(error || \"Timed out after \" + ms + \" ms\");\n            error.code = \"ETIMEDOUT\";\n        }\n        deferred.reject(error);\n    }, ms);\n\n    this.then(function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    }, deferred.notify);\n\n    return deferred.promise;\n};\n\n/**\n * Returns a promise for the given value (or promised value), some\n * milliseconds after it resolved. Passes rejections immediately.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after milliseconds\n * time has elapsed since the resolution of the given promise.\n * If the given promise rejects, that is passed immediately.\n */\nQ.delay = function (object, timeout) {\n    if (timeout === void 0) {\n        timeout = object;\n        object = void 0;\n    }\n    return Q(object).delay(timeout);\n};\n\nPromise.prototype.delay = function (timeout) {\n    return this.then(function (value) {\n        var deferred = defer();\n        setTimeout(function () {\n            deferred.resolve(value);\n        }, timeout);\n        return deferred.promise;\n    });\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = function (callback, args) {\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfapply = function (args) {\n    var deferred = defer();\n    var nodeArgs = array_slice(args);\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n * @example\n * Q.nfcall(FS.readFile, __filename)\n * .then(function (content) {\n * })\n *\n */\nQ.nfcall = function (callback /*...args*/) {\n    var args = array_slice(arguments, 1);\n    return Q(callback).nfapply(args);\n};\n\nPromise.prototype.nfcall = function (/*...args*/) {\n    var nodeArgs = array_slice(arguments);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.fapply(nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n * @example\n * Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n * .then(console.log)\n * .done()\n */\nQ.nfbind =\nQ.denodeify = function (callback /*...args*/) {\n    if (callback === undefined) {\n        throw new Error(\"Q can't wrap an undefined function\");\n    }\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        Q(callback).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nfbind =\nPromise.prototype.denodeify = function (/*...args*/) {\n    var args = array_slice(arguments);\n    args.unshift(this);\n    return Q.denodeify.apply(void 0, args);\n};\n\nQ.nbind = function (callback, thisp /*...args*/) {\n    var baseArgs = array_slice(arguments, 2);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n        function bound() {\n            return callback.apply(thisp, arguments);\n        }\n        Q(bound).fapply(nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n};\n\nPromise.prototype.nbind = function (/*thisp, ...args*/) {\n    var args = array_slice(arguments, 0);\n    args.unshift(this);\n    return Q.nbind.apply(void 0, args);\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nmapply = // XXX As proposed by \"Redsandro\"\nQ.npost = function (object, name, args) {\n    return Q(object).npost(name, args);\n};\n\nPromise.prototype.nmapply = // XXX As proposed by \"Redsandro\"\nPromise.prototype.npost = function (name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = // XXX Based on Mark Miller's proposed \"send\"\nQ.nmcall = // XXX Based on \"Redsandro's\" proposal\nQ.ninvoke = function (object, name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    Q(object).dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\nPromise.prototype.nsend = // XXX Based on Mark Miller's proposed \"send\"\nPromise.prototype.nmcall = // XXX Based on \"Redsandro's\" proposal\nPromise.prototype.ninvoke = function (name /*...args*/) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    this.dispatch(\"post\", [name, nodeArgs]).fail(deferred.reject);\n    return deferred.promise;\n};\n\n/**\n * If a function would like to support both Node continuation-passing-style and\n * promise-returning-style, it can end its internal promise chain with\n * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user\n * elects to use a nodeback, the result will be sent there.  If they do not\n * pass a nodeback, they will receive the result promise.\n * @param object a result (or a promise for a result)\n * @param {Function} nodeback a Node.js-style callback\n * @returns either the promise or nothing\n */\nQ.nodeify = nodeify;\nfunction nodeify(object, nodeback) {\n    return Q(object).nodeify(nodeback);\n}\n\nPromise.prototype.nodeify = function (nodeback) {\n    if (nodeback) {\n        this.then(function (value) {\n            Q.nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            Q.nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return this;\n    }\n};\n\nQ.noConflict = function() {\n    throw new Error(\"Q.noConflict only works when Q is used as a global\");\n};\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/q/q.js\n// module id = 500\n// module chunks = 0 3","const o = require('odata')\n\no().config({\n  endpoint: 'http://axiomcredit-001-site1.etempurl.com/odata'\n})\n\nexport default o\n\n\n\n// WEBPACK FOOTER //\n// ./src/api/odata.js","// +++\r\n// o.js  v0.3.7\r\n//\r\n// o.js is a simple oData wrapper for JavaScript.\r\n// Currently supporting the following operations:\r\n// .get() / .post() / .put() / .delete() / .first()  / .take() / .skip() / .filter() / .orderBy() / .orderByDesc() / .count() /.search() / .select() / .any() / .ref() / .deleteRef()\r\n//\r\n// By Jan Hommes\r\n// Date: 11/08/2017\r\n// Contributors: Matteo Antony Mistretta (https://github.com/IceOnFire), \r\n//\r\n// --------------------\r\n// The MIT License (MIT)\r\n//\r\n// Copyright (c) 2017 Jan Hommes\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to deal\r\n// in the Software without restriction, including without limitation the rights\r\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n// copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n// THE SOFTWARE.\r\n// +++\r\n; (function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['q'], factory);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('q'));\r\n    } else {\r\n        root.o = factory(root.Q);\r\n    }\r\n}(this, function (Q) {\r\n    function o(res) {\r\n        var base = this;\r\n\r\n        //base config object\r\n        base.oConfig = base.oConfig || {\r\n            endpoint: null,\r\n            format: 'json', \t// The media format. Default is JSON.\r\n            autoFormat: true,   // Will always append a $format=json to each query if set to true.\r\n            version: 4, \t\t// currently only tested for Version 4. Most will work in version 3 as well.\r\n            strictMode: true, \t// strict mode throws exception, non strict mode only logs them\r\n            start: null, \t\t// a function which is executed on loading\r\n            ready: null,\t\t// a function which is executed on ready\r\n            error: null,\t\t// a function which is executed on error\r\n            headers: [],\t\t// an array of additional headers [{name:'headername',value:'headervalue'}]\r\n            username: null, \t// the basic auth username\r\n            password: null,\t\t// the basic auth password\r\n            isAsync: true,\t\t// set this to false to enable sync requests. Only usable without basic auth\r\n            isCors: true,       // set this to false to disable CORS\r\n            openAjaxRequests: 0,// a counter for all open ajax request to determine that are all ready TODO: Move this out of the config\r\n            isHashRoute: true,  // set this var to false to disable automatic #-hash setting on routes\r\n            appending: ''\t\t// set this value to append something to a any request. eg.: [{name:'apikey', value:'xyz'}]\r\n        };\r\n\r\n        // +++\r\n        // Configuration of the oData endpoint\r\n        //\r\n        // endpoint: Name of the endpoint e.g. http(s)://MyDomain/ServiceName.svc\r\n        // json: Use json, true or false (currently only json supported)\r\n        // version: Define the oData Version. (currently only Version 3 and 4 are supported)\r\n        // strictMode: In strict mode exceptions are thrown, else they are logged\r\n        // start: A function which is executed on loading\r\n        // ready: A function which is executed on finished loading\r\n        // headers: An array of additional headers [{name:'headername',value:'headervalue'}]\r\n        // username: The basic auth username\r\n        // password: The basic auth password\r\n        // isAsync: If set to false, the request are done sync. Default is true.\r\n        // IsCors: set this to false to disable CORS\r\n        // +++\r\n        base.config = function (config) {\r\n            base.oConfig = merge(base.oConfig, config);\r\n        }\r\n\r\n        // +++\r\n        // indicates if a endpoint is configured\r\n        // +++\r\n        base.isEndpoint = function () {\r\n            return (base.oConfig.endpoint !== null);\r\n        }\r\n\r\n        // +++\r\n        // To merge x object together\r\n        // +++\r\n        function merge() {\r\n            var obj = {},\r\n                i = 0,\r\n                il = arguments.length,\r\n                key;\r\n            for (; i < il; i++) {\r\n                for (key in arguments[i]) {\r\n                    if (arguments[i].hasOwnProperty(key)) {\r\n                        obj[key] = arguments[i][key];\r\n                    }\r\n                }\r\n            }\r\n            return obj;\r\n        }\r\n\r\n        if (typeof res === 'undefined') {\r\n            return (base);\r\n        }\r\n        else {\r\n            return (new oData(res, base.oConfig));\r\n        }\r\n    }\r\n\r\n\r\n    function oData(res, config) {\r\n        var base = this;\r\n\r\n        // --------------------+++ VARIABLES +++---------------------------\r\n\r\n        //base internal variables\r\n        var resource = null; \t\t\t\t\t// the main resource string\r\n        var resourceList = []; \t\t    \t\t// an array list of all resource used\r\n        var routeList = []; \t\t\t\t\t// an array list of all routes used\r\n        var isEndpoint = true;\t\t    \t\t// true if an endpoint is configured\r\n        var currentPromise = null;\t    \t\t// if promise (Q.js) is used, we hold it here\r\n        var overideLoading = null;      \t\t// if set, this resource call don't use the global loading function\r\n        var isXDomainRequest = false;   \t\t// this is set to true in IE 9 and IE 8 to support CORS operations. No basic auth support :(\r\n        var beforeRoutingFunc = function () { };\t// A function which is called before routing.\r\n        var internalParam = {}; \t\t\t\t// like base.param this object holds all parameter for a route but with the leading : for easier using in regexes\r\n        var opertionMapping = {\r\n            '==': 'eq',\r\n            '===': 'eq',\r\n            '!=': 'ne',\r\n            '!==': 'ne',\r\n            '>': 'gt',\r\n            '>=': 'ge',\r\n            '<': 'lt',\r\n            '<=': 'le',\r\n            '&&': 'and',\r\n            '||': 'or',\r\n            '!': 'not',\r\n            //'+': 'add',\r\n            //'-': 'sub',\r\n            '*': 'mul',\r\n            //'.': '/',\r\n            '%': 'mod'\r\n        };\r\n\r\n\r\n        //base external variables\r\n        base.data = [];\t\t\t\t\t//holds the data after an callback\r\n        base.inlinecount = null; \t\t//if inlinecount is set, here the counting is gold\r\n        base.param = {};\t\t\t\t//this object holds all parameter for a route\r\n        base.oConfig = config;\t\t\t//the internal config, passed over from the o function\r\n        base.raw = null;                //holds the data after an callback (raw data, containing also metadata)\r\n\r\n\r\n        // ---------------------+++ PUBLICS +++----------------------------\r\n\r\n        // +++\r\n        // route is a little extra function to enable rest-like routing on the client side\r\n        // +++\r\n        base.routes = base.route = function (routes, callback) {\r\n\r\n            //if not a array, make it one\r\n            if (!isArray(routes)) {\r\n                routes = [routes];\r\n            }\r\n\r\n            // check support\r\n            if (typeof window === 'undefined') {\r\n                throwEx('Routes are only supported in a browser env.');\r\n            }\r\n\r\n            var prevHash = window.location.hash;\r\n\r\n            //literate over every rout and add a interval to check if the route is triggered\r\n            for (var i = 0; i < routes.length; i++) {\r\n                if (typeof callback !== 'undefined') {\r\n\r\n                    //Push the routes in the routeList\r\n                    //TODO: Is there any way to use the build an on hash update function?! Onhaschange can't be bound multiple times. Also a problem: if the hash is called a second time the route is not triggered\r\n                    routeList.push({\r\n                        name: routes[i],\r\n                        route: buildRouteRegex(routes[i]),\r\n                        callback: callback,\r\n                        param: {},\r\n                        interval: setInterval(function () {\r\n                            if (window.location.hash != prevHash) {\r\n                                prevHash = window.location.hash;\r\n                                checkRoute(window.location.hash);\r\n                            }\r\n                        }, 100)\r\n                    });\r\n                }\r\n                else {\r\n                    throwEx('Routes without a callback are not supported. Please define a function like .route(\"YourRoute\", function() { }).');\r\n                }\r\n            }\r\n\r\n            //trigger on init if the hash is the same like current\r\n            base.triggerRoute(window.location.hash);\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // get called beforerounting\r\n        // +++\r\n        base.beforeRouting = function (beforeFunc) {\r\n            beforeRoutingFunc = beforeFunc;\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // indicates if a endpoint is configured\r\n        // +++\r\n        base.isEndpoint = function () {\r\n            return (isEndpoint);\r\n        }\r\n\r\n        // +++\r\n        // triggers a route\r\n        // +++\r\n        base.triggerRoute = function (hash) {\r\n            checkRoute(hash);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the object with the given id\r\n        // +++\r\n        base.find = function (getId) {\r\n            resource.path[resource.path.length - 1].get = getId;\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the top x objects\r\n        // +++\r\n        base.top = base.take = function (takeAmount) {\r\n            if (!isQueryThrowEx(['$top'])) {\r\n                addQuery('$top', takeAmount, takeAmount);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the x objects skipped by the property value\r\n        // +++\r\n        base.skip = function (skipAmount) {\r\n            if (!isQueryThrowEx('$skip')) {\r\n                addQuery('$skip', skipAmount, skipAmount);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the first object which is found\r\n        // +++\r\n        base.first = function () {\r\n            if (!isQueryThrowEx(['$top', '$first'])) {\r\n                addQuery('$top', 1, null, '$first');\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // add a filter\r\n        // +++\r\n        base.filter = base.where = function (filterStr) {\r\n            var filterVal = checkEmpty(jsToOdata(filterStr));\r\n            if (isQuery('$filter')) {\r\n                appendQuery('$filter', filterVal, filterVal);\r\n            }\r\n            else {\r\n                addQuery('$filter', filterVal, filterVal);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Applies a any filter\r\n        // +++\r\n        base.any = function (res, filter) {\r\n            var filterVal = res + '/any(x:x/' + jsToOdata(checkEmpty(filter)) + ')'\r\n            if (isQuery('$filter')) {\r\n                appendQuery('$filter', filterVal, filterVal);\r\n            }\r\n            else {\r\n                addQuery('$filter', filterVal, filterVal);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // orders the result asc\r\n        // +++\r\n        base.orderBy = function (orderStr, direction) {\r\n            if (typeof direction === 'undefined') {\r\n                direction = 'asc';\r\n            }\r\n            if (!isQueryThrowEx('$orderby')) {\r\n                addQuery('$orderby', checkEmpty(orderStr) + ' ' + direction);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // orders the result desc\r\n        // +++\r\n        base.orderByDesc = function (orderStr) {\r\n            return base.orderBy(orderStr, 'desc');\r\n        }\r\n\r\n        // +++\r\n        // enables select\r\n        // +++\r\n        base.select = function (selectStr) {\r\n            addQuery('$select', checkEmpty(selectStr));\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the counted data-sets\r\n        // +++\r\n        base.count = function () {\r\n            if (base.oConfig.version >= 4) {\r\n                resource.path.push({ resource: '$count', get: null });\r\n            }\r\n            else {\r\n                removeQuery('$format');\r\n                addQuery('$count', 'count');\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a inline count\r\n        // +++\r\n        base.inlineCount = function (countOption) {\r\n            if (base.oConfig.version >= 4) {\r\n                countOption = countOption || 'true';\r\n                if (!isQueryThrowEx('$count')) {\r\n                    addQuery('$count', countOption);\r\n                }\r\n            }\r\n            else {\r\n                countOption = countOption || 'allpages';\r\n                if (!isQueryThrowEx('$inlinecount')) {\r\n                    addQuery('$inlinecount', countOption);\r\n                }\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a second resource to the request list to batch it\r\n        // +++\r\n        base.batch = function (res) {\r\n            //add a new resource\r\n            addNewResource(res);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // returns the top x objects\r\n        // +++\r\n        base.expand = function (expandStr) {\r\n            expandResource(expandStr);\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // set to false to disabel loading, set two functions to overide loading\r\n        // +++\r\n        base.loading = function (func1, func2) {\r\n            func2 = func2 || func1;\r\n            if (!func1)\r\n                overideLoading = [function () { }, function () { }];\r\n            else {\r\n                overideLoading = [func1, func2];\r\n            }\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // appends a navigation property to an existing resource\r\n        // +++\r\n        base.ref = base.link = function (navPath, id) {\r\n            removeQuery('$format');\r\n            if (resource == null || resource.get) {\r\n                throwEx('You need to define a resource with the find() method to append an navigation property');\r\n            }\r\n            if (base.oConfig.version < 4) {\r\n                resource.method = 'POST';\r\n                resource.path.push('$link');\r\n                resource.path.push({ resource: navPath, get: null });\r\n            }\r\n            else {\r\n                resource.method = 'POST';\r\n                resource.path.push({ resource: navPath, get: null });\r\n                resource.path.push({ resource: '$ref', get: null });\r\n            }\r\n            var newResource = parseUri(navPath);\r\n            newResource.path[newResource.path.length - 1].get = id;\r\n            var baseRes = buildQuery(newResource);\r\n            resource.data = { '@odata.id': baseRes.substring(0, baseRes.length - 1) };\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // deletes a referenced entity relation\r\n        // +++\r\n        base.removeRef = base.deleteRef = function (navPath, id) {\r\n            removeQuery('$format');\r\n            if (resource == null || resource.get) {\r\n                throwEx('You need to define a resource with the find() method to append an navigation property');\r\n            }\r\n            if (base.oConfig.version < 4) {\r\n                resource.method = 'POST';\r\n                resource.path.push('$link');\r\n                resource.path.push({ resource: navPath, get: null });\r\n            }\r\n            else {\r\n                resource.method = 'POST';\r\n                resource.path.push({ resource: navPath, get: null });\r\n                resource.path.push({ resource: '$ref', get: null });\r\n            }\r\n            if (id) {\r\n                var newResource = parseUri(navPath);\r\n                newResource.path[newResource.path.length - 1].get = id;\r\n                var baseRes = buildQuery(newResource);\r\n                addQuery('$id', baseRes.substring(0, baseRes.length - 1));\r\n            }\r\n            //set the method\r\n            resource.method = 'DELETE';\r\n\r\n            return (base);\r\n        }\r\n\r\n\r\n        // +++\r\n        // This function actually queries the oData service with a GET request\r\n        // +++\r\n        base.get = function (callback, errorCallback) {\r\n            // init the q -> if node require a node promise -> if ES6, try ES6 promise\r\n            var promise = initPromise();\r\n            if (promise && typeof callback === 'undefined')\r\n                currentPromise = promise.defer();\r\n\r\n            //start the request\r\n            startRequest(callback, errorCallback, false);\r\n            if (promise && typeof callback === 'undefined')\r\n                return (currentPromise.promise);\r\n            else\r\n                return (base);\r\n        }\r\n\r\n        // +++\r\n        // adds a dataset to the current selected resource\r\n        // if o(\"Product/ProductGroup\").post(...) will post a dataset to the Product resource\r\n        // +++\r\n        base.save = function (callback, errorCallback) {\r\n            //if base.data is set and the user saves, we copying this resource as a Patch\r\n            //this allows a fast edit mode after a get request\r\n            if (resource.method === 'GET' && resource.data !== null) {\r\n                var newResource = deepCopy(resource);\r\n                //set the method and data\r\n                newResource.method = 'PATCH';\r\n                newResource.data = resource.data;\r\n                addNewResource(newResource);\r\n            }\r\n\r\n            var promise = initPromise();\r\n\r\n            //start the request with promise\r\n            if (promise && typeof callback === 'undefined') {\r\n                currentPromise = promise.defer();\r\n                startRequest(callback, errorCallback, true);\r\n                return (currentPromise.promise);\r\n            }\r\n            //start the request without promise\r\n            else {\r\n                startRequest(callback, errorCallback, true);\r\n                return (base);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // adds a dataset to the current selected resource\r\n        // o(\"Product/ProductGroup\").post(...) will post a dataset to the Product resource\r\n        // alternative you can define a new resource by using .post({data},'OtherResource');\r\n        // +++\r\n        base.post = function (data, res) {\r\n            //test: remove the $format attribute\r\n            removeQuery('$format');\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            //if (!resource.path[0] || !resource.path[0].get)\r\n            //    throwEx('Bulk inserts are not supported. You need to query a unique resource with find() to post it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'POST';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a update with the given Data to the current dataset with PATCH.\r\n        // +++\r\n        base.patch = function (data, res) {\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk updates are not supported. You need to query a unique resource with find() to patch/put it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'PATCH';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a update with the given Data to the current dataset with PUT.\r\n        // +++\r\n        base.put = function (data, res) {\r\n\r\n            //add the resource\r\n            if (res) {\r\n                addNewResource(res);\r\n            }\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk updates are not supported. You need to query a unique resource with find() to patch/put it.');\r\n\r\n            //set the method and data\r\n            resource.method = 'PUT';\r\n            resource.data = data;\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // does a delete with the given Data to the current dataset\r\n        // +++\r\n        base.remove = base['delete'] = function (res) {\r\n\r\n            //add the resource\r\n            if (res)\r\n                addNewResource(res);\r\n\r\n            if (!resource.path[resource.path.length - 1] || !resource.path[resource.path.length - 1].get)\r\n                throwEx('Bulk deletes are not supported. You need to query a unique resource with find() to delete it.');\r\n\r\n            //set the method\r\n            resource.method = 'DELETE';\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Returns the current query\r\n        // +++\r\n        base.query = function (overrideRes) {\r\n            return (buildQuery(overrideRes));\r\n        }\r\n\r\n        // +++\r\n        // search for the degined columns\r\n        // +++\r\n        base.search = function (searchColumns, searchWord, searchFunc, isSupported) {\r\n\r\n            var searchStr = buildSearchFilter(searchColumns, searchWord, searchFunc);\r\n\r\n            if (base.oConfig.version == 4 && isSupported) {\r\n                if (!isQueryThrowEx('$search')) {\r\n                    addQuery('$search', searchStr, searchStr);\r\n                }\r\n            }\r\n            else {\r\n                if (!isQueryThrowEx('$filter')) {\r\n                    addQuery('$filter', searchStr, searchStr, '$search');\r\n                }\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Adds a filter to exclude data from a existing data-result\r\n        // +++\r\n        base.filterByList = base.exclude = function (column, data) {\r\n            if (!isQueryThrowEx('$filter')) {\r\n                var filterStr = buildFilterByData(column, data, opertionMapping['!='], opertionMapping['&&']);\r\n                addQuery('$filter', checkEmpty(filterStr), filterStr);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Adds a filter to include data from a existing data-result\r\n        // +++\r\n        base.include = function (column, data) {\r\n            if (!isQueryThrowEx('$filter')) {\r\n                var filterStr = buildFilterByData(column, data, opertionMapping['=='], opertionMapping['||']);\r\n                addQuery('$filter', checkEmpty(filterStr), filterStr);\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // Set this value to add a progress handler to the current resource\r\n        // +++\r\n        base.progress = function (progressFunc) {\r\n            if (resource != null) {\r\n                resource.progress = progressFunc;\r\n            }\r\n            return (base);\r\n        }\r\n\r\n        // ---------------------+++ INTERNALS +++----------------------------\r\n\r\n        // +++\r\n        // initialize a promise callback\r\n        // +++\r\n        function initPromise() {\r\n            if (typeof Q !== 'undefined') {\r\n                var p = Q;\r\n                return (p);\r\n            }\r\n            else if (typeof window === 'undefined') {\r\n                var p = require('q');\r\n                return (p);\r\n            }\r\n            else {\r\n                return (null);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // builds a filter by a given data object to include or exclude values on a query\r\n        // +++\r\n        function buildFilterByData(column, filterList, operation, combine) {\r\n            if (isArray(filterList)) {\r\n                var filterStr = \"\", arr = [];\r\n                for (i = 0; i < filterList.length; ++i) {\r\n                    arr[i] = '(' + column + ' ' + operation + ' ' + filterList[i][column] + ')';\r\n                }\r\n                filterStr = arr.join(' ' + combine + ' ');\r\n                return (filterStr);\r\n            }\r\n            return (\"\");\r\n        }\r\n\r\n        // +++\r\n        // builds a search filter\r\n        // ++++\r\n        function buildSearchFilter(searchColumns, searchWord, searchFunc) {\r\n            searchFunc = searchFunc || (base.oConfig.version == 4 ? 'contains' : 'substringof');\r\n            var searchWordSplit = searchWord.split(' ');\r\n            var isNotExactSearch = (searchFunc === 'contains' || searchFunc === 'substringof');\r\n\r\n            var columnArr = [];\r\n            for (var i = 0; i < searchColumns.length; i++) {\r\n                var wordArr = [];\r\n                if (isNotExactSearch) {\r\n                    for (var m = 0; m < searchWordSplit.length; m++) {\r\n                        if (base.oConfig.version == 4) {\r\n                            wordArr.push(searchFunc + '(' + searchColumns[i] + ',\\'' + searchWordSplit[m] + '\\')');\r\n                        }\r\n                        else {\r\n                            wordArr.push(searchFunc + '(\\'' + searchWordSplit[m] + '\\',' + searchColumns[i] + ')');\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    wordArr.push(searchColumns[i] + ' ' + searchFunc + ' \\'' + searchWord + '\\'');\r\n                }\r\n                columnArr.push('(' + wordArr.join(' and ') + ')');\r\n            }\r\n            return (columnArr.join('or'));\r\n        }\r\n\r\n        // +++\r\n        // builds the URI for this query\r\n        // +++\r\n        function buildQuery(overrideRes) {\r\n            var res = overrideRes || resource;\r\n\r\n            //check if there is a resource defined\r\n            if (!res || res.path.length === 0)\r\n                throwEx('No resource defined. Define a resource first with o(\"YourResourcePath\").');\r\n\r\n            //get the full query\r\n            var queryStr = '';\r\n\r\n            //add the configured endpoint\r\n            if (isEndpoint) {\r\n                queryStr = base.oConfig.endpoint + (endsWith(base.oConfig.endpoint, '/') ? '' : '/');\r\n            }\r\n\r\n            //combine the uri\r\n            for (var i = 0; i < res.path.length; i++) {\r\n                queryStr += res.path[i].resource;\r\n\r\n                if (res.path[i].get) {\r\n                    queryStr += '(' + (internalParam[res.path[i].get] || res.path[i].get) + ')';\r\n                }\r\n\r\n                queryStr += '/';\r\n            }\r\n\r\n            if (!res.appending) {\r\n                queryStr = queryStr.slice(0, -1);\r\n            }\r\n\r\n            return (queryStr + res.appending + getQuery());\r\n        }\r\n\r\n        // +++\r\n        // internal function which builds the url get parameter\r\n        // +++\r\n        function getQuery() {\r\n            var tempStr = '';\r\n\r\n            for (queryName in resource.query) {\r\n                if (resource.query.hasOwnProperty(queryName) && resource.query[queryName] != null) {\r\n                    tempStr += '&' + resource.queryList[resource.query[queryName]].name + '=' + strFormat(resource.queryList[resource.query[queryName]].value, internalParam);\r\n                }\r\n            }\r\n            if (tempStr.length > 0)\r\n                return ('?' + tempStr.substring(1));\r\n            return (\"\");\r\n        }\r\n\r\n        // +++\r\n        // checks if a route exist and starts the request and adds the parameters\r\n        // +++\r\n        function checkRoute(hash) {\r\n            //literate over the complete routeList\r\n            for (var r = 0; r < routeList.length; r++) {\r\n                //check regex with hash\r\n                if (routeList[r].route.regex.test(hash)) {\r\n\r\n                    //reset the param\r\n                    internalParam = {};\r\n                    var param = {};\r\n\r\n                    //get the matching data\r\n                    var matches = routeList[r].route.regex.exec(hash);\r\n\r\n                    //combine the propArr with the matches\r\n                    if (typeof routeList[r].route.param !== 'undefined') {\r\n                        var i = 1;\r\n                        for (prop in routeList[r].route.param) {\r\n                            internalParam[prop] = matches[i];\r\n                            param[prop.substring(1)] = matches[i];\r\n                            i++;\r\n                        }\r\n                    }\r\n                    else {\r\n                        for (var i = 1; i < matches.length; i++) {\r\n                            internalParam[':' + (i - 1)] = matches[i];\r\n                            param[(i - 1)] = matches[i];\r\n\r\n                        }\r\n                    }\r\n\r\n                    //trigger the before routing func1\r\n                    if (!beforeRoutingFunc(param)) {\r\n                        //start the request if there is a resource defined\r\n                        startRouteRequest(routeList[r].callback, param);\r\n                    }\r\n\r\n                    base.param = param;\r\n                }\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // builds a route regex function based on a given string\r\n        // +++\r\n        function buildRouteRegex(routeStr) {\r\n            //build regex TODO: Can be done before and not on every iteration\r\n            var routeRegex = routeStr;\r\n            if (!(routeStr instanceof RegExp)) {\r\n                //set the hash if needed\r\n                if (base.oConfig.isHashRoute && !startsWith(routeStr, '#')) {\r\n                    routeStr = '#' + routeStr;\r\n                }\r\n                //build up a regex\r\n                var routeArr = routeStr.split('/');\r\n                var param = {};\r\n                for (var i = 0; i < routeArr.length; i++) {\r\n                    if (startsWith(routeArr[i], ':')) {\r\n                        param[routeArr[i]] = true;\r\n                        routeArr[i] = '([\\\\w| |-]+|\\\\[\\W| |-]+)';\r\n                    }\r\n                }\r\n                routeRegex = new RegExp('^' + routeArr.join('/') + '$');\r\n            }\r\n            return ({ regex: routeRegex, param: param });\r\n        }\r\n\r\n        // +++\r\n        // performs a deep copy on an object with JSON\r\n        // +++\r\n        function deepCopy(obj) {\r\n            if (JSON) {\r\n                return (JSON.parse(JSON.stringify(obj)));\r\n            }\r\n            else {\r\n                throwEx('No JSON Support.');\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // takes a script with javascript operations and translates it to odata\r\n        // +++\r\n        function jsToOdata(str) {\r\n            //stripe out the vars\r\n            var regexp = new RegExp(\"'.*?'\", '');\r\n\r\n            var matches = regexp.exec(str);\r\n            str = str.replace(regexp, '{0}');\r\n\r\n            for (key in opertionMapping) {\r\n                str = str.split(key).join(' ' + opertionMapping[key] + ' ');\r\n            }\r\n\r\n            if (matches != null) {\r\n                for (var i = 0; i < matches.length; i++) {\r\n                    str = str.replace('{0}', matches[i])\r\n                }\r\n            }\r\n\r\n            return (str);\r\n        }\r\n\r\n\r\n        // +++\r\n        // adds an new resource to the resouce list\r\n        // +++\r\n        function addNewResource(res) {\r\n            //add the predefined resource to the history resource list\r\n            if (resource)\r\n                resourceList.push(resource);\r\n\r\n            //build the resource array\r\n            if (typeof res === 'string')\r\n                resource = parseUri(res);\r\n            else\r\n                resource = res;\r\n\r\n            //add the default format\r\n            if (!isQuery('$format') && base.oConfig.autoFormat) {\r\n                addQuery('$format', base.oConfig.format);\r\n            }\r\n\r\n            //appendings\r\n            for (var i = 0; i < base.oConfig.appending.length; i++) {\r\n                addQuery(base.oConfig.appending[i].name, base.oConfig.appending[i].value);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // starts a request to the service\r\n        // +++\r\n        function startRequest(callback, errorCallback, isSave, param) {\r\n\r\n            //check if resource is defined\r\n            if (resource === null) {\r\n                throwEx('You must define a resource to perform a get(), post(), put() or delete() function. Define a resource with o(\"YourODataResource\").');\r\n            }\r\n\r\n            //create a CORS ajax Request\r\n            if (resourceList.length === 0 && !isSave) {\r\n                startAjaxReq(createCORSRequest('GET', buildQuery()), null, callback, errorCallback, false,\r\n                    [\r\n                        { name: 'Accept', value: 'application/json,text/plain' },\r\n                        { name: 'Content-Type', value: 'application/json' }\r\n                    ],\r\n                    param, resource.progress);\r\n            }\r\n            //else check if we need to make a $batch request\r\n            else {\r\n                //add the last resource to the history\r\n                resourceList.push(resource);\r\n\r\n                //build a ajax request\r\n                var ajaxReq = createCORSRequest(resource.method, buildQuery());\r\n                //check if we only have one request or we need to force batch because of isXDomainRequest\r\n                if ((countMethod(['POST', 'PATCH', 'DELETE', 'PUT']) <= 1 && isSave) && !isXDomainRequest) {\r\n                    startAjaxReq(ajaxReq, stringify(resource.data), callback, errorCallback, false,\r\n                        [\r\n                            { name: 'Accept', value: 'application/json' },\r\n                            { name: 'Content-Type', value: 'application/json' }\r\n                        ],\r\n                        param, resourceList[resourceList.length - 1].progress);\r\n                    // because the post/put/delete is done, we remove the resource to assume that it will not be posted again\r\n                    removeResource(['POST', 'PATCH', 'DELETE', 'PUT']);\r\n                }\r\n                // do a $batch request\r\n                else {\r\n                    // generate a uui for this batch\r\n                    var guid = generateUUID();\r\n\r\n                    // build the endpoint\r\n                    var endpoint = base.oConfig.endpoint + (endsWith(base.oConfig.endpoint, '/') ? '' : '/') + '$batch';\r\n\r\n                    // appendings\r\n                    for (var i = 0; i < base.oConfig.appending.length; i++) {\r\n                        endpoint += (i === 0 ? '?' : '&') + base.oConfig.appending[i].name + '=' + base.oConfig.appending[i].value;\r\n                    }\r\n\r\n                    // start the request\r\n                    startAjaxReq(createCORSRequest('POST', endpoint), buildBatchBody(guid, isSave), callback, errorCallback, true,\r\n                        // add the necessary headers\r\n                        [{ name: 'Content-Type', value: 'multipart/mixed; boundary=batch_' + guid }],\r\n                        param, resourceList[resourceList.length - 1].progress);\r\n                    if (isSave) {\r\n                        // because the post/put/delete is done, we remove the resource to assume that it will not be posted again\r\n                        removeResource(['POST', 'PUT', 'DELETE']);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // starts a request triggered by a route\r\n        // +++\r\n        function startRouteRequest(callback, param) {\r\n            if (resource.path[0].resource !== \"\")\r\n                startRequest(callback, null, false, param);\r\n            else {\r\n                callback.call(base, param);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // This functions interprets the given resource and returns the base object. It is called by the o-return.\r\n        // +++\r\n        function init(res) {\r\n            //if no resource defined, just return the base object\r\n            if (typeof res === 'undefined')\r\n                return (base);\r\n\r\n            //Check if we have a endpoint and save it to the var\r\n            if ((res.toUpperCase().indexOf('HTTP://') > -1 || res.toUpperCase().indexOf('HTTPS://') > -1)) {\r\n                isEndpoint = false;\r\n            }\r\n            else {\r\n                //check if endpoint is defined\r\n                if (!base.oConfig.endpoint) {\r\n                    throwEx('You can not use resource query without defining your oData endpoint. Use o().config({endpoint:yourEndpoint}) to define your oData endpoint.');\r\n                }\r\n            }\r\n\r\n            //set the route name\r\n            routeName = res;\r\n\r\n            //add the basic resource\r\n            addNewResource(res);\r\n\r\n            return (base);\r\n        }\r\n\r\n        // +++\r\n        // expands a resource by the given resource string (separated by ,)\r\n        // +++\r\n        function expandResource(expandStr) {\r\n            if (isQuery('$expand')) {\r\n                resource.queryList[resource.query.$expand].value += ',' + expandStr;\r\n                resource.queryList[resource.query.$expand].original = resource.queryList[resource.query.$expand].value;\r\n            }\r\n            else {\r\n                addQuery('$expand', expandStr, expandStr);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // internal function to parse the Uri and extrude the resource\r\n        // +++\r\n        function parseUri(resource) {\r\n            var resSplit = resource.split('?');\r\n            var uri = resource;\r\n            var query = '';\r\n            var reqObj = {\r\n                path: [], //array of all without the base\r\n                appending: '', // e.g. $count or $batch\r\n                query: {}, //the query Array --> use base.queryArray\r\n                queryList: [],\r\n                method: 'GET',\r\n                data: null,\r\n                progress: null,\r\n            };\r\n\r\n            //query\r\n            if (resSplit.length === 2) {\r\n                uri = resSplit[0];\r\n                query = resSplit[1];\r\n                var querySplit = query.split('&');\r\n                for (var i = 0; i < querySplit.length; i++) {\r\n                    var pair = querySplit[i].split('=');\r\n                    reqObj.queryList.push({ name: pair[0], value: pair[1] });\r\n                    reqObj.query[pair[0]] = reqObj.queryList.length - 1;\r\n                }\r\n            }\r\n\r\n            //uri\r\n            var uriSplit = uri.split('/');\r\n            for (var i = 0; i < uriSplit.length; i++) {\r\n                if (startsWith(uriSplit[i], '$') && uriSplit[i] !== '$link') {\r\n                    reqObj.appending = uriSplit[i];\r\n                }\r\n                else {\r\n                    var index = uriSplit[i].split('(');\r\n                    if (index.length === 1 || startsWith(uriSplit[i], '(')) {\r\n                        reqObj.path.push({ 'resource': uriSplit[i], 'get': null });\r\n                    }\r\n                    else {\r\n                        reqObj.path.push({ 'resource': index[0], 'get': index[1].substring(0, index[1].length - 1) });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return (reqObj);\r\n        }\r\n\r\n        // +++\r\n        // internal function to add a query parameter\r\n        // +++\r\n        function addQuery(queryName, queryValue, queryOriginal, queryPseudonym) {\r\n            queryOriginal = queryOriginal || null;\r\n            resource.queryList.push({ name: queryName, value: queryValue, original: queryOriginal });\r\n            resource.query[queryPseudonym || queryName] = resource.queryList.length - 1;\r\n        }\r\n\r\n        // +++\r\n        // internal function to append a query parameter\r\n        // +++\r\n        function appendQuery(queryName, queryValue, queryOriginal, appendType, queryPseudonym) {\r\n            queryOriginal = queryOriginal || null;\r\n            appendType = appendType || ' or ';\r\n            queryName = queryPseudonym || queryName;\r\n            resource.queryList[resource.query[queryName]].value = '(' + resource.queryList[resource.query[queryName]].value + ')' + appendType + '(' + queryValue + ')';\r\n            if (queryOriginal)\r\n                resource.queryList[resource.query[queryName]].original = resource.queryList[resource.query[queryName]].value;\r\n        }\r\n\r\n        // +++\r\n        // internal function to remove a query parameter\r\n        // +++\r\n        function removeQuery(queryName) {\r\n            resource.query[queryName] = null;\r\n        }\r\n\r\n        // +++\r\n        // internal function to check if a query exist. Otherwith throwEx a exception\r\n        // queries: Could be an array or an string\r\n        // returns true if\r\n        // +++\r\n        function isQueryThrowEx(queries) {\r\n            if (isQuery(queries)) {\r\n                var queryName = queries;\r\n                if (isArray(queryName)) {\r\n                    queryName = queryName.join(\",\");\r\n                }\r\n                throwEx('There is already a depending query. You can not use them together/twice: ' + queryName)\r\n                return (true);\r\n            }\r\n            return (false);\r\n        }\r\n\r\n        // +++\r\n        // internal function to check if a query exist\r\n        // queries:  Could be an array or an string\r\n        // returns true if the query is already in the query array\r\n        // +++\r\n        function isQuery(queries) {\r\n            var queryNames = (isArray(queries) ? queries : [queries]);\r\n            var isIn = false;\r\n            for (var i = 0; i < queryNames.length; i++) {\r\n                if (resource.query.hasOwnProperty(queryNames[i])) {\r\n                    isIn = true;\r\n                }\r\n            }\r\n            return (isIn);\r\n        }\r\n\r\n        // +++\r\n        // returns a  RFC4122 version 4 compliant  UUID\r\n        // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\r\n        // +++\r\n        function generateUUID() {\r\n            var d = new Date().getTime();\r\n            var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n                var r = (d + Math.random() * 16) % 16 | 0;\r\n                d = Math.floor(d / 16);\r\n                return (c == 'x' ? r : (r & 0x7 | 0x8)).toString(16);\r\n            });\r\n            return uuid;\r\n        }\r\n\r\n        // +++\r\n        // Checks if a value is positiv and a integer\r\n        // +++\r\n        function checkEmpty(str, throwName) {\r\n            if (typeof str !== 'undefined' && str !== null && str.length > 0)\r\n                return (str);\r\n            else\r\n                throwEx(throwName + ': Parameter must be set.');\r\n        }\r\n\r\n        // +++\r\n        // Helper function for trying to parse from this page: http://pietschsoft.com/post/2008/01/14/JavaScript-intTryParse-Equivalent\r\n        // +++\r\n        function tryParseInt(str, defaultValue) {\r\n            if (typeof str === 'number')\r\n                return (str);\r\n            var retValue = defaultValue;\r\n            if (str) {\r\n                if (str.length > 0) {\r\n                    if (!isNaN(str)) {\r\n                        retValue = parseInt(str);\r\n                    }\r\n                }\r\n            }\r\n            return (retValue);\r\n        }\r\n\r\n        // +++\r\n        // helper to count the current length of all methods in the resourceList\r\n        // +++\r\n        function countMethod(methodNames) {\r\n            var count = 0;\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                if (methodNames.indexOf(resourceList[i].method) > -1)\r\n                    count++;\r\n            }\r\n            return (count);\r\n        }\r\n\r\n        // +++\r\n        // removes resources out of the resourceList by it's method name\r\n        // +++\r\n        function removeResource(methodNames) {\r\n            //TODO:  Add a future detection here for .filter() can help to increase performance. This is a overall function to work in all common browsers. A better way is to use .filter(), but it is not supported by all browsers.\r\n            var spliceArr = [];\r\n            //search for them\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                if (methodNames.indexOf(resourceList[i].method) > -1)\r\n                    spliceArr.push(i);\r\n            }\r\n            //and after that, remove them by reverse looping\r\n            for (var i = spliceArr.length - 1; i >= 0; i--) {\r\n                resourceList.splice(spliceArr[i], 1);\r\n            }\r\n            //pack the last resource in the current resource\r\n            if (resourceList[0])\r\n                resource = resourceList[0];\r\n        }\r\n\r\n\r\n        // +++\r\n        // helper that stringify data. Checks for JSON support\r\n        // +++\r\n        function stringify(data) {\r\n            if (JSON)\r\n                return (JSON.stringify(data));\r\n            else {\r\n                //Throw exception\r\n                throwEx('No JSON support.');\r\n                return (data);\r\n            }\r\n        }\r\n\r\n        // +++\r\n        // Helper function to check if a given object is an array\r\n        // +++\r\n        function isArray(obj) {\r\n            //fall back for older browsers\r\n            if (typeof Array.isArray === 'undefined') {\r\n                return (obj.toString() === '[object Array]');\r\n            }\r\n            //the checking\r\n            return (Array.isArray(obj));\r\n        }\r\n\r\n        // +++\r\n        // helper function to check if a string ends with something\r\n        // +++\r\n        function endsWith(str, suffix) {\r\n            return (str ? str.indexOf(suffix, str.length - suffix.length) !== -1 : false);\r\n        }\r\n\r\n        // +++\r\n        // helper function to check if a string starts with something\r\n        // +++\r\n        function startsWith(s, str) {\r\n            return (s.indexOf(str) === 0);\r\n        }\r\n\r\n        // +++\r\n        // Throws an exception\r\n        // +++\r\n        function throwEx(msg) {\r\n            function oException(msg) {\r\n                this.message = msg;\r\n                this.name = 'o.js exception';\r\n            }\r\n            oException.prototype = new Error();\r\n            if (base.oConfig.strictMode === true)\r\n                throw new oException(msg);\r\n            else\r\n                console.log('o.js exception: ' + msg);\r\n        }\r\n\r\n        // +++\r\n        // builds a oData $batch http body\r\n        // +++\r\n        function buildBatchBody(batchGuid, isSave) {\r\n            var body = '';\r\n            var changsetGuid = generateUUID();\r\n            var isChangeset = false;\r\n            if (isSave) {\r\n                body += '--batch_' + batchGuid + '\\n';\r\n                body += 'Content-Type: multipart/mixed; boundary=changeset_' + changsetGuid + '\\n\\n';\r\n            }\r\n\r\n            var hostname = null;\r\n            if (base.oConfig.endpoint !== null) {\r\n                //find & remove protocol (http, https etc.) and get hostname\r\n                if (base.oConfig.endpoint.indexOf(\"://\") > -1) {\r\n                    hostname = base.oConfig.endpoint.split('/')[2];\r\n                } else {\r\n                    hostname = base.oConfig.endpoint.split('/')[0];\r\n                }\r\n                //find & remove port number\r\n                hostname = hostname.split(':')[0];\r\n            }\r\n\r\n            //loop over the resourceList\r\n            for (var i = 0; i < resourceList.length; i++) {\r\n                var res = resourceList[i];\r\n                //set the current resource to the resouceList-Element resource to enable addQuery and expand functions\r\n                resource = res;\r\n                //only do get if not saving is choosen\r\n                if (res.method === 'GET' && !isSave) {\r\n                    body += '--batch_' + batchGuid + '\\n';\r\n                    body += 'Content-Type: application/http\\n';\r\n                    body += 'Content-Transfer-Encoding: binary\\n\\n';\r\n                    body += res.method + ' ' + buildQuery(res) + ' HTTP/1.1\\n';\r\n                    body += 'Host: ' + hostname + '\\n';\r\n\r\n                    for (var k = 0; k < base.oConfig.headers.length; k++) {\r\n                        var header = base.oConfig.headers[k];\r\n                        body += header.name + ': ' + header.value + '\\n';\r\n                    }\r\n\r\n                    body += '\\n';\r\n                }\r\n                //do POST if the base.save() function was called\r\n                //TODO:  || res.method==='PUT' || res.method==='DELETE'\r\n                else if ((res.method === 'POST' || res.method === 'PUT' || res.method === 'PATCH' || res.method === 'DELETE') && isSave) {\r\n                    //var stringData = stringify(res.data);\r\n                    body += '--changeset_' + changsetGuid + '\\n';\r\n                    body += 'Content-Type: application/http\\n';\r\n                    body += 'Content-Transfer-Encoding: binary\\n';\r\n                    body += 'Content-ID:' + i + 1 + '\\n\\n'; //This ID can be referenced $1/Customer\r\n                    body += res.method + ' ' + buildQuery(res) + ' HTTP/1.1\\n';\r\n                    body += 'Host: ' + hostname + '\\n';\r\n\r\n                    for (var k = 0; k < base.oConfig.headers.length; k++) {\r\n                        var header = base.oConfig.headers[k];\r\n                        body += header.name + ': ' + header.value + '\\n';\r\n                    }\r\n\r\n                    body += 'Content-Type: application/json\\n';\r\n                    //body += 'Content-Length:' + stringData.length + '\\n';\r\n                    body += '\\n' + stringify(resource.data) + '\\n\\n\\n';\r\n                    isChangeset = true;\r\n                }\r\n            }\r\n            if (isChangeset)\r\n                body += '--changeset_' + changsetGuid + '--\\n\\n';\r\n            body += '--batch_' + batchGuid + '--';\r\n\r\n            return (body);\r\n        }\r\n\r\n        // +++\r\n        // start a ajax request. data should be null if nothing to send\r\n        // +++\r\n        function startAjaxReq(ajaxRequest, data, callback, errorCallback, isBatch, headers, param, progress) {\r\n\r\n            //if start loading function is set call it\r\n            if (base.oConfig.start && overideLoading == null) {\r\n                base.oConfig.openAjaxRequests++;\r\n                base.oConfig.start();\r\n            }\r\n            if (overideLoading && overideLoading[0]) {\r\n                overideLoading[0](true);\r\n            }\r\n\r\n            //save the base element into a temp base element\r\n            var tempBase = base;\r\n\r\n            // for ie 9 and 8\r\n            if (isXDomainRequest) {\r\n                ajaxRequest.onload = function (e) {\r\n                    ajaxRequest.readyState = 4;\r\n                    ajaxRequest.status = 200;\r\n                    ajaxRequest.onreadystatechange();\r\n                };\r\n                ajaxRequest.onerror = function (e) {\r\n                    ajaxRequest.readyState = 0;\r\n                    ajaxRequest.status = 400;\r\n                    ajaxRequest.onreadystatechange();\r\n                };\r\n            }\r\n            else if (typeof progress === 'function') {\r\n                ajaxRequest.onprogress = progress;\r\n            }\r\n\r\n            ajaxRequest.onreadystatechange = function () {\r\n                //check the http status\r\n                if (ajaxRequest.readyState === 4) {\r\n                    if (ajaxRequest.status >= 200 && ajaxRequest.status < 300) {\r\n\r\n                        //dealing with the response\r\n                        if (ajaxRequest.status !== 204) {\r\n                            if (!isBatch) {\r\n                                parseResponse(ajaxRequest.responseText, tempBase);\r\n                                //callback.call(tempBase,tempBase.data);\r\n                            }\r\n                            //else, handling a $batch response\r\n                            else {\r\n                                var dataArray = [];\r\n                                var regex = /({[\\s\\S]*?--batchresponse_)/g;\r\n                                var result;\r\n                                do {\r\n                                    result = regex.exec(ajaxRequest.responseText);\r\n                                    if (result) {\r\n                                        parseResponse(result[0].substring(0, result[0].length - 16), tempBase);\r\n                                        dataArray.push(tempBase.data);\r\n                                    }\r\n\r\n                                } while (result);\r\n\r\n                                tempBase.data = dataArray;\r\n                            }\r\n                        }\r\n\r\n                        //call the Callback (check for Q-promise)\r\n                        if (currentPromise) {\r\n                            currentPromise.resolve(tempBase);\r\n                        }\r\n                        if (typeof callback === 'function') {\r\n                            callback.call(tempBase, tempBase.data, param);\r\n                        }\r\n                    }\r\n                    else {\r\n                        try {\r\n                            var errResponse = ajaxRequest.responseText;\r\n\r\n                            if (JSON && ajaxRequest.responseText != \"\")\r\n                                errResponse = JSON.parse(ajaxRequest.responseText);\r\n\r\n                            if (errResponse !== '' && errResponse['odata.error']) {\r\n                                var errorMsg = errResponse['odata.error'].message.value + ' | HTTP Status: ' + ajaxRequest.status + ' | oData Code: ' + errResponse['odata.error'].code;\r\n                                throwEx(errorMsg);\r\n                            }\r\n                            else {\r\n                                throwEx('Request to ' + buildQuery() + ' failed with HTTP status ' + (ajaxRequest.status || 404) + '.');\r\n                            }\r\n                        } catch (ex) {\r\n                            endLoading(tempBase, true, ajaxRequest.status || 404, ajaxRequest.responseText);\r\n                            if (typeof errorCallback === 'function') {\r\n                                errorCallback(ajaxRequest.status || 404, ex)\r\n                            }\r\n                            else if (currentPromise) {\r\n                                ex.status = (ajaxRequest.status || 404);\r\n                                currentPromise.reject(ex);\r\n                            }\r\n                            else {\r\n                                throw ex;\r\n                            }\r\n                        }\r\n                    }\r\n                    //end the loading when everything is okay\r\n                    endLoading(tempBase, false);\r\n                }\r\n            }\r\n\r\n            //check if we need to preflight the request (only if basic auth and isAsync)\r\n            if (base.oConfig.username && base.oConfig.password) {\r\n                //ajaxRequest.withCredentials=true;\r\n                if (isXDomainRequest) {\r\n                    throwEx('CORS and Basic Auth is not supported for IE <= 9. Try to set isCors:false in the OData config if you do not need CORS support.');\r\n                }\r\n                ajaxRequest.setRequestHeader('Authorization', 'Basic ' + encodeBase64(base.oConfig.username + ':' + base.oConfig.password));\r\n            }\r\n\r\n            //check if not IE 9 or 8\r\n            if (!isXDomainRequest) {\r\n                //set headers\r\n                if (headers) {\r\n                    //normal headers\r\n                    for (var i = 0; i < headers.length; i++) {\r\n                        ajaxRequest.setRequestHeader(headers[i].name, headers[i].value);\r\n                    }\r\n                }\r\n\r\n                //additional headers\r\n                if (base.oConfig.headers.length > 0) {\r\n                    //TODO: merge both normal and additional headers?!\r\n                    for (var i = 0; i < base.oConfig.headers.length; i++) {\r\n                        ajaxRequest.setRequestHeader(base.oConfig.headers[i].name, base.oConfig.headers[i].value);\r\n                    }\r\n                }\r\n            }\r\n            ajaxRequest.send(data);\r\n        }\r\n\r\n        //+++\r\n        // Cancels the loading state\r\n        //+++\r\n        function endLoading(base, isError, status, msg) {\r\n            if (base.oConfig.ready && overideLoading == null) {\r\n                base.oConfig.openAjaxRequests--;\r\n                if (base.oConfig.openAjaxRequests <= 0) {\r\n                    base.oConfig.ready();\r\n                }\r\n            }\r\n\r\n            if (overideLoading && overideLoading[1]) {\r\n                overideLoading[1](false);\r\n            }\r\n\r\n            if (base.oConfig.error && isError) {\r\n                base.oConfig.error(status, msg);\r\n            }\r\n        }\r\n\r\n\r\n        // +++\r\n        // this function parses a normal response to a JSON response\r\n        // +++\r\n        function parseResponse(response, tempBase) {\r\n            var count = tryParseInt(response, -1);\r\n            if (count !== -1) {\r\n                tempBase.data = count;\r\n            }\r\n            else {\r\n                if (JSON && response !== '') {\r\n                    var data = JSON.parse(response);\r\n                    tempBase.raw = data;\r\n                    if (data.hasOwnProperty('value')) {\r\n                        if (isQuery(['$first']) && data.value.length && data.value.length <= 1) {\r\n                            tempBase.data = data.value[0];\r\n                        }\r\n                        else {\r\n                            tempBase.data = data.value;\r\n                        }\r\n                        if (data.hasOwnProperty('odata.count') || data.hasOwnProperty('@odata.count')) {\r\n                            tempBase.inlinecount = data['odata.count'] || data['@odata.count'];\r\n                        }\r\n                    }\r\n                    else {\r\n                        tempBase.data = data;\r\n                    }\r\n                    resource.data = tempBase.data;\r\n                }\r\n                else {\r\n                    tempBase.data = response;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // +++\r\n        // Create the XHR object with CORS support\r\n        // +++\r\n        function createCORSRequest(method, url) {\r\n            var xhr = null;\r\n\r\n            //if no window assume node.js\r\n            if (typeof window === 'undefined') {\r\n                var Xhr2 = require('xhr2');\r\n                xhr = new Xhr2();\r\n            }\r\n            else {\r\n                xhr = new XMLHttpRequest();\r\n            }\r\n\r\n            if (base.oConfig.isCors && 'withCredentials' in xhr) {\r\n\t\t\t\txhr.withCredentials=true;\r\n                // XHR for Chrome/Firefox/Opera/Safari.\r\n                xhr.open(method, url, base.oConfig.isAsync);\r\n            }\r\n            else if (base.oConfig.isCors && typeof XDomainRequest !== 'undefined') {\r\n                // XDomainRequest for IE.\r\n                xhr = new XDomainRequest();\r\n                // does not support PUT PATCH operations -> Switch to batch\r\n                isXDomainRequest = true;\r\n                if (method == 'GET')\r\n                    xhr.open(method, url);\r\n                else\r\n                    xhr.open('POST', url);\r\n            }\r\n            else {\r\n                // CORS not supported or forced\r\n                xhr.open(method, url, base.oConfig.isAsync);\r\n            }\r\n            return xhr;\r\n        }\r\n\r\n        // +++\r\n        // helper function to format a string with :vars\r\n        // +++\r\n        function strFormat() {\r\n            var str = arguments[0];\r\n            var para = arguments[1];\r\n            for (var p in para) {\r\n                var regex = new RegExp(p, 'g');\r\n                if (typeof str === 'string')\r\n                    str = str.replace(regex, para[p]);\r\n            }\r\n\r\n            return str;\r\n        }\r\n\r\n        //+++\r\n        // encode a string to base64\r\n        // +++\r\n        function encodeBase64(str) {\r\n            var Base64 = {\r\n\r\n                // private property\r\n                _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\r\n\r\n                // private method for encoding\r\n                encode: function (input) {\r\n                    var output = '';\r\n                    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\r\n                    var i = 0;\r\n\r\n                    input = Base64._utf8_encode(input);\r\n\r\n                    while (i < input.length) {\r\n\r\n                        chr1 = input.charCodeAt(i++);\r\n                        chr2 = input.charCodeAt(i++);\r\n                        chr3 = input.charCodeAt(i++);\r\n\r\n                        enc1 = chr1 >> 2;\r\n                        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\r\n                        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\r\n                        enc4 = chr3 & 63;\r\n\r\n                        if (isNaN(chr2)) {\r\n                            enc3 = enc4 = 64;\r\n                        } else if (isNaN(chr3)) {\r\n                            enc4 = 64;\r\n                        }\r\n\r\n                        output = output +\r\n                            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +\r\n                            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);\r\n\r\n                    }\r\n\r\n                    return output;\r\n                },\r\n\r\n\r\n                // private method for UTF-8 encoding\r\n                _utf8_encode: function (string) {\r\n                    string = string.replace(/\\r\\n/g, '\\n');\r\n                    var utftext = '';\r\n\r\n                    for (var n = 0; n < string.length; n++) {\r\n\r\n                        var c = string.charCodeAt(n);\r\n\r\n                        if (c < 128) {\r\n                            utftext += String.fromCharCode(c);\r\n                        }\r\n                        else if ((c > 127) && (c < 2048)) {\r\n                            utftext += String.fromCharCode((c >> 6) | 192);\r\n                            utftext += String.fromCharCode((c & 63) | 128);\r\n                        }\r\n                        else {\r\n                            utftext += String.fromCharCode((c >> 12) | 224);\r\n                            utftext += String.fromCharCode(((c >> 6) & 63) | 128);\r\n                            utftext += String.fromCharCode((c & 63) | 128);\r\n                        }\r\n\r\n                    }\r\n\r\n                    return utftext;\r\n                }\r\n            }\r\n\r\n            return (Base64.encode(str));\r\n        }\r\n\r\n        return (init(res));\r\n    }\r\n\r\n    return o;\r\n}));\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/odata/o.js\n// module id = 571\n// module chunks = 0 3","module.exports = XMLHttpRequest;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/xhr2/lib/browser.js\n// module id = 572\n// module chunks = 0 3","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../../../node_modules/css-loader/index.js?{\\\"minimize\\\":true,\\\"sourceMap\\\":true,\\\"alias\\\":{\\\"../img\\\":\\\"../static/img\\\"}}!../../../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-e231a1e4\\\",\\\"scoped\\\":true,\\\"hasInlineConfig\\\":false}!../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./index.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../../../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"ec996900\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/extract-text-webpack-plugin/dist/loader.js?{\"omit\":1,\"remove\":true}!./node_modules/vue-style-loader!./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true,\"alias\":{\"../img\":\"../static/img\"}}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-e231a1e4\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/modules/supplier/index.vue\n// module id = 617\n// module chunks = 3","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.id, \"\", \"\", {\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"file\":\"index.vue\",\"sourceRoot\":\"\"}]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/css-loader?{\"minimize\":true,\"sourceMap\":true,\"alias\":{\"../img\":\"../static/img\"}}!./node_modules/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-e231a1e4\",\"scoped\":true,\"hasInlineConfig\":false}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0!./src/modules/supplier/index.vue\n// module id = 618\n// module chunks = 3","<template>\n  <div class=\"app\">\n    <AppHeader/>\n    <div class=\"app-body\">\n      <Sidebar :navItems=\"nav\"/>\n      <main class=\"main\">\n        <div class=\"container-fluid\">\n          <router-view></router-view>\n        </div>\n      </main>\n\n    </div>\n    <!--<AppFooter/>-->\n  </div>\n</template>\n\n<script>\n  import nav from './_nav'\n  import { Header as AppHeader, Sidebar } from '../../components/'\n  import { mapGetters } from 'vuex'\n  import { hubConnection } from 'signalr-no-jquery'\n  import store from './store'\n\n  export default {\n    name: 'SupplierContainer',\n    components: {\n      AppHeader,\n      Sidebar\n    },\n    data () {\n      return {\n        nav: nav.items\n      }\n    },\n    computed: {\n      ...mapGetters({\n        supplier: '$_supplier_view/supplier'\n      }),\n      name () {\n        return this.$route.name\n      },\n      list () {\n        return this.$route.matched\n      }\n    },\n    created () {\n      this.$store.registerModule('$_supplier_view', store)\n\n      const connection = hubConnection('http://axiomcredit-001-site1.etempurl.com/signalr')\n      const hubProxy = connection.createHubProxy('chatHub')\n      hubProxy.on('hello', function () {\n        console.log('Hello from the other side')\n      })\n      connection.start({ jsonp: true })\n        .done(function () { console.log('Now connected, connection ID=' + connection.id) })\n        .fail(function () { console.log('Could not connect') })\n    },\n    mounted () {\n      this.$store.dispatch('$_supplier_view/GET_SUPPLIER')\n      // let hubConnection = new HubConnection('http://localhost:29484/signalr/chat')\n    }\n  }\n</script>\n\n<style scoped>\n\n</style>\n\n\n\n// WEBPACK FOOTER //\n// src/modules/supplier/index.vue","export default {\n  items: [\n    {\n      name: 'Profile',\n      icon: 'icon-user'\n    },\n    {\n      name: 'Notifications',\n      icon: 'icon-bell'\n    },\n    {\n      name: 'Messages',\n      icon: 'icon-speedometer'\n    }\n  ]\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/supplier/_nav.js","'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar jQueryShim = require('./jQueryShim');\r\n\r\n/* jquery.signalR.core.js */\r\n/*global window:false */\r\n/*!\r\n * ASP.NET SignalR JavaScript Library v2.2.1\r\n * http://signalr.net/\r\n *\r\n * Copyright (c) .NET Foundation. All rights reserved.\r\n * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n *\r\n */\r\n\r\n/// <reference path=\"Scripts/jquery-1.6.4.js\" />\r\n/// <reference path=\"jquery.signalR.version.js\" />\r\n(function ($, window, undefined) {\r\n\r\n    var resources = {\r\n        nojQuery: \"jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.\",\r\n        noTransportOnInit: \"No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.\",\r\n        errorOnNegotiate: \"Error during negotiation request.\",\r\n        stoppedWhileLoading: \"The connection was stopped during page load.\",\r\n        stoppedWhileNegotiating: \"The connection was stopped during the negotiate request.\",\r\n        errorParsingNegotiateResponse: \"Error parsing negotiate response.\",\r\n        errorDuringStartRequest: \"Error during start request. Stopping the connection.\",\r\n        stoppedDuringStartRequest: \"The connection was stopped during the start request.\",\r\n        errorParsingStartResponse: \"Error parsing start response: '{0}'. Stopping the connection.\",\r\n        invalidStartResponse: \"Invalid start response: '{0}'. Stopping the connection.\",\r\n        protocolIncompatible: \"You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.\",\r\n        sendFailed: \"Send failed.\",\r\n        parseFailed: \"Failed at parsing response: {0}\",\r\n        longPollFailed: \"Long polling request failed.\",\r\n        eventSourceFailedToConnect: \"EventSource failed to connect.\",\r\n        eventSourceError: \"Error raised by EventSource\",\r\n        webSocketClosed: \"WebSocket closed.\",\r\n        pingServerFailedInvalidResponse: \"Invalid ping response when pinging server: '{0}'.\",\r\n        pingServerFailed: \"Failed to ping server.\",\r\n        pingServerFailedStatusCode: \"Failed to ping server.  Server responded with status code {0}, stopping the connection.\",\r\n        pingServerFailedParse: \"Failed to parse ping server response, stopping the connection.\",\r\n        noConnectionTransport: \"Connection is in an invalid state, there is no transport active.\",\r\n        webSocketsInvalidState: \"The Web Socket transport is in an invalid state, transitioning into reconnecting.\",\r\n        reconnectTimeout: \"Couldn't reconnect within the configured timeout of {0} ms, disconnecting.\",\r\n        reconnectWindowTimeout: \"The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection.\"\r\n    };\r\n\r\n    if (typeof $ !== \"function\") {\r\n        // no jQuery!\r\n        throw new Error(resources.nojQuery);\r\n    }\r\n\r\n    var _signalR,\r\n        _connection,\r\n        _pageLoaded = window.document.readyState === \"complete\",\r\n        _pageWindow = $(window),\r\n        _negotiateAbortText = \"__Negotiate Aborted__\",\r\n        events = {\r\n        onStart: \"onStart\",\r\n        onStarting: \"onStarting\",\r\n        onReceived: \"onReceived\",\r\n        onError: \"onError\",\r\n        onConnectionSlow: \"onConnectionSlow\",\r\n        onReconnecting: \"onReconnecting\",\r\n        onReconnect: \"onReconnect\",\r\n        onStateChanged: \"onStateChanged\",\r\n        onDisconnect: \"onDisconnect\"\r\n    },\r\n        ajaxDefaults = {\r\n        processData: true,\r\n        timeout: null,\r\n        async: true,\r\n        global: false,\r\n        cache: false\r\n    },\r\n        _log = function _log(msg, logging) {\r\n        if (logging === false) {\r\n            return;\r\n        }\r\n        var m;\r\n        if (typeof window.console === \"undefined\") {\r\n            return;\r\n        }\r\n        m = \"[\" + new Date().toTimeString() + \"] SignalR: \" + msg;\r\n        if (window.console.debug) {\r\n            window.console.debug(m);\r\n        } else if (window.console.log) {\r\n            window.console.log(m);\r\n        }\r\n    },\r\n        changeState = function changeState(connection, expectedState, newState) {\r\n        if (expectedState === connection.state) {\r\n            connection.state = newState;\r\n\r\n            $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n        isDisconnecting = function isDisconnecting(connection) {\r\n        return connection.state === _signalR.connectionState.disconnected;\r\n    },\r\n        supportsKeepAlive = function supportsKeepAlive(connection) {\r\n        return connection._.keepAliveData.activated && connection.transport.supportsKeepAlive(connection);\r\n    },\r\n        configureStopReconnectingTimeout = function configureStopReconnectingTimeout(connection) {\r\n        var stopReconnectingTimeout, onReconnectTimeout;\r\n\r\n        // Check if this connection has already been configured to stop reconnecting after a specified timeout.\r\n        // Without this check if a connection is stopped then started events will be bound multiple times.\r\n        if (!connection._.configuredStopReconnectingTimeout) {\r\n            onReconnectTimeout = function onReconnectTimeout(connection) {\r\n                var message = _signalR._.format(_signalR.resources.reconnectTimeout, connection.disconnectTimeout);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [_signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n            };\r\n\r\n            connection.reconnecting(function () {\r\n                var connection = this;\r\n\r\n                // Guard against state changing in a previous user defined even handler\r\n                if (connection.state === _signalR.connectionState.reconnecting) {\r\n                    stopReconnectingTimeout = window.setTimeout(function () {\r\n                        onReconnectTimeout(connection);\r\n                    }, connection.disconnectTimeout);\r\n                }\r\n            });\r\n\r\n            connection.stateChanged(function (data) {\r\n                if (data.oldState === _signalR.connectionState.reconnecting) {\r\n                    // Clear the pending reconnect timeout check\r\n                    window.clearTimeout(stopReconnectingTimeout);\r\n                }\r\n            });\r\n\r\n            connection._.configuredStopReconnectingTimeout = true;\r\n        }\r\n    };\r\n\r\n    _signalR = function signalR(url, qs, logging) {\r\n        /// <summary>Creates a new SignalR connection for the given url</summary>\r\n        /// <param name=\"url\" type=\"String\">The URL of the long polling endpoint</param>\r\n        /// <param name=\"qs\" type=\"Object\">\r\n        ///     [Optional] Custom querystring parameters to add to the connection URL.\r\n        ///     If an object, every non-function member will be added to the querystring.\r\n        ///     If a string, it's added to the QS as specified.\r\n        /// </param>\r\n        /// <param name=\"logging\" type=\"Boolean\">\r\n        ///     [Optional] A flag indicating whether connection logging is enabled to the browser\r\n        ///     console/log. Defaults to false.\r\n        /// </param>\r\n\r\n        return new _signalR.fn.init(url, qs, logging);\r\n    };\r\n\r\n    _signalR._ = {\r\n        defaultContentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\r\n        ieVersion: function () {\r\n            var version, matches;\r\n\r\n            if (window.navigator.appName === 'Microsoft Internet Explorer') {\r\n                // Check if the user agent has the pattern \"MSIE (one or more numbers).(one or more numbers)\";\r\n                matches = /MSIE ([0-9]+\\.[0-9]+)/.exec(window.navigator.userAgent);\r\n\r\n                if (matches) {\r\n                    version = window.parseFloat(matches[1]);\r\n                }\r\n            }\r\n\r\n            // undefined value means not IE\r\n            return version;\r\n        }(),\r\n\r\n        error: function error(message, source, context) {\r\n            var e = new Error(message);\r\n            e.source = source;\r\n\r\n            if (typeof context !== \"undefined\") {\r\n                e.context = context;\r\n            }\r\n\r\n            return e;\r\n        },\r\n\r\n        transportError: function transportError(message, transport, source, context) {\r\n            var e = this.error(message, source, context);\r\n            e.transport = transport ? transport.name : undefined;\r\n            return e;\r\n        },\r\n\r\n        format: function format() {\r\n            /// <summary>Usage: format(\"Hi {0}, you are {1}!\", \"Foo\", 100) </summary>\r\n            var s = arguments[0];\r\n            for (var i = 0; i < arguments.length - 1; i++) {\r\n                s = s.replace(\"{\" + i + \"}\", arguments[i + 1]);\r\n            }\r\n            return s;\r\n        },\r\n\r\n        firefoxMajorVersion: function firefoxMajorVersion(userAgent) {\r\n            // Firefox user agents: http://useragentstring.com/pages/Firefox/\r\n            var matches = userAgent.match(/Firefox\\/(\\d+)/);\r\n            if (!matches || !matches.length || matches.length < 2) {\r\n                return 0;\r\n            }\r\n            return parseInt(matches[1], 10 /* radix */);\r\n        },\r\n\r\n        configurePingInterval: function configurePingInterval(connection) {\r\n            var config = connection._.config,\r\n                onFail = function onFail(error) {\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n            };\r\n\r\n            if (config && !connection._.pingIntervalId && config.pingInterval) {\r\n                connection._.pingIntervalId = window.setInterval(function () {\r\n                    _signalR.transports._logic.pingServer(connection).fail(onFail);\r\n                }, config.pingInterval);\r\n            }\r\n        }\r\n    };\r\n\r\n    _signalR.events = events;\r\n\r\n    _signalR.resources = resources;\r\n\r\n    _signalR.ajaxDefaults = ajaxDefaults;\r\n\r\n    _signalR.changeState = changeState;\r\n\r\n    _signalR.isDisconnecting = isDisconnecting;\r\n\r\n    _signalR.connectionState = {\r\n        connecting: 0,\r\n        connected: 1,\r\n        reconnecting: 2,\r\n        disconnected: 4\r\n    };\r\n\r\n    _signalR.hub = {\r\n        start: function start() {\r\n            // This will get replaced with the real hub connection start method when hubs is referenced correctly\r\n            throw new Error(\"SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.\");\r\n        }\r\n    };\r\n\r\n    // .on() was added in version 1.7.0, .load() was removed in version 3.0.0 so we fallback to .load() if .on() does\r\n    // not exist to not break existing applications\r\n    if (typeof _pageWindow.on == \"function\") {\r\n        _pageWindow.on(\"load\", function () {\r\n            _pageLoaded = true;\r\n        });\r\n    } else {\r\n        _pageWindow.load(function () {\r\n            _pageLoaded = true;\r\n        });\r\n    }\r\n\r\n    function validateTransport(requestedTransport, connection) {\r\n        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>\r\n        /// <param name=\"requestedTransport\" type=\"Object\">The designated transports that the user has specified.</param>\r\n        /// <param name=\"connection\" type=\"signalR\">The connection that will be using the requested transports.  Used for logging purposes.</param>\r\n        /// <returns type=\"Object\" />\r\n\r\n        if ($.isArray(requestedTransport)) {\r\n            // Go through transport array and remove an \"invalid\" tranports\r\n            for (var i = requestedTransport.length - 1; i >= 0; i--) {\r\n                var transport = requestedTransport[i];\r\n                if ($.type(transport) !== \"string\" || !_signalR.transports[transport]) {\r\n                    connection.log(\"Invalid transport: \" + transport + \", removing it from the transports list.\");\r\n                    requestedTransport.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Verify we still have transports left, if we dont then we have invalid transports\r\n            if (requestedTransport.length === 0) {\r\n                connection.log(\"No transports remain within the specified transport array.\");\r\n                requestedTransport = null;\r\n            }\r\n        } else if (!_signalR.transports[requestedTransport] && requestedTransport !== \"auto\") {\r\n            connection.log(\"Invalid transport: \" + requestedTransport.toString() + \".\");\r\n            requestedTransport = null;\r\n        } else if (requestedTransport === \"auto\" && _signalR._.ieVersion <= 8) {\r\n            // If we're doing an auto transport and we're IE8 then force longPolling, #1764\r\n            return [\"longPolling\"];\r\n        }\r\n\r\n        return requestedTransport;\r\n    }\r\n\r\n    function getDefaultPort(protocol) {\r\n        if (protocol === \"http:\") {\r\n            return 80;\r\n        } else if (protocol === \"https:\") {\r\n            return 443;\r\n        }\r\n    }\r\n\r\n    function addDefaultPort(protocol, url) {\r\n        // Remove ports  from url.  We have to check if there's a / or end of line\r\n        // following the port in order to avoid removing ports such as 8080.\r\n        if (url.match(/:\\d+$/)) {\r\n            return url;\r\n        } else {\r\n            return url + \":\" + getDefaultPort(protocol);\r\n        }\r\n    }\r\n\r\n    function ConnectingMessageBuffer(connection, drainCallback) {\r\n        var that = this,\r\n            buffer = [];\r\n\r\n        that.tryBuffer = function (message) {\r\n            if (connection.state === $.signalR.connectionState.connecting) {\r\n                buffer.push(message);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        that.drain = function () {\r\n            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                while (buffer.length > 0) {\r\n                    drainCallback(buffer.shift());\r\n                }\r\n            }\r\n        };\r\n\r\n        that.clear = function () {\r\n            buffer = [];\r\n        };\r\n    }\r\n\r\n    _signalR.fn = _signalR.prototype = {\r\n        init: function init(url, qs, logging) {\r\n            var $connection = $(this);\r\n\r\n            this.url = url;\r\n            this.qs = qs;\r\n            this.lastError = null;\r\n            this._ = {\r\n                keepAliveData: {},\r\n                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {\r\n                    $connection.triggerHandler(events.onReceived, [message]);\r\n                }),\r\n                lastMessageAt: new Date().getTime(),\r\n                lastActiveAt: new Date().getTime(),\r\n                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,\r\n                beatHandle: null,\r\n                totalTransportConnectTimeout: 0 // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout\r\n            };\r\n            if (typeof logging === \"boolean\") {\r\n                this.logging = logging;\r\n            }\r\n        },\r\n\r\n        _parseResponse: function _parseResponse(response) {\r\n            var that = this;\r\n\r\n            if (!response) {\r\n                return response;\r\n            } else if (typeof response === \"string\") {\r\n                return that.json.parse(response);\r\n            } else {\r\n                return response;\r\n            }\r\n        },\r\n\r\n        _originalJson: window.JSON,\r\n\r\n        json: window.JSON,\r\n\r\n        isCrossDomain: function isCrossDomain(url, against) {\r\n            /// <summary>Checks if url is cross domain</summary>\r\n            /// <param name=\"url\" type=\"String\">The base URL</param>\r\n            /// <param name=\"against\" type=\"Object\">\r\n            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.\r\n            ///     If specified it must contain a protocol and a host property.\r\n            /// </param>\r\n            var link;\r\n\r\n            url = $.trim(url);\r\n\r\n            against = against || window.location;\r\n\r\n            if (url.indexOf(\"http\") !== 0) {\r\n                return false;\r\n            }\r\n\r\n            // Create an anchor tag.\r\n            link = window.document.createElement(\"a\");\r\n            link.href = url;\r\n\r\n            // When checking for cross domain we have to special case port 80 because the window.location will remove the\r\n            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);\r\n        },\r\n\r\n        ajaxDataType: \"text\",\r\n\r\n        contentType: \"application/json; charset=UTF-8\",\r\n\r\n        logging: false,\r\n\r\n        state: _signalR.connectionState.disconnected,\r\n\r\n        clientProtocol: \"1.5\",\r\n\r\n        reconnectDelay: 2000,\r\n\r\n        transportConnectTimeout: 0,\r\n\r\n        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)\r\n\r\n        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request\r\n\r\n        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout\r\n\r\n        start: function start(options, callback) {\r\n            /// <summary>Starts the connection</summary>\r\n            /// <param name=\"options\" type=\"Object\">Options map</param>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection has started</param>\r\n            var connection = this,\r\n                config = {\r\n                pingInterval: 300000,\r\n                waitForPageLoad: true,\r\n                transport: \"auto\",\r\n                jsonp: false\r\n            },\r\n                _initialize,\r\n                deferred = connection._deferral || $.Deferred(),\r\n                // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it\r\n            parser = window.document.createElement(\"a\");\r\n\r\n            connection.lastError = null;\r\n\r\n            // Persist the deferral so that if start is called multiple times the same deferral is used.\r\n            connection._deferral = deferred;\r\n\r\n            if (!connection.json) {\r\n                // no JSON!\r\n                throw new Error(\"SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.\");\r\n            }\r\n\r\n            if ($.type(options) === \"function\") {\r\n                // Support calling with single callback parameter\r\n                callback = options;\r\n            } else if ($.type(options) === \"object\") {\r\n                $.extend(config, options);\r\n                if ($.type(config.callback) === \"function\") {\r\n                    callback = config.callback;\r\n                }\r\n            }\r\n\r\n            config.transport = validateTransport(config.transport, connection);\r\n\r\n            // If the transport is invalid throw an error and abort start\r\n            if (!config.transport) {\r\n                throw new Error(\"SignalR: Invalid transport(s) specified, aborting start.\");\r\n            }\r\n\r\n            connection._.config = config;\r\n\r\n            // Check to see if start is being called prior to page load\r\n            // If waitForPageLoad is true we then want to re-direct function call to the window load event\r\n            if (!_pageLoaded && config.waitForPageLoad === true) {\r\n                connection._.deferredStartHandler = function () {\r\n                    connection.start(options, callback);\r\n                };\r\n                _pageWindow.bind(\"load\", connection._.deferredStartHandler);\r\n\r\n                return deferred.promise();\r\n            }\r\n\r\n            // If we're already connecting just return the same deferral as the original connection start\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                return deferred.promise();\r\n            } else if (changeState(connection, _signalR.connectionState.disconnected, _signalR.connectionState.connecting) === false) {\r\n                // We're not connecting so try and transition into connecting.\r\n                // If we fail to transition then we're either in connected or reconnecting.\r\n\r\n                deferred.resolve(connection);\r\n                return deferred.promise();\r\n            }\r\n\r\n            configureStopReconnectingTimeout(connection);\r\n\r\n            // Resolve the full url\r\n            parser.href = connection.url;\r\n            if (!parser.protocol || parser.protocol === \":\") {\r\n                connection.protocol = window.document.location.protocol;\r\n                connection.host = parser.host || window.document.location.host;\r\n            } else {\r\n                connection.protocol = parser.protocol;\r\n                connection.host = parser.host;\r\n            }\r\n\r\n            connection.baseUrl = connection.protocol + \"//\" + connection.host;\r\n\r\n            // Set the websocket protocol\r\n            connection.wsProtocol = connection.protocol === \"https:\" ? \"wss://\" : \"ws://\";\r\n\r\n            // If jsonp with no/auto transport is specified, then set the transport to long polling\r\n            // since that is the only transport for which jsonp really makes sense.\r\n            // Some developers might actually choose to specify jsonp for same origin requests\r\n            // as demonstrated by Issue #623.\r\n            if (config.transport === \"auto\" && config.jsonp === true) {\r\n                config.transport = \"longPolling\";\r\n            }\r\n\r\n            // If the url is protocol relative, prepend the current windows protocol to the url.\r\n            if (connection.url.indexOf(\"//\") === 0) {\r\n                connection.url = window.location.protocol + connection.url;\r\n                connection.log(\"Protocol relative URL detected, normalizing it to '\" + connection.url + \"'.\");\r\n            }\r\n\r\n            if (this.isCrossDomain(connection.url)) {\r\n                connection.log(\"Auto detected cross domain url.\");\r\n\r\n                if (config.transport === \"auto\") {\r\n                    // TODO: Support XDM with foreverFrame\r\n                    config.transport = [\"webSockets\", \"serverSentEvents\", \"longPolling\"];\r\n                }\r\n\r\n                if (typeof config.withCredentials === \"undefined\") {\r\n                    config.withCredentials = true;\r\n                }\r\n\r\n                // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.\r\n                // i.e. if the browser doesn't supports CORS\r\n                // If it is, ignore any preference to the contrary, and switch to jsonp.\r\n                if (!config.jsonp) {\r\n                    config.jsonp = !$.support.cors;\r\n\r\n                    if (config.jsonp) {\r\n                        connection.log(\"Using jsonp because this browser doesn't support CORS.\");\r\n                    }\r\n                }\r\n\r\n                connection.contentType = _signalR._.defaultContentType;\r\n            }\r\n\r\n            connection.withCredentials = config.withCredentials;\r\n\r\n            connection.ajaxDataType = config.jsonp ? \"jsonp\" : \"text\";\r\n\r\n            $(connection).bind(events.onStart, function (e, data) {\r\n                if ($.type(callback) === \"function\") {\r\n                    callback.call(connection);\r\n                }\r\n                deferred.resolve(connection);\r\n            });\r\n\r\n            connection._.initHandler = _signalR.transports._logic.initHandler(connection);\r\n\r\n            _initialize = function initialize(transports, index) {\r\n                var noTransportError = _signalR._.error(resources.noTransportOnInit);\r\n\r\n                index = index || 0;\r\n                if (index >= transports.length) {\r\n                    if (index === 0) {\r\n                        connection.log(\"No transports supported by the server were selected.\");\r\n                    } else if (index === 1) {\r\n                        connection.log(\"No fallback transports were selected.\");\r\n                    } else {\r\n                        connection.log(\"Fallback transports exhausted.\");\r\n                    }\r\n\r\n                    // No transport initialized successfully\r\n                    $(connection).triggerHandler(events.onError, [noTransportError]);\r\n                    deferred.reject(noTransportError);\r\n                    // Stop the connection if it has connected and move it into the disconnected state\r\n                    connection.stop();\r\n                    return;\r\n                }\r\n\r\n                // The connection was aborted\r\n                if (connection.state === _signalR.connectionState.disconnected) {\r\n                    return;\r\n                }\r\n\r\n                var transportName = transports[index],\r\n                    transport = _signalR.transports[transportName],\r\n                    onFallback = function onFallback() {\r\n                    _initialize(transports, index + 1);\r\n                };\r\n\r\n                connection.transport = transport;\r\n\r\n                try {\r\n                    connection._.initHandler.start(transport, function () {\r\n                        // success\r\n                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials\r\n                        var isFirefox11OrGreater = _signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,\r\n                            asyncAbort = !!connection.withCredentials && isFirefox11OrGreater;\r\n\r\n                        connection.log(\"The start request succeeded. Transitioning to the connected state.\");\r\n\r\n                        if (supportsKeepAlive(connection)) {\r\n                            _signalR.transports._logic.monitorKeepAlive(connection);\r\n                        }\r\n\r\n                        _signalR.transports._logic.startHeartbeat(connection);\r\n\r\n                        // Used to ensure low activity clients maintain their authentication.\r\n                        // Must be configured once a transport has been decided to perform valid ping requests.\r\n                        _signalR._.configurePingInterval(connection);\r\n\r\n                        if (!changeState(connection, _signalR.connectionState.connecting, _signalR.connectionState.connected)) {\r\n                            connection.log(\"WARNING! The connection was not in the connecting state.\");\r\n                        }\r\n\r\n                        // Drain any incoming buffered messages (messages that came in prior to connect)\r\n                        connection._.connectingMessageBuffer.drain();\r\n\r\n                        $(connection).triggerHandler(events.onStart);\r\n\r\n                        // wire the stop handler for when the user leaves the page\r\n                        _pageWindow.bind(\"unload\", function () {\r\n                            connection.log(\"Window unloading, stopping the connection.\");\r\n\r\n                            connection.stop(asyncAbort);\r\n                        });\r\n\r\n                        if (isFirefox11OrGreater) {\r\n                            // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.\r\n                            // #2400\r\n                            _pageWindow.bind(\"beforeunload\", function () {\r\n                                // If connection.stop() runs runs in beforeunload and fails, it will also fail\r\n                                // in unload unless connection.stop() runs after a timeout.\r\n                                window.setTimeout(function () {\r\n                                    connection.stop(asyncAbort);\r\n                                }, 0);\r\n                            });\r\n                        }\r\n                    }, onFallback);\r\n                } catch (error) {\r\n                    connection.log(transport.name + \" transport threw '\" + error.message + \"' when attempting to start.\");\r\n                    onFallback();\r\n                }\r\n            };\r\n\r\n            var url = connection.url + \"/negotiate\",\r\n                onFailed = function onFailed(error, connection) {\r\n                var err = _signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);\r\n\r\n                $(connection).triggerHandler(events.onError, err);\r\n                deferred.reject(err);\r\n                // Stop the connection if negotiate failed\r\n                connection.stop();\r\n            };\r\n\r\n            $(connection).triggerHandler(events.onStarting);\r\n\r\n            url = _signalR.transports._logic.prepareQueryString(connection, url);\r\n\r\n            connection.log(\"Negotiating with '\" + url + \"'.\");\r\n\r\n            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.\r\n            connection._.negotiateRequest = _signalR.transports._logic.ajax(connection, {\r\n                url: url,\r\n                error: function error(_error, statusText) {\r\n                    // We don't want to cause any errors if we're aborting our own negotiate request.\r\n                    if (statusText !== _negotiateAbortText) {\r\n                        onFailed(_error, connection);\r\n                    } else {\r\n                        // This rejection will noop if the deferred has already been resolved or rejected.\r\n                        deferred.reject(_signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));\r\n                    }\r\n                },\r\n                success: function success(result) {\r\n                    var res,\r\n                        keepAliveData,\r\n                        protocolError,\r\n                        transports = [],\r\n                        supportedTransports = [];\r\n\r\n                    try {\r\n                        res = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        onFailed(_signalR._.error(resources.errorParsingNegotiateResponse, error), connection);\r\n                        return;\r\n                    }\r\n\r\n                    keepAliveData = connection._.keepAliveData;\r\n                    connection.appRelativeUrl = res.Url;\r\n                    connection.id = res.ConnectionId;\r\n                    connection.token = res.ConnectionToken;\r\n                    connection.webSocketServerUrl = res.WebSocketServerUrl;\r\n\r\n                    // The long poll timeout is the ConnectionTimeout plus 10 seconds\r\n                    connection._.pollTimeout = res.ConnectionTimeout * 1000 + 10000; // in ms\r\n\r\n                    // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect\r\n                    // after res.DisconnectTimeout seconds.\r\n                    connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms\r\n\r\n                    // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout\r\n                    connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;\r\n\r\n                    // If we have a keep alive\r\n                    if (res.KeepAliveTimeout) {\r\n                        // Register the keep alive data as activated\r\n                        keepAliveData.activated = true;\r\n\r\n                        // Timeout to designate when to force the connection into reconnecting converted to milliseconds\r\n                        keepAliveData.timeout = res.KeepAliveTimeout * 1000;\r\n\r\n                        // Timeout to designate when to warn the developer that the connection may be dead or is not responding.\r\n                        keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;\r\n\r\n                        // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes\r\n                        connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;\r\n                    } else {\r\n                        keepAliveData.activated = false;\r\n                    }\r\n\r\n                    connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);\r\n\r\n                    if (!res.ProtocolVersion || res.ProtocolVersion !== connection.clientProtocol) {\r\n                        protocolError = _signalR._.error(_signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n\r\n                        return;\r\n                    }\r\n\r\n                    $.each(_signalR.transports, function (key) {\r\n                        if (key.indexOf(\"_\") === 0 || key === \"webSockets\" && !res.TryWebSockets) {\r\n                            return true;\r\n                        }\r\n                        supportedTransports.push(key);\r\n                    });\r\n\r\n                    if ($.isArray(config.transport)) {\r\n                        $.each(config.transport, function (_, transport) {\r\n                            if ($.inArray(transport, supportedTransports) >= 0) {\r\n                                transports.push(transport);\r\n                            }\r\n                        });\r\n                    } else if (config.transport === \"auto\") {\r\n                        transports = supportedTransports;\r\n                    } else if ($.inArray(config.transport, supportedTransports) >= 0) {\r\n                        transports.push(config.transport);\r\n                    }\r\n\r\n                    _initialize(transports);\r\n                }\r\n            });\r\n\r\n            return deferred.promise();\r\n        },\r\n\r\n        starting: function starting(callback) {\r\n            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute before the connection is fully instantiated.</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStarting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        send: function send(data) {\r\n            /// <summary>Sends data over the connection</summary>\r\n            /// <param name=\"data\" type=\"String\">The data to send over the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection must be started before data can be sent. Call .start() before .send()\");\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.\");\r\n            }\r\n\r\n            connection.transport.send(connection, data);\r\n            // REVIEW: Should we return deferred here?\r\n            return connection;\r\n        },\r\n\r\n        received: function received(callback) {\r\n            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when any data is received on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReceived, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stateChanged: function stateChanged(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection state changes</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStateChanged, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        error: function error(callback) {\r\n            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when an error occurs on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onError, function (e, errorData, sendData) {\r\n                connection.lastError = errorData;\r\n                // In practice 'errorData' is the SignalR built error object.\r\n                // In practice 'sendData' is undefined for all error events except those triggered by\r\n                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.\r\n                callback.call(connection, errorData, sendData);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        disconnected: function disconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is broken</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onDisconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        connectionSlow: function connectionSlow(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is slow</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onConnectionSlow, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n\r\n            return connection;\r\n        },\r\n\r\n        reconnecting: function reconnecting(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection enters a reconnecting state</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnecting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        reconnected: function reconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is restored</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stop: function stop(async, notifyServer) {\r\n            /// <summary>Stops listening</summary>\r\n            /// <param name=\"async\" type=\"Boolean\">Whether or not to asynchronously abort the connection</param>\r\n            /// <param name=\"notifyServer\" type=\"Boolean\">Whether we want to notify the server that we are aborting the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this,\r\n\r\n            // Save deferral because this is always cleaned up\r\n            deferral = connection._deferral;\r\n\r\n            // Verify that we've bound a load event.\r\n            if (connection._.deferredStartHandler) {\r\n                // Unbind the event.\r\n                _pageWindow.unbind(\"load\", connection._.deferredStartHandler);\r\n            }\r\n\r\n            // Always clean up private non-timeout based state.\r\n            delete connection._.config;\r\n            delete connection._.deferredStartHandler;\r\n\r\n            // This needs to be checked despite the connection state because a connection start can be deferred until page load.\r\n            // If we've deferred the start due to a page load we need to unbind the \"onLoad\" -> start event.\r\n            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {\r\n                connection.log(\"Stopping connection prior to negotiate.\");\r\n\r\n                // If we have a deferral we should reject it\r\n                if (deferral) {\r\n                    deferral.reject(_signalR._.error(resources.stoppedWhileLoading));\r\n                }\r\n\r\n                // Short-circuit because the start has not been fully started.\r\n                return;\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                return;\r\n            }\r\n\r\n            connection.log(\"Stopping connection.\");\r\n\r\n            // Clear this no matter what\r\n            window.clearTimeout(connection._.beatHandle);\r\n            window.clearInterval(connection._.pingIntervalId);\r\n\r\n            if (connection.transport) {\r\n                connection.transport.stop(connection);\r\n\r\n                if (notifyServer !== false) {\r\n                    connection.transport.abort(connection, async);\r\n                }\r\n\r\n                if (supportsKeepAlive(connection)) {\r\n                    _signalR.transports._logic.stopMonitoringKeepAlive(connection);\r\n                }\r\n\r\n                connection.transport = null;\r\n            }\r\n\r\n            if (connection._.negotiateRequest) {\r\n                // If the negotiation request has already completed this will noop.\r\n                connection._.negotiateRequest.abort(_negotiateAbortText);\r\n                delete connection._.negotiateRequest;\r\n            }\r\n\r\n            // Ensure that initHandler.stop() is called before connection._deferral is deleted\r\n            if (connection._.initHandler) {\r\n                connection._.initHandler.stop();\r\n            }\r\n\r\n            delete connection._deferral;\r\n            delete connection.messageId;\r\n            delete connection.groupsToken;\r\n            delete connection.id;\r\n            delete connection._.pingIntervalId;\r\n            delete connection._.lastMessageAt;\r\n            delete connection._.lastActiveAt;\r\n\r\n            // Clear out our message buffer\r\n            connection._.connectingMessageBuffer.clear();\r\n\r\n            // Trigger the disconnect event\r\n            changeState(connection, connection.state, _signalR.connectionState.disconnected);\r\n            $(connection).triggerHandler(events.onDisconnect);\r\n\r\n            return connection;\r\n        },\r\n\r\n        log: function log(msg) {\r\n            _log(msg, this.logging);\r\n        }\r\n    };\r\n\r\n    _signalR.fn.init.prototype = _signalR.fn;\r\n\r\n    _signalR.noConflict = function () {\r\n        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>\r\n        /// <returns type=\"signalR\" />\r\n        if ($.connection === _signalR) {\r\n            $.connection = _connection;\r\n        }\r\n        return _signalR;\r\n    };\r\n\r\n    if ($.connection) {\r\n        _connection = $.connection;\r\n    }\r\n\r\n    $.connection = $.signalR = _signalR;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.common.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        startAbortText = \"__Start Aborted__\",\r\n        transportLogic;\r\n\r\n    signalR.transports = {};\r\n\r\n    function beat(connection) {\r\n        if (connection._.keepAliveData.monitoring) {\r\n            checkIfAlive(connection);\r\n        }\r\n\r\n        // Ensure that we successfully marked active before continuing the heartbeat.\r\n        if (transportLogic.markActive(connection)) {\r\n            connection._.beatHandle = window.setTimeout(function () {\r\n                beat(connection);\r\n            }, connection._.beatInterval);\r\n        }\r\n    }\r\n\r\n    function checkIfAlive(connection) {\r\n        var keepAliveData = connection._.keepAliveData,\r\n            timeElapsed;\r\n\r\n        // Only check if we're connected\r\n        if (connection.state === signalR.connectionState.connected) {\r\n            timeElapsed = new Date().getTime() - connection._.lastMessageAt;\r\n\r\n            // Check if the keep alive has completely timed out\r\n            if (timeElapsed >= keepAliveData.timeout) {\r\n                connection.log(\"Keep alive timed out.  Notifying transport that connection has been lost.\");\r\n\r\n                // Notify transport that the connection has been lost\r\n                connection.transport.lostConnection(connection);\r\n            } else if (timeElapsed >= keepAliveData.timeoutWarning) {\r\n                // This is to assure that the user only gets a single warning\r\n                if (!keepAliveData.userNotified) {\r\n                    connection.log(\"Keep alive has been missed, connection may be dead/slow.\");\r\n                    $(connection).triggerHandler(events.onConnectionSlow);\r\n                    keepAliveData.userNotified = true;\r\n                }\r\n            } else {\r\n                keepAliveData.userNotified = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAjaxUrl(connection, path) {\r\n        var url = connection.url + path;\r\n\r\n        if (connection.transport) {\r\n            url += \"?transport=\" + connection.transport.name;\r\n        }\r\n\r\n        return transportLogic.prepareQueryString(connection, url);\r\n    }\r\n\r\n    function InitHandler(connection) {\r\n        this.connection = connection;\r\n\r\n        this.startRequested = false;\r\n        this.startCompleted = false;\r\n        this.connectionStopped = false;\r\n    }\r\n\r\n    InitHandler.prototype = {\r\n        start: function start(transport, onSuccess, onFallback) {\r\n            var that = this,\r\n                connection = that.connection,\r\n                failCalled = false;\r\n\r\n            if (that.startRequested || that.connectionStopped) {\r\n                connection.log(\"WARNING! \" + transport.name + \" transport cannot be started. Initialization ongoing or completed.\");\r\n                return;\r\n            }\r\n\r\n            connection.log(transport.name + \" transport starting.\");\r\n\r\n            transport.start(connection, function () {\r\n                if (!failCalled) {\r\n                    that.initReceived(transport, onSuccess);\r\n                }\r\n            }, function (error) {\r\n                // Don't allow the same transport to cause onFallback to be called twice\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    that.transportFailed(transport, error, onFallback);\r\n                }\r\n\r\n                // Returns true if the transport should stop;\r\n                // false if it should attempt to reconnect\r\n                return !that.startCompleted || that.connectionStopped;\r\n            });\r\n\r\n            that.transportTimeoutHandle = window.setTimeout(function () {\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    connection.log(transport.name + \" transport timed out when trying to connect.\");\r\n                    that.transportFailed(transport, undefined, onFallback);\r\n                }\r\n            }, connection._.totalTransportConnectTimeout);\r\n        },\r\n\r\n        stop: function stop() {\r\n            this.connectionStopped = true;\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n            signalR.transports._logic.tryAbortStartRequest(this.connection);\r\n        },\r\n\r\n        initReceived: function initReceived(transport, onSuccess) {\r\n            var that = this,\r\n                connection = that.connection;\r\n\r\n            if (that.startRequested) {\r\n                connection.log(\"WARNING! The client received multiple init messages.\");\r\n                return;\r\n            }\r\n\r\n            if (that.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            that.startRequested = true;\r\n            window.clearTimeout(that.transportTimeoutHandle);\r\n\r\n            connection.log(transport.name + \" transport connected. Initiating start request.\");\r\n            signalR.transports._logic.ajaxStart(connection, function () {\r\n                that.startCompleted = true;\r\n                onSuccess();\r\n            });\r\n        },\r\n\r\n        transportFailed: function transportFailed(transport, error, onFallback) {\r\n            var connection = this.connection,\r\n                deferred = connection._deferral,\r\n                wrappedError;\r\n\r\n            if (this.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n\r\n            if (!this.startRequested) {\r\n                transport.stop(connection);\r\n\r\n                connection.log(transport.name + \" transport failed to connect. Attempting to fall back.\");\r\n                onFallback();\r\n            } else if (!this.startCompleted) {\r\n                // Do not attempt to fall back if a start request is ongoing during a transport failure.\r\n                // Instead, trigger an error and stop the connection.\r\n                wrappedError = signalR._.error(signalR.resources.errorDuringStartRequest, error);\r\n\r\n                connection.log(transport.name + \" transport failed during the start request. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                if (deferred) {\r\n                    deferred.reject(wrappedError);\r\n                }\r\n\r\n                connection.stop();\r\n            } else {\r\n                // The start request has completed, but the connection has not stopped.\r\n                // No need to do anything here. The transport should attempt its normal reconnect logic.\r\n            }\r\n        }\r\n    };\r\n\r\n    transportLogic = signalR.transports._logic = {\r\n        ajax: function ajax(connection, options) {\r\n            return $.ajax($.extend( /*deep copy*/true, {}, $.signalR.ajaxDefaults, {\r\n                type: \"GET\",\r\n                data: {},\r\n                xhrFields: { withCredentials: connection.withCredentials },\r\n                contentType: connection.contentType,\r\n                dataType: connection.ajaxDataType\r\n            }, options));\r\n        },\r\n\r\n        pingServer: function pingServer(connection) {\r\n            /// <summary>Pings the server</summary>\r\n            /// <param name=\"connection\" type=\"signalr\">Connection associated with the server ping</param>\r\n            /// <returns type=\"signalR\" />\r\n            var url,\r\n                xhr,\r\n                deferral = $.Deferred();\r\n\r\n            if (connection.transport) {\r\n                url = connection.url + \"/ping\";\r\n\r\n                url = transportLogic.addQs(url, connection.qs);\r\n\r\n                xhr = transportLogic.ajax(connection, {\r\n                    url: url,\r\n                    success: function success(result) {\r\n                        var data;\r\n\r\n                        try {\r\n                            data = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailedParse, connection.transport, error, xhr));\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        if (data.Response === \"pong\") {\r\n                            deferral.resolve();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result), connection.transport, null /* error */\r\n                            , xhr));\r\n                        }\r\n                    },\r\n                    error: function error(_error2) {\r\n                        if (_error2.status === 401 || _error2.status === 403) {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedStatusCode, _error2.status), connection.transport, _error2, xhr));\r\n                            connection.stop();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailed, connection.transport, _error2, xhr));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                deferral.reject(signalR._.transportError(signalR.resources.noConnectionTransport, connection.transport));\r\n            }\r\n\r\n            return deferral.promise();\r\n        },\r\n\r\n        prepareQueryString: function prepareQueryString(connection, url) {\r\n            var preparedUrl;\r\n\r\n            // Use addQs to start since it handles the ?/& prefix for us\r\n            preparedUrl = transportLogic.addQs(url, \"clientProtocol=\" + connection.clientProtocol);\r\n\r\n            // Add the user-specified query string params if any\r\n            preparedUrl = transportLogic.addQs(preparedUrl, connection.qs);\r\n\r\n            if (connection.token) {\r\n                preparedUrl += \"&connectionToken=\" + window.encodeURIComponent(connection.token);\r\n            }\r\n\r\n            if (connection.data) {\r\n                preparedUrl += \"&connectionData=\" + window.encodeURIComponent(connection.data);\r\n            }\r\n\r\n            return preparedUrl;\r\n        },\r\n\r\n        addQs: function addQs(url, qs) {\r\n            var appender = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\",\r\n                firstChar;\r\n\r\n            if (!qs) {\r\n                return url;\r\n            }\r\n\r\n            if ((typeof qs === 'undefined' ? 'undefined' : _typeof(qs)) === \"object\") {\r\n                return url + appender + $.param(qs);\r\n            }\r\n\r\n            if (typeof qs === \"string\") {\r\n                firstChar = qs.charAt(0);\r\n\r\n                if (firstChar === \"?\" || firstChar === \"&\") {\r\n                    appender = \"\";\r\n                }\r\n\r\n                return url + appender + qs;\r\n            }\r\n\r\n            throw new Error(\"Query string property must be either a string or object.\");\r\n        },\r\n\r\n        // BUG #2953: The url needs to be same otherwise it will cause a memory leak\r\n        getUrl: function getUrl(connection, transport, reconnecting, poll, ajaxPost) {\r\n            /// <summary>Gets the url for making a GET based connect request</summary>\r\n            var baseUrl = transport === \"webSockets\" ? \"\" : connection.baseUrl,\r\n                url = baseUrl + connection.appRelativeUrl,\r\n                qs = \"transport=\" + transport;\r\n\r\n            if (!ajaxPost && connection.groupsToken) {\r\n                qs += \"&groupsToken=\" + window.encodeURIComponent(connection.groupsToken);\r\n            }\r\n\r\n            if (!reconnecting) {\r\n                url += \"/connect\";\r\n            } else {\r\n                if (poll) {\r\n                    // longPolling transport specific\r\n                    url += \"/poll\";\r\n                } else {\r\n                    url += \"/reconnect\";\r\n                }\r\n\r\n                if (!ajaxPost && connection.messageId) {\r\n                    qs += \"&messageId=\" + window.encodeURIComponent(connection.messageId);\r\n                }\r\n            }\r\n            url += \"?\" + qs;\r\n            url = transportLogic.prepareQueryString(connection, url);\r\n\r\n            if (!ajaxPost) {\r\n                url += \"&tid=\" + Math.floor(Math.random() * 11);\r\n            }\r\n\r\n            return url;\r\n        },\r\n\r\n        maximizePersistentResponse: function maximizePersistentResponse(minPersistentResponse) {\r\n            return {\r\n                MessageId: minPersistentResponse.C,\r\n                Messages: minPersistentResponse.M,\r\n                Initialized: typeof minPersistentResponse.S !== \"undefined\" ? true : false,\r\n                ShouldReconnect: typeof minPersistentResponse.T !== \"undefined\" ? true : false,\r\n                LongPollDelay: minPersistentResponse.L,\r\n                GroupsToken: minPersistentResponse.G\r\n            };\r\n        },\r\n\r\n        updateGroups: function updateGroups(connection, groupsToken) {\r\n            if (groupsToken) {\r\n                connection.groupsToken = groupsToken;\r\n            }\r\n        },\r\n\r\n        stringifySend: function stringifySend(connection, message) {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\" || message === null) {\r\n                return message;\r\n            }\r\n            return connection.json.stringify(message);\r\n        },\r\n\r\n        ajaxSend: function ajaxSend(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data),\r\n                url = getAjaxUrl(connection, \"/send\"),\r\n                xhr,\r\n                onFail = function onFail(error, connection) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);\r\n            };\r\n\r\n            xhr = transportLogic.ajax(connection, {\r\n                url: url,\r\n                type: connection.ajaxDataType === \"jsonp\" ? \"GET\" : \"POST\",\r\n                contentType: signalR._.defaultContentType,\r\n                data: {\r\n                    data: payload\r\n                },\r\n                success: function success(result) {\r\n                    var res;\r\n\r\n                    if (result) {\r\n                        try {\r\n                            res = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            onFail(error, connection);\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        transportLogic.triggerReceived(connection, res);\r\n                    }\r\n                },\r\n                error: function error(_error3, textStatus) {\r\n                    if (textStatus === \"abort\" || textStatus === \"parsererror\") {\r\n                        // The parsererror happens for sends that don't return any data, and hence\r\n                        // don't write the jsonp callback to the response. This is harder to fix on the server\r\n                        // so just hack around it on the client for now.\r\n                        return;\r\n                    }\r\n\r\n                    onFail(_error3, connection);\r\n                }\r\n            });\r\n\r\n            return xhr;\r\n        },\r\n\r\n        ajaxAbort: function ajaxAbort(connection, async) {\r\n            if (typeof connection.transport === \"undefined\") {\r\n                return;\r\n            }\r\n\r\n            // Async by default unless explicitly overidden\r\n            async = typeof async === \"undefined\" ? true : async;\r\n\r\n            var url = getAjaxUrl(connection, \"/abort\");\r\n\r\n            transportLogic.ajax(connection, {\r\n                url: url,\r\n                async: async,\r\n                timeout: 1000,\r\n                type: \"POST\"\r\n            });\r\n\r\n            connection.log(\"Fired ajax abort async = \" + async + \".\");\r\n        },\r\n\r\n        ajaxStart: function ajaxStart(connection, onSuccess) {\r\n            var rejectDeferred = function rejectDeferred(error) {\r\n                var deferred = connection._deferral;\r\n                if (deferred) {\r\n                    deferred.reject(error);\r\n                }\r\n            },\r\n                triggerStartError = function triggerStartError(error) {\r\n                connection.log(\"The start request failed. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n                rejectDeferred(error);\r\n                connection.stop();\r\n            };\r\n\r\n            connection._.startRequest = transportLogic.ajax(connection, {\r\n                url: getAjaxUrl(connection, \"/start\"),\r\n                success: function success(result, statusText, xhr) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.errorParsingStartResponse, result), error, xhr));\r\n                        return;\r\n                    }\r\n\r\n                    if (data.Response === \"started\") {\r\n                        onSuccess();\r\n                    } else {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.invalidStartResponse, result), null /* error */, xhr));\r\n                    }\r\n                },\r\n                error: function error(xhr, statusText, _error4) {\r\n                    if (statusText !== startAbortText) {\r\n                        triggerStartError(signalR._.error(signalR.resources.errorDuringStartRequest, _error4, xhr));\r\n                    } else {\r\n                        // Stop has been called, no need to trigger the error handler\r\n                        // or stop the connection again with onStartError\r\n                        connection.log(\"The start request aborted because connection.stop() was called.\");\r\n                        rejectDeferred(signalR._.error(signalR.resources.stoppedDuringStartRequest, null /* error */, xhr));\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        tryAbortStartRequest: function tryAbortStartRequest(connection) {\r\n            if (connection._.startRequest) {\r\n                // If the start request has already completed this will noop.\r\n                connection._.startRequest.abort(startAbortText);\r\n                delete connection._.startRequest;\r\n            }\r\n        },\r\n\r\n        tryInitialize: function tryInitialize(connection, persistentResponse, onInitialized) {\r\n            if (persistentResponse.Initialized && onInitialized) {\r\n                onInitialized();\r\n            } else if (persistentResponse.Initialized) {\r\n                connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n            }\r\n        },\r\n\r\n        triggerReceived: function triggerReceived(connection, data) {\r\n            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {\r\n                $(connection).triggerHandler(events.onReceived, [data]);\r\n            }\r\n        },\r\n\r\n        processMessages: function processMessages(connection, minData, onInitialized) {\r\n            var data;\r\n\r\n            // Update the last message time stamp\r\n            transportLogic.markLastMessage(connection);\r\n\r\n            if (minData) {\r\n                data = transportLogic.maximizePersistentResponse(minData);\r\n\r\n                transportLogic.updateGroups(connection, data.GroupsToken);\r\n\r\n                if (data.MessageId) {\r\n                    connection.messageId = data.MessageId;\r\n                }\r\n\r\n                if (data.Messages) {\r\n                    $.each(data.Messages, function (index, message) {\r\n                        transportLogic.triggerReceived(connection, message);\r\n                    });\r\n\r\n                    transportLogic.tryInitialize(connection, data, onInitialized);\r\n                }\r\n            }\r\n        },\r\n\r\n        monitorKeepAlive: function monitorKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // If we haven't initiated the keep alive timeouts then we need to\r\n            if (!keepAliveData.monitoring) {\r\n                keepAliveData.monitoring = true;\r\n\r\n                transportLogic.markLastMessage(connection);\r\n\r\n                // Save the function so we can unbind it on stop\r\n                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {\r\n                    // Mark a new message so that keep alive doesn't time out connections\r\n                    transportLogic.markLastMessage(connection);\r\n                };\r\n\r\n                // Update Keep alive on reconnect\r\n                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                connection.log(\"Now monitoring keep alive with a warning timeout of \" + keepAliveData.timeoutWarning + \", keep alive timeout of \" + keepAliveData.timeout + \" and disconnecting timeout of \" + connection.disconnectTimeout);\r\n            } else {\r\n                connection.log(\"Tried to monitor keep alive but it's already being monitored.\");\r\n            }\r\n        },\r\n\r\n        stopMonitoringKeepAlive: function stopMonitoringKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // Only attempt to stop the keep alive monitoring if its being monitored\r\n            if (keepAliveData.monitoring) {\r\n                // Stop monitoring\r\n                keepAliveData.monitoring = false;\r\n\r\n                // Remove the updateKeepAlive function from the reconnect event\r\n                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                // Clear all the keep alive data\r\n                connection._.keepAliveData = {};\r\n                connection.log(\"Stopping the monitoring of the keep alive.\");\r\n            }\r\n        },\r\n\r\n        startHeartbeat: function startHeartbeat(connection) {\r\n            connection._.lastActiveAt = new Date().getTime();\r\n            beat(connection);\r\n        },\r\n\r\n        markLastMessage: function markLastMessage(connection) {\r\n            connection._.lastMessageAt = new Date().getTime();\r\n        },\r\n\r\n        markActive: function markActive(connection) {\r\n            if (transportLogic.verifyLastActive(connection)) {\r\n                connection._.lastActiveAt = new Date().getTime();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isConnectedOrReconnecting: function isConnectedOrReconnecting(connection) {\r\n            return connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        ensureReconnectingState: function ensureReconnectingState(connection) {\r\n            if (changeState(connection, signalR.connectionState.connected, signalR.connectionState.reconnecting) === true) {\r\n                $(connection).triggerHandler(events.onReconnecting);\r\n            }\r\n            return connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        clearReconnectTimeout: function clearReconnectTimeout(connection) {\r\n            if (connection && connection._.reconnectTimeout) {\r\n                window.clearTimeout(connection._.reconnectTimeout);\r\n                delete connection._.reconnectTimeout;\r\n            }\r\n        },\r\n\r\n        verifyLastActive: function verifyLastActive(connection) {\r\n            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {\r\n                var message = signalR._.format(signalR.resources.reconnectWindowTimeout, new Date(connection._.lastActiveAt), connection.reconnectWindow);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        reconnect: function reconnect(connection, transportName) {\r\n            var transport = signalR.transports[transportName];\r\n\r\n            // We should only set a reconnectTimeout if we are currently connected\r\n            // and a reconnectTimeout isn't already set.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {\r\n                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n                if (!transportLogic.verifyLastActive(connection)) {\r\n                    return;\r\n                }\r\n\r\n                connection._.reconnectTimeout = window.setTimeout(function () {\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    transport.stop(connection);\r\n\r\n                    if (transportLogic.ensureReconnectingState(connection)) {\r\n                        connection.log(transportName + \" reconnecting.\");\r\n                        transport.start(connection);\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        handleParseFailure: function handleParseFailure(connection, result, error, onFailed, context) {\r\n            var wrappedError = signalR._.transportError(signalR._.format(signalR.resources.parseFailed, result), connection.transport, error, context);\r\n\r\n            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.\r\n            if (onFailed && onFailed(wrappedError)) {\r\n                connection.log(\"Failed to parse server response while attempting to connect.\");\r\n            } else {\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                connection.stop();\r\n            }\r\n        },\r\n\r\n        initHandler: function initHandler(connection) {\r\n            return new InitHandler(connection);\r\n        },\r\n\r\n        foreverFrame: {\r\n            count: 0,\r\n            connections: {}\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.webSockets.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.webSockets = {\r\n        name: \"webSockets\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data);\r\n\r\n            try {\r\n                connection.socket.send(payload);\r\n            } catch (ex) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.webSocketsInvalidState, connection.transport, ex, connection.socket), data]);\r\n            }\r\n        },\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var url,\r\n                opened = false,\r\n                that = this,\r\n                reconnecting = !onSuccess,\r\n                $connection = $(connection);\r\n\r\n            if (!window.WebSocket) {\r\n                onFailed();\r\n                return;\r\n            }\r\n\r\n            if (!connection.socket) {\r\n                if (connection.webSocketServerUrl) {\r\n                    url = connection.webSocketServerUrl;\r\n                } else {\r\n                    url = connection.wsProtocol + connection.host;\r\n                }\r\n\r\n                url += transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n                connection.log(\"Connecting to websocket endpoint '\" + url + \"'.\");\r\n                connection.socket = new window.WebSocket(url);\r\n\r\n                connection.socket.onopen = function () {\r\n                    opened = true;\r\n                    connection.log(\"Websocket opened.\");\r\n\r\n                    transportLogic.clearReconnectTimeout(connection);\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                };\r\n\r\n                connection.socket.onclose = function (event) {\r\n                    var error;\r\n\r\n                    // Only handle a socket close if the close is from the current socket.\r\n                    // Sometimes on disconnect the server will push down an onclose event\r\n                    // to an expired socket.\r\n\r\n                    if (this === connection.socket) {\r\n                        if (opened && typeof event.wasClean !== \"undefined\" && event.wasClean === false) {\r\n                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but\r\n                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.\r\n                            error = signalR._.transportError(signalR.resources.webSocketClosed, connection.transport, event);\r\n\r\n                            connection.log(\"Unclean disconnect from websocket: \" + (event.reason || \"[no reason given].\"));\r\n                        } else {\r\n                            connection.log(\"Websocket closed.\");\r\n                        }\r\n\r\n                        if (!onFailed || !onFailed(error)) {\r\n                            if (error) {\r\n                                $(connection).triggerHandler(events.onError, [error]);\r\n                            }\r\n\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                connection.socket.onmessage = function (event) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(event.data);\r\n                    } catch (error) {\r\n                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);\r\n                        return;\r\n                    }\r\n\r\n                    if (data) {\r\n                        // data.M is PersistentResponse.Messages\r\n                        if ($.isEmptyObject(data) || data.M) {\r\n                            transportLogic.processMessages(connection, data, onSuccess);\r\n                        } else {\r\n                            // For websockets we need to trigger onReceived\r\n                            // for callbacks to outgoing hub calls.\r\n                            transportLogic.triggerReceived(connection, data);\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection.socket) {\r\n                connection.log(\"Closing the Websocket.\");\r\n                connection.socket.close();\r\n                connection.socket = null;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.serverSentEvents.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        clearReconnectAttemptTimeout = function clearReconnectAttemptTimeout(connection) {\r\n        window.clearTimeout(connection._.reconnectAttemptTimeoutHandle);\r\n        delete connection._.reconnectAttemptTimeoutHandle;\r\n    };\r\n\r\n    signalR.transports.serverSentEvents = {\r\n        name: \"serverSentEvents\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        timeOut: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                opened = false,\r\n                $connection = $(connection),\r\n                reconnecting = !onSuccess,\r\n                url;\r\n\r\n            if (connection.eventSource) {\r\n                connection.log(\"The connection already has an event source. Stopping it.\");\r\n                connection.stop();\r\n            }\r\n\r\n            if (!window.EventSource) {\r\n                if (onFailed) {\r\n                    connection.log(\"This browser doesn't support SSE.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            url = transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n            try {\r\n                connection.log(\"Attempting to connect to SSE endpoint '\" + url + \"'.\");\r\n                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });\r\n            } catch (e) {\r\n                connection.log(\"EventSource failed trying to connect with error \" + e.Message + \".\");\r\n                if (onFailed) {\r\n                    // The connection failed, call the failed callback\r\n                    onFailed();\r\n                } else {\r\n                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);\r\n                    if (reconnecting) {\r\n                        // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                        that.reconnect(connection);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (reconnecting) {\r\n                connection._.reconnectAttemptTimeoutHandle = window.setTimeout(function () {\r\n                    if (opened === false) {\r\n                        // If we're reconnecting and the event source is attempting to connect,\r\n                        // don't keep retrying. This causes duplicate connections to spawn.\r\n                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {\r\n                            // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                }, that.timeOut);\r\n            }\r\n\r\n            connection.eventSource.addEventListener(\"open\", function (e) {\r\n                connection.log(\"EventSource connected.\");\r\n\r\n                clearReconnectAttemptTimeout(connection);\r\n                transportLogic.clearReconnectTimeout(connection);\r\n\r\n                if (opened === false) {\r\n                    opened = true;\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                }\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"message\", function (e) {\r\n                var res;\r\n\r\n                // process messages\r\n                if (e.data === \"initialized\") {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    res = connection._parseResponse(e.data);\r\n                } catch (error) {\r\n                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.processMessages(connection, res, onSuccess);\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"error\", function (e) {\r\n                var error = signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e);\r\n\r\n                // Only handle an error if the error is from the current Event Source.\r\n                // Sometimes on disconnect the server will push down an error event\r\n                // to an expired Event Source.\r\n                if (this !== connection.eventSource) {\r\n                    return;\r\n                }\r\n\r\n                if (onFailed && onFailed(error)) {\r\n                    return;\r\n                }\r\n\r\n                connection.log(\"EventSource readyState: \" + connection.eventSource.readyState + \".\");\r\n\r\n                if (e.eventPhase === window.EventSource.CLOSED) {\r\n                    // We don't use the EventSource's native reconnect function as it\r\n                    // doesn't allow us to change the URL when reconnecting. We need\r\n                    // to change the URL to not include the /connect suffix, and pass\r\n                    // the last message id we received.\r\n                    connection.log(\"EventSource reconnecting due to the server connection ending.\");\r\n                    that.reconnect(connection);\r\n                } else {\r\n                    // connection error\r\n                    connection.log(\"EventSource error.\");\r\n                    $connection.triggerHandler(events.onError, [error]);\r\n                }\r\n            }, false);\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            clearReconnectAttemptTimeout(connection);\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection && connection.eventSource) {\r\n                connection.log(\"EventSource calling close().\");\r\n                connection.eventSource.close();\r\n                connection.eventSource = null;\r\n                delete connection.eventSource;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.foreverFrame.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        createFrame = function createFrame() {\r\n        var frame = window.document.createElement(\"iframe\");\r\n        frame.setAttribute(\"style\", \"position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;\");\r\n        return frame;\r\n    },\r\n\r\n    // Used to prevent infinite loading icon spins in older versions of ie\r\n    // We build this object inside a closure so we don't pollute the rest of\r\n    // the foreverFrame transport with unnecessary functions/utilities.\r\n    loadPreventer = function () {\r\n        var loadingFixIntervalId = null,\r\n            loadingFixInterval = 1000,\r\n            attachedTo = 0;\r\n\r\n        return {\r\n            prevent: function prevent() {\r\n                // Prevent additional iframe removal procedures from newer browsers\r\n                if (signalR._.ieVersion <= 8) {\r\n                    // We only ever want to set the interval one time, so on the first attachedTo\r\n                    if (attachedTo === 0) {\r\n                        // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky\r\n                        loadingFixIntervalId = window.setInterval(function () {\r\n                            var tempFrame = createFrame();\r\n\r\n                            window.document.body.appendChild(tempFrame);\r\n                            window.document.body.removeChild(tempFrame);\r\n\r\n                            tempFrame = null;\r\n                        }, loadingFixInterval);\r\n                    }\r\n\r\n                    attachedTo++;\r\n                }\r\n            },\r\n            cancel: function cancel() {\r\n                // Only clear the interval if there's only one more object that the loadPreventer is attachedTo\r\n                if (attachedTo === 1) {\r\n                    window.clearInterval(loadingFixIntervalId);\r\n                }\r\n\r\n                if (attachedTo > 0) {\r\n                    attachedTo--;\r\n                }\r\n            }\r\n        };\r\n    }();\r\n\r\n    signalR.transports.foreverFrame = {\r\n        name: \"foreverFrame\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        // Added as a value here so we can create tests to verify functionality\r\n        iframeClearThreshold: 50,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                frameId = transportLogic.foreverFrame.count += 1,\r\n                url,\r\n                frame = createFrame(),\r\n                frameLoadHandler = function frameLoadHandler() {\r\n                connection.log(\"Forever frame iframe finished loading and is no longer receiving messages.\");\r\n                if (!onFailed || !onFailed()) {\r\n                    that.reconnect(connection);\r\n                }\r\n            };\r\n\r\n            if (window.EventSource) {\r\n                // If the browser supports SSE, don't use Forever Frame\r\n                if (onFailed) {\r\n                    connection.log(\"Forever Frame is not supported by SignalR on browsers with SSE support.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            frame.setAttribute(\"data-signalr-connection-id\", connection.id);\r\n\r\n            // Start preventing loading icon\r\n            // This will only perform work if the loadPreventer is not attached to another connection.\r\n            loadPreventer.prevent();\r\n\r\n            // Build the url\r\n            url = transportLogic.getUrl(connection, this.name);\r\n            url += \"&frameId=\" + frameId;\r\n\r\n            // add frame to the document prior to setting URL to avoid caching issues.\r\n            window.document.documentElement.appendChild(frame);\r\n\r\n            connection.log(\"Binding to iframe's load event.\");\r\n\r\n            if (frame.addEventListener) {\r\n                frame.addEventListener(\"load\", frameLoadHandler, false);\r\n            } else if (frame.attachEvent) {\r\n                frame.attachEvent(\"onload\", frameLoadHandler);\r\n            }\r\n\r\n            frame.src = url;\r\n            transportLogic.foreverFrame.connections[frameId] = connection;\r\n\r\n            connection.frame = frame;\r\n            connection.frameId = frameId;\r\n\r\n            if (onSuccess) {\r\n                connection.onSuccess = function () {\r\n                    connection.log(\"Iframe transport started.\");\r\n                    onSuccess();\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            var that = this;\r\n\r\n            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {\r\n                window.setTimeout(function () {\r\n                    // Verify that we're ok to reconnect.\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {\r\n                        var frame = connection.frame,\r\n                            src = transportLogic.getUrl(connection, that.name, true) + \"&frameId=\" + connection.frameId;\r\n                        connection.log(\"Updating iframe src to '\" + src + \"'.\");\r\n                        frame.src = src;\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        receive: function receive(connection, data) {\r\n            var cw, body, response;\r\n\r\n            if (connection.json !== connection._originalJson) {\r\n                // If there's a custom JSON parser configured then serialize the object\r\n                // using the original (browser) JSON parser and then deserialize it using\r\n                // the custom parser (connection._parseResponse does that). This is so we\r\n                // can easily send the response from the server as \"raw\" JSON but still\r\n                // support custom JSON deserialization in the browser.\r\n                data = connection._originalJson.stringify(data);\r\n            }\r\n\r\n            response = connection._parseResponse(data);\r\n\r\n            transportLogic.processMessages(connection, response, connection.onSuccess);\r\n\r\n            // Protect against connection stopping from a callback trigger within the processMessages above.\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                // Delete the script & div elements\r\n                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;\r\n                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {\r\n                    connection.frameMessageCount = 0;\r\n                    cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                    if (cw && cw.document && cw.document.body) {\r\n                        body = cw.document.body;\r\n\r\n                        // Remove all the child elements from the iframe's body to conserver memory\r\n                        while (body.firstChild) {\r\n                            body.removeChild(body.firstChild);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            var cw = null;\r\n\r\n            // Stop attempting to prevent loading icon\r\n            loadPreventer.cancel();\r\n\r\n            if (connection.frame) {\r\n                if (connection.frame.stop) {\r\n                    connection.frame.stop();\r\n                } else {\r\n                    try {\r\n                        cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                        if (cw.document && cw.document.execCommand) {\r\n                            cw.document.execCommand(\"Stop\");\r\n                        }\r\n                    } catch (e) {\r\n                        connection.log(\"Error occurred when stopping foreverFrame transport. Message = \" + e.message + \".\");\r\n                    }\r\n                }\r\n\r\n                // Ensure the iframe is where we left it\r\n                if (connection.frame.parentNode === window.document.body) {\r\n                    window.document.body.removeChild(connection.frame);\r\n                }\r\n\r\n                delete transportLogic.foreverFrame.connections[connection.frameId];\r\n                connection.frame = null;\r\n                connection.frameId = null;\r\n                delete connection.frame;\r\n                delete connection.frameId;\r\n                delete connection.onSuccess;\r\n                delete connection.frameMessageCount;\r\n                connection.log(\"Stopping forever frame.\");\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        },\r\n\r\n        getConnection: function getConnection(id) {\r\n            return transportLogic.foreverFrame.connections[id];\r\n        },\r\n\r\n        started: function started(connection) {\r\n            if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n\r\n                $(connection).triggerHandler(events.onReconnect);\r\n            }\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.longPolling.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        isDisconnecting = $.signalR.isDisconnecting,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.longPolling = {\r\n        name: \"longPolling\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return false;\r\n        },\r\n\r\n        reconnectDelay: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            /// <summary>Starts the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to start</param>\r\n            var that = this,\r\n                _fireConnect = function fireConnect() {\r\n                _fireConnect = $.noop;\r\n\r\n                connection.log(\"LongPolling connected.\");\r\n\r\n                if (onSuccess) {\r\n                    onSuccess();\r\n                } else {\r\n                    connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n                }\r\n            },\r\n                tryFailConnect = function tryFailConnect(error) {\r\n                if (onFailed(error)) {\r\n                    connection.log(\"LongPolling failed to connect.\");\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            },\r\n                privateData = connection._,\r\n                reconnectErrors = 0,\r\n                fireReconnected = function fireReconnected(instance) {\r\n                window.clearTimeout(privateData.reconnectTimeoutId);\r\n                privateData.reconnectTimeoutId = null;\r\n\r\n                if (changeState(instance, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                    // Successfully reconnected!\r\n                    instance.log(\"Raising the reconnect event\");\r\n                    $(instance).triggerHandler(events.onReconnect);\r\n                }\r\n            },\r\n\r\n            // 1 hour\r\n            maxFireReconnectedTimeout = 3600000;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.log(\"Polling xhr requests already exists, aborting.\");\r\n                connection.stop();\r\n            }\r\n\r\n            connection.messageId = null;\r\n\r\n            privateData.reconnectTimeoutId = null;\r\n\r\n            privateData.pollTimeoutId = window.setTimeout(function () {\r\n                (function poll(instance, raiseReconnect) {\r\n                    var messageId = instance.messageId,\r\n                        connect = messageId === null,\r\n                        reconnecting = !connect,\r\n                        polling = !raiseReconnect,\r\n                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling, true /* use Post for longPolling */),\r\n                        postData = {};\r\n\r\n                    if (instance.messageId) {\r\n                        postData.messageId = instance.messageId;\r\n                    }\r\n\r\n                    if (instance.groupsToken) {\r\n                        postData.groupsToken = instance.groupsToken;\r\n                    }\r\n\r\n                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.\r\n                    if (isDisconnecting(instance) === true) {\r\n                        return;\r\n                    }\r\n\r\n                    connection.log(\"Opening long polling request to '\" + url + \"'.\");\r\n                    instance.pollXhr = transportLogic.ajax(connection, {\r\n                        xhrFields: {\r\n                            onprogress: function onprogress() {\r\n                                transportLogic.markLastMessage(connection);\r\n                            }\r\n                        },\r\n                        url: url,\r\n                        type: \"POST\",\r\n                        contentType: signalR._.defaultContentType,\r\n                        data: postData,\r\n                        timeout: connection._.pollTimeout,\r\n                        success: function success(result) {\r\n                            var minData,\r\n                                delay = 0,\r\n                                data,\r\n                                shouldReconnect;\r\n\r\n                            connection.log(\"Long poll complete.\");\r\n\r\n                            // Reset our reconnect errors so if we transition into a reconnecting state again we trigger\r\n                            // reconnected quickly\r\n                            reconnectErrors = 0;\r\n\r\n                            try {\r\n                                // Remove any keep-alives from the beginning of the result\r\n                                minData = connection._parseResponse(result);\r\n                            } catch (error) {\r\n                                transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);\r\n                                return;\r\n                            }\r\n\r\n                            // If there's currently a timeout to trigger reconnect, fire it now before processing messages\r\n                            if (privateData.reconnectTimeoutId !== null) {\r\n                                fireReconnected(instance);\r\n                            }\r\n\r\n                            if (minData) {\r\n                                data = transportLogic.maximizePersistentResponse(minData);\r\n                            }\r\n\r\n                            transportLogic.processMessages(instance, minData, _fireConnect);\r\n\r\n                            if (data && $.type(data.LongPollDelay) === \"number\") {\r\n                                delay = data.LongPollDelay;\r\n                            }\r\n\r\n                            if (isDisconnecting(instance) === true) {\r\n                                return;\r\n                            }\r\n\r\n                            shouldReconnect = data && data.ShouldReconnect;\r\n                            if (shouldReconnect) {\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function\r\n                            if (delay > 0) {\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, shouldReconnect);\r\n                                }, delay);\r\n                            } else {\r\n                                poll(instance, shouldReconnect);\r\n                            }\r\n                        },\r\n\r\n                        error: function error(data, textStatus) {\r\n                            var error = signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr);\r\n\r\n                            // Stop trying to trigger reconnect, connection is in an error state\r\n                            // If we're not in the reconnect state this will noop\r\n                            window.clearTimeout(privateData.reconnectTimeoutId);\r\n                            privateData.reconnectTimeoutId = null;\r\n\r\n                            if (textStatus === \"abort\") {\r\n                                connection.log(\"Aborted xhr request.\");\r\n                                return;\r\n                            }\r\n\r\n                            if (!tryFailConnect(error)) {\r\n\r\n                                // Increment our reconnect errors, we assume all errors to be reconnect errors\r\n                                // In the case that it's our first error this will cause Reconnect to be fired\r\n                                // after 1 second due to reconnectErrors being = 1.\r\n                                reconnectErrors++;\r\n\r\n                                if (connection.state !== signalR.connectionState.reconnecting) {\r\n                                    connection.log(\"An error occurred using longPolling. Status = \" + textStatus + \".  Response = \" + data.responseText + \".\");\r\n                                    $(instance).triggerHandler(events.onError, [error]);\r\n                                }\r\n\r\n                                // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.\r\n                                // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.\r\n                                // Therefore we don't want to change that failure code path.\r\n                                if ((connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting) && !transportLogic.verifyLastActive(connection)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Call poll with the raiseReconnect flag as true after the reconnect delay\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, true);\r\n                                }, that.reconnectDelay);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // This will only ever pass after an error has occurred via the poll ajax procedure.\r\n                    if (reconnecting && raiseReconnect === true) {\r\n                        // We wait to reconnect depending on how many times we've failed to reconnect.\r\n                        // This is essentially a heuristic that will exponentially increase in wait time before\r\n                        // triggering reconnected.  This depends on the \"error\" handler of Poll to cancel this\r\n                        // timeout if it triggers before the Reconnected event fires.\r\n                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.\r\n                        privateData.reconnectTimeoutId = window.setTimeout(function () {\r\n                            fireReconnected(instance);\r\n                        }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));\r\n                    }\r\n                })(connection);\r\n            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort(\"lostConnection\");\r\n            }\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            /// <summary>Stops the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to stop</param>\r\n\r\n            window.clearTimeout(connection._.pollTimeoutId);\r\n            window.clearTimeout(connection._.reconnectTimeoutId);\r\n\r\n            delete connection._.pollTimeoutId;\r\n            delete connection._.reconnectTimeoutId;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort();\r\n                connection.pollXhr = null;\r\n                delete connection.pollXhr;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.hubs.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var eventNamespace = \".hubProxy\",\r\n        signalR = $.signalR;\r\n\r\n    function makeEventName(event) {\r\n        return event + eventNamespace;\r\n    }\r\n\r\n    // Equivalent to Array.prototype.map\r\n    function map(arr, fun, thisp) {\r\n        var i,\r\n            length = arr.length,\r\n            result = [];\r\n        for (i = 0; i < length; i += 1) {\r\n            if (arr.hasOwnProperty(i)) {\r\n                result[i] = fun.call(thisp, arr[i], i, arr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getArgValue(a) {\r\n        return $.isFunction(a) ? null : $.type(a) === \"undefined\" ? null : a;\r\n    }\r\n\r\n    function hasMembers(obj) {\r\n        for (var key in obj) {\r\n            // If we have any properties in our callback map then we have callbacks and can exit the loop via return\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function clearInvocationCallbacks(connection, error) {\r\n        /// <param name=\"connection\" type=\"hubConnection\" />\r\n        var callbacks = connection._.invocationCallbacks,\r\n            callback;\r\n\r\n        if (hasMembers(callbacks)) {\r\n            connection.log(\"Clearing hub invocation callbacks with error: \" + error + \".\");\r\n        }\r\n\r\n        // Reset the callback cache now as we have a local var referencing it\r\n        connection._.invocationCallbackId = 0;\r\n        delete connection._.invocationCallbacks;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Loop over the callbacks and invoke them.\r\n        // We do this using a local var reference and *after* we've cleared the cache\r\n        // so that if a fail callback itself tries to invoke another method we don't\r\n        // end up with its callback in the list we're looping over.\r\n        for (var callbackId in callbacks) {\r\n            callback = callbacks[callbackId];\r\n            callback.method.call(callback.scope, { E: error });\r\n        }\r\n    }\r\n\r\n    // hubProxy\r\n    function hubProxy(hubConnection, hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        return new hubProxy.fn.init(hubConnection, hubName);\r\n    }\r\n\r\n    hubProxy.fn = hubProxy.prototype = {\r\n        init: function init(connection, hubName) {\r\n            this.state = {};\r\n            this.connection = connection;\r\n            this.hubName = hubName;\r\n            this._ = {\r\n                callbackMap: {}\r\n            };\r\n        },\r\n\r\n        constructor: hubProxy,\r\n\r\n        hasSubscriptions: function hasSubscriptions() {\r\n            return hasMembers(this._.callbackMap);\r\n        },\r\n\r\n        on: function on(eventName, callback) {\r\n            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to register the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            // If there is not an event registered for this callback yet we want to create its event space in the callback map.\r\n            if (!callbackMap[eventName]) {\r\n                callbackMap[eventName] = {};\r\n            }\r\n\r\n            // Map the callback to our encompassed function\r\n            callbackMap[eventName][callback] = function (e, data) {\r\n                callback.apply(that, data);\r\n            };\r\n\r\n            $(that).bind(makeEventName(eventName), callbackMap[eventName][callback]);\r\n\r\n            return that;\r\n        },\r\n\r\n        off: function off(eventName, callback) {\r\n            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to unregister the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be invoked.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                callbackSpace;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            callbackSpace = callbackMap[eventName];\r\n\r\n            // Verify that there is an event space to unbind\r\n            if (callbackSpace) {\r\n                // Only unbind if there's an event bound with eventName and a callback with the specified callback\r\n                if (callbackSpace[callback]) {\r\n                    $(that).unbind(makeEventName(eventName), callbackSpace[callback]);\r\n\r\n                    // Remove the callback from the callback map\r\n                    delete callbackSpace[callback];\r\n\r\n                    // Check if there are any members left on the event, if not we need to destroy it.\r\n                    if (!hasMembers(callbackSpace)) {\r\n                        delete callbackMap[eventName];\r\n                    }\r\n                } else if (!callback) {\r\n                    // Check if we're removing the whole event and we didn't error because of an invalid callback\r\n                    $(that).unbind(makeEventName(eventName));\r\n\r\n                    delete callbackMap[eventName];\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        invoke: function invoke(methodName) {\r\n            /// <summary>Invokes a server hub method with the given arguments.</summary>\r\n            /// <param name=\"methodName\" type=\"String\">The name of the server hub method.</param>\r\n\r\n            var that = this,\r\n                connection = that.connection,\r\n                args = $.makeArray(arguments).slice(1),\r\n                argValues = map(args, getArgValue),\r\n                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },\r\n                d = $.Deferred(),\r\n                callback = function callback(minResult) {\r\n                var result = that._maximizeHubResponse(minResult),\r\n                    source,\r\n                    error;\r\n\r\n                // Update the hub state\r\n                $.extend(that.state, result.State);\r\n\r\n                if (result.Progress) {\r\n                    if (d.notifyWith) {\r\n                        // Progress is only supported in jQuery 1.7+\r\n                        d.notifyWith(that, [result.Progress.Data]);\r\n                    } else if (!connection._.progressjQueryVersionLogged) {\r\n                        connection.log(\"A hub method invocation progress update was received but the version of jQuery in use (\" + $.prototype.jquery + \") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications.\");\r\n                        connection._.progressjQueryVersionLogged = true;\r\n                    }\r\n                } else if (result.Error) {\r\n                    // Server hub method threw an exception, log it & reject the deferred\r\n                    if (result.StackTrace) {\r\n                        connection.log(result.Error + \"\\n\" + result.StackTrace + \".\");\r\n                    }\r\n\r\n                    // result.ErrorData is only set if a HubException was thrown\r\n                    source = result.IsHubException ? \"HubException\" : \"Exception\";\r\n                    error = signalR._.error(result.Error, source);\r\n                    error.data = result.ErrorData;\r\n\r\n                    connection.log(that.hubName + \".\" + methodName + \" failed to execute. Error: \" + error.message);\r\n                    d.rejectWith(that, [error]);\r\n                } else {\r\n                    // Server invocation succeeded, resolve the deferred\r\n                    connection.log(\"Invoked \" + that.hubName + \".\" + methodName);\r\n                    d.resolveWith(that, [result.Result]);\r\n                }\r\n            };\r\n\r\n            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };\r\n            connection._.invocationCallbackId += 1;\r\n\r\n            if (!$.isEmptyObject(that.state)) {\r\n                data.S = that.state;\r\n            }\r\n\r\n            connection.log(\"Invoking \" + that.hubName + \".\" + methodName);\r\n            connection.send(data);\r\n\r\n            return d.promise();\r\n        },\r\n\r\n        _maximizeHubResponse: function _maximizeHubResponse(minHubResponse) {\r\n            return {\r\n                State: minHubResponse.S,\r\n                Result: minHubResponse.R,\r\n                Progress: minHubResponse.P ? {\r\n                    Id: minHubResponse.P.I,\r\n                    Data: minHubResponse.P.D\r\n                } : null,\r\n                Id: minHubResponse.I,\r\n                IsHubException: minHubResponse.H,\r\n                Error: minHubResponse.E,\r\n                StackTrace: minHubResponse.T,\r\n                ErrorData: minHubResponse.D\r\n            };\r\n        }\r\n    };\r\n\r\n    hubProxy.fn.init.prototype = hubProxy.fn;\r\n\r\n    // hubConnection\r\n    function hubConnection(url, options) {\r\n        /// <summary>Creates a new hub connection.</summary>\r\n        /// <param name=\"url\" type=\"String\">[Optional] The hub route url, defaults to \"/signalr\".</param>\r\n        /// <param name=\"options\" type=\"Object\">[Optional] Settings to use when creating the hubConnection.</param>\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        };\r\n\r\n        $.extend(settings, options);\r\n\r\n        if (!url || settings.useDefaultPath) {\r\n            url = (url || \"\") + \"/signalr\";\r\n        }\r\n        return new hubConnection.fn.init(url, settings);\r\n    }\r\n\r\n    hubConnection.fn = hubConnection.prototype = $.connection();\r\n\r\n    hubConnection.fn.init = function (url, options) {\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        },\r\n            connection = this;\r\n\r\n        $.extend(settings, options);\r\n\r\n        // Call the base constructor\r\n        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);\r\n\r\n        // Object to store hub proxies for this connection\r\n        connection.proxies = {};\r\n\r\n        connection._.invocationCallbackId = 0;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Wire up the received handler\r\n        connection.received(function (minData) {\r\n            var data, proxy, dataCallbackId, callback, hubName, eventName;\r\n            if (!minData) {\r\n                return;\r\n            }\r\n\r\n            // We have to handle progress updates first in order to ensure old clients that receive\r\n            // progress updates enter the return value branch and then no-op when they can't find\r\n            // the callback in the map (because the minData.I value will not be a valid callback ID)\r\n            if (typeof minData.P !== \"undefined\") {\r\n                // Process progress notification\r\n                dataCallbackId = minData.P.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else if (typeof minData.I !== \"undefined\") {\r\n                // We received the return value from a server method invocation, look up callback by id and call it\r\n                dataCallbackId = minData.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    // Delete the callback from the proxy\r\n                    connection._.invocationCallbacks[dataCallbackId] = null;\r\n                    delete connection._.invocationCallbacks[dataCallbackId];\r\n\r\n                    // Invoke the callback\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else {\r\n                data = this._maximizeClientHubInvocation(minData);\r\n\r\n                // We received a client invocation request, i.e. broadcast from server hub\r\n                connection.log(\"Triggering client hub event '\" + data.Method + \"' on hub '\" + data.Hub + \"'.\");\r\n\r\n                // Normalize the names to lowercase\r\n                hubName = data.Hub.toLowerCase();\r\n                eventName = data.Method.toLowerCase();\r\n\r\n                // Trigger the local invocation event\r\n                proxy = this.proxies[hubName];\r\n\r\n                // Update the hub state\r\n                $.extend(proxy.state, data.State);\r\n                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);\r\n            }\r\n        });\r\n\r\n        connection.error(function (errData, origData) {\r\n            var callbackId, callback;\r\n\r\n            if (!origData) {\r\n                // No original data passed so this is not a send error\r\n                return;\r\n            }\r\n\r\n            callbackId = origData.I;\r\n            callback = connection._.invocationCallbacks[callbackId];\r\n\r\n            // Verify that there is a callback bound (could have been cleared)\r\n            if (callback) {\r\n                // Delete the callback\r\n                connection._.invocationCallbacks[callbackId] = null;\r\n                delete connection._.invocationCallbacks[callbackId];\r\n\r\n                // Invoke the callback with an error to reject the promise\r\n                callback.method.call(callback.scope, { E: errData });\r\n            }\r\n        });\r\n\r\n        connection.reconnecting(function () {\r\n            if (connection.transport && connection.transport.name === \"webSockets\") {\r\n                clearInvocationCallbacks(connection, \"Connection started reconnecting before invocation result was received.\");\r\n            }\r\n        });\r\n\r\n        connection.disconnected(function () {\r\n            clearInvocationCallbacks(connection, \"Connection was disconnected before invocation result was received.\");\r\n        });\r\n    };\r\n\r\n    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {\r\n        return {\r\n            Hub: minClientHubInvocation.H,\r\n            Method: minClientHubInvocation.M,\r\n            Args: minClientHubInvocation.A,\r\n            State: minClientHubInvocation.S\r\n        };\r\n    };\r\n\r\n    hubConnection.fn._registerSubscribedHubs = function () {\r\n        /// <summary>\r\n        ///     Sets the starting event to loop through the known hubs and register any new hubs\r\n        ///     that have been added to the proxy.\r\n        /// </summary>\r\n        var connection = this;\r\n\r\n        if (!connection._subscribedToHubs) {\r\n            connection._subscribedToHubs = true;\r\n            connection.starting(function () {\r\n                // Set the connection's data object with all the hub proxies with active subscriptions.\r\n                // These proxies will receive notifications from the server.\r\n                var subscribedHubs = [];\r\n\r\n                $.each(connection.proxies, function (key) {\r\n                    if (this.hasSubscriptions()) {\r\n                        subscribedHubs.push({ name: key });\r\n                        connection.log(\"Client subscribed to hub '\" + key + \"'.\");\r\n                    }\r\n                });\r\n\r\n                if (subscribedHubs.length === 0) {\r\n                    connection.log(\"No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.\");\r\n                }\r\n\r\n                connection.data = connection.json.stringify(subscribedHubs);\r\n            });\r\n        }\r\n    };\r\n\r\n    hubConnection.fn.createHubProxy = function (hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        /// <param name=\"hubName\" type=\"String\">\r\n        ///     The name of the hub on the server to create the proxy for.\r\n        /// </param>\r\n\r\n        // Normalize the name to lowercase\r\n        hubName = hubName.toLowerCase();\r\n\r\n        var proxy = this.proxies[hubName];\r\n        if (!proxy) {\r\n            proxy = hubProxy(this, hubName);\r\n            this.proxies[hubName] = proxy;\r\n        }\r\n\r\n        this._registerSubscribedHubs();\r\n\r\n        return proxy;\r\n    };\r\n\r\n    hubConnection.fn.init.prototype = hubConnection.fn;\r\n\r\n    $.hubConnection = hubConnection;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.version.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n(function ($, undefined) {\r\n    $.signalR.version = \"2.2.1\";\r\n})(jQueryShim);\r\n\r\nvar hubConnection = exports.hubConnection = jQueryShim.hubConnection;\r\nvar signalR = exports.signalR = jQueryShim.signalR;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/signalr-no-jquery/build/signalR.js\n// module id = 621\n// module chunks = 3","'use strict';\r\n\r\nvar jQueryDeferred = require('jquery-deferred');\r\nvar jQueryParam = require('jquery-param');\r\n\r\nvar jqueryFunction = function jqueryFunction(subject) {\r\n  var events = subject.events || {};\r\n\r\n  if (subject && subject === subject.window) return {\r\n    0: subject,\r\n    load: function load(handler) {\r\n      return subject.addEventListener('load', handler, false);\r\n    },\r\n    bind: function bind(event, handler) {\r\n      return subject.addEventListener(event, handler, false);\r\n    },\r\n    unbind: function unbind(event, handler) {\r\n      return subject.removeEventListener(event, handler, false);\r\n    }\r\n  };\r\n\r\n  return {\r\n    0: subject,\r\n\r\n    unbind: function unbind(event, handler) {\r\n      var handlers = events[event] || [];\r\n\r\n      if (handler) {\r\n        var idx = handlers.indexOf(handler);\r\n        if (idx !== -1) handlers.splice(idx, 1);\r\n      } else handlers = [];\r\n\r\n      events[event] = handlers;\r\n      subject.events = events;\r\n    },\r\n    bind: function bind(event, handler) {\r\n      var current = events[event] || [];\r\n      events[event] = current.concat(handler);\r\n      subject.events = events;\r\n    },\r\n    triggerHandler: function triggerHandler(event, args) {\r\n      var _this = this;\r\n\r\n      var handlers = events[event] || [];\r\n      handlers.forEach(function (fn) {\r\n        if (args && args[0] && args[0].type === undefined) {\r\n          args = [{\r\n            type: event\r\n          }].concat(args || []);\r\n        } else {\r\n          args = args || [];\r\n        }\r\n\r\n        fn.apply(_this, args);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\nvar xhr = function xhr() {\r\n  try {\r\n    return new window.XMLHttpRequest();\r\n  } catch (e) {}\r\n};\r\n\r\nvar ajax = function ajax(options) {\r\n  var request = xhr();\r\n  request.onreadystatechange = function () {\r\n    if (request.readyState !== 4) {\r\n      return;\r\n    }\r\n\r\n    if (request.status === 200 && !request._hasError) {\r\n      options.success && options.success(JSON.parse(request.responseText));\r\n    } else {\r\n      options.error && options.error(request);\r\n    }\r\n  };\r\n\r\n  request.open(options.type, options.url);\r\n  request.setRequestHeader('content-type', options.contentType);\r\n\r\n  request.send(options.data.data && 'data=' + options.data.data);\r\n\r\n  return {\r\n    abort: function abort(reason) {\r\n      return request.abort(reason);\r\n    }\r\n  };\r\n};\r\n\r\nmodule.exports = jQueryDeferred.extend(jqueryFunction, jQueryDeferred, {\r\n  defaultAjaxHeaders: null,\r\n  ajax: ajax,\r\n  inArray: function inArray(arr, item) {\r\n    return arr.indexOf(item) !== -1;\r\n  },\r\n  trim: function trim(str) {\r\n    return str && str.trim();\r\n  },\r\n  isEmptyObject: function isEmptyObject(obj) {\r\n    return !obj || Object.keys(obj).length === 0;\r\n  },\r\n  makeArray: function makeArray(arr) {\r\n    return [].slice.call(arr, 0);\r\n  },\r\n  param: function param(obj) {\r\n    return jQueryParam(obj);\r\n  },\r\n  support: {\r\n    cors: function () {\r\n      var xhrObj = xhr();\r\n      return !!xhrObj && \"withCredentials\" in xhrObj;\r\n    }()\r\n  }\r\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/signalr-no-jquery/build/jQueryShim.js\n// module id = 622\n// module chunks = 3","\nmodule.exports = require('./lib/jquery-deferred');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-deferred/index.js\n// module id = 623\n// module chunks = 3","\n/*!\n* jquery-deferred\n* Copyright(c) 2011 Hidden <zzdhidden@gmail.com>\n* MIT Licensed\n*/\n\n/**\n* Library version.\n*/\n\nvar jQuery = module.exports = require(\"./jquery-callbacks.js\"),\n\tcore_slice = Array.prototype.slice;\n\n/**\n* jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/deferred.js\n* Doc: http://api.jquery.com/category/deferred-object/\n*\n*/\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ]( jQuery.isFunction( fn ) ?\n\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\tvar returned = fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} :\n\t\t\t\t\t\t\t\tnewDefer[ action ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ] = list.fire\n\t\t\tdeferred[ tuple[0] ] = list.fire;\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-deferred/lib/jquery-deferred.js\n// module id = 624\n// module chunks = 3","var jQuery = module.exports = require(\"./jquery-core.js\"),\n\tcore_rspace = /\\s+/;\n/**\n* jQuery Callbacks\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/callbacks.js\n*\n*/\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.split( core_rspace ), function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Control if a given callback is in the list\n\t\t\thas: function( fn ) {\n\t\t\t\treturn jQuery.inArray( fn, list ) > -1;\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-deferred/lib/jquery-callbacks.js\n// module id = 625\n// module chunks = 3","/**\n* jQuery core object.\n*\n* Worker with jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/core.js\n*\n*/\n\nvar jQuery = module.exports = {\n\ttype: type\n\t, isArray: isArray\n\t, isFunction: isFunction\n\t, isPlainObject: isPlainObject\n\t, each: each\n\t, extend: extend\n\t, noop: function() {}\n};\n\nvar toString = Object.prototype.toString;\n\nvar class2type = {};\n// Populate the class2type map\n\"Boolean Number String Function Array Date RegExp Object\".split(\" \").forEach(function(name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\n\nfunction type( obj ) {\n\treturn obj == null ?\n\t\tString( obj ) :\n\t\t\tclass2type[ toString.call(obj) ] || \"object\";\n}\n\nfunction isFunction( obj ) {\n\treturn jQuery.type(obj) === \"function\";\n}\n\nfunction isArray( obj ) {\n\treturn jQuery.type(obj) === \"array\";\n}\n\nfunction each( object, callback, args ) {\n\tvar name, i = 0,\n\tlength = object.length,\n\tisObj = length === undefined || isFunction( object );\n\n\tif ( args ) {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t} else {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn object;\n}\n\nfunction isPlainObject( obj ) {\n\t// Must be an Object.\n\tif ( !obj || jQuery.type(obj) !== \"object\" ) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\ttarget = arguments[0] || {},\n\ti = 1,\n\tlength = arguments.length,\n\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-deferred/lib/jquery-core.js\n// module id = 626\n// module chunks = 3","/**\n * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT\n */\n(function (global) {\n    'use strict';\n\n    var param = function (a) {\n        var s = [], rbracket = /\\[\\]$/,\n            isArray = function (obj) {\n                return Object.prototype.toString.call(obj) === '[object Array]';\n            }, add = function (k, v) {\n                v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n                s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n            }, buildParams = function (prefix, obj) {\n                var i, len, key;\n\n                if (prefix) {\n                    if (isArray(obj)) {\n                        for (i = 0, len = obj.length; i < len; i++) {\n                            if (rbracket.test(prefix)) {\n                                add(prefix, obj[i]);\n                            } else {\n                                buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i]);\n                            }\n                        }\n                    } else if (obj && String(obj) === '[object Object]') {\n                        for (key in obj) {\n                            buildParams(prefix + '[' + key + ']', obj[key]);\n                        }\n                    } else {\n                        add(prefix, obj);\n                    }\n                } else if (isArray(obj)) {\n                    for (i = 0, len = obj.length; i < len; i++) {\n                        add(obj[i].name, obj[i].value);\n                    }\n                } else {\n                    for (key in obj) {\n                        buildParams(key, obj[key]);\n                    }\n                }\n                return s;\n            };\n\n        return buildParams('', a).join('&').replace(/%20/g, '+');\n    };\n\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = param;\n    } else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return param;\n        });\n    } else {\n        global.param = param;\n    }\n\n}(this));\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/jquery-param/jquery-param.js\n// module id = 627\n// module chunks = 3","import odata from '../../../api/odata'\n\nexport default {\n  namespaced: true,\n  state: {\n    supplier: {},\n    currentApplicant: {}\n  },\n  actions: {\n    GET_SUPPLIER: (context) => {\n      odata('Suppliers').find(5).expand('Offers($expand=Applications)').get(function (data) {\n        //  console.log(data)\n        context.commit('SUPPLIER_UPDATED', data)\n      })\n    },\n    SAVE_OFFER: ({commit}, offer) => {\n      // post request here\n      odata('Suppliers(5)/Offers').post(offer).save(function (data) {\n        //  console.log(data)\n        commit('ADD_OFFER', offer)\n      })\n    },\n    GET_OFFER_APPLICATIONS: ({commit}, offerId) => {\n      return new Promise((resolve, reject) => {\n        odata('Offers(' + offerId + ')/Applications').expand('Applicant($expand=Scores($orderby=Date))').get(function (data) {\n          resolve(data)\n          // commit('SET_CURRENT_APPLICANT', data)\n        })\n      })\n    }\n  },\n  getters: {\n    supplier: state => state.supplier,\n    offers: state => state.supplier.Offers\n  },\n  mutations: {\n    SUPPLIER_UPDATED: (state, supplier) => {\n      state.supplier = supplier\n    },\n    ADD_OFFER: (state, offer) => {\n      // state.supplier.Offers = []\n      state.supplier.Offers.push(offer)\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/modules/supplier/store/index.js","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"app\"},[_c('AppHeader'),_vm._v(\" \"),_c('div',{staticClass:\"app-body\"},[_c('Sidebar',{attrs:{\"navItems\":_vm.nav}}),_vm._v(\" \"),_c('main',{staticClass:\"main\"},[_c('div',{staticClass:\"container-fluid\"},[_c('router-view')],1)])],1)],1)}\nvar staticRenderFns = []\nvar esExports = { render: render, staticRenderFns: staticRenderFns }\nexport default esExports\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vue-loader/lib/template-compiler?{\"id\":\"data-v-e231a1e4\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0!./src/modules/supplier/index.vue\n// module id = 629\n// module chunks = 3"],"sourceRoot":""}